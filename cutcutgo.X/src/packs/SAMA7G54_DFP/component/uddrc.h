/*
 * Component description for UDDRC
 *
 * Copyright (c) 2021 Microchip Technology Inc. and its subsidiaries.
 *
 * Subject to your compliance with these terms, you may use Microchip software and any derivatives
 * exclusively with Microchip products. It is your responsibility to comply with third party license
 * terms applicable to your use of third party software (including open source software) that may
 * accompany Microchip software.
 *
 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY,
 * APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, INCIDENTAL OR CONSEQUENTIAL
 * LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF
 * MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT
 * ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT
 * EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 *
 */

/* file generated from device description version 2021-07-26T12:51:16Z */
#ifndef _SAMA7G_UDDRC_COMPONENT_H_
#define _SAMA7G_UDDRC_COMPONENT_H_

/* ************************************************************************** */
/*   SOFTWARE API DEFINITION FOR UDDRC                                        */
/* ************************************************************************** */

/* -------- UDDRC_MSTR : (UDDRC Offset: 0x00) (R/W 32) Master Register 0 -------- */
#define UDDRC_MSTR_RESETVALUE                 _U_(0x40001)                                         /**<  (UDDRC_MSTR) Master Register 0  Reset Value */

#define UDDRC_MSTR_DDR3_Pos                   _U_(0)                                               /**< (UDDRC_MSTR) Select DDR3 SDRAM  - 1 - DDR3 SDRAM device in use  - 0 - non-DDR3 SDRAM device in use Only present in designs that support DDR3. Programming Mode: Static Position */
#define UDDRC_MSTR_DDR3_Msk                   (_U_(0x1) << UDDRC_MSTR_DDR3_Pos)                    /**< (UDDRC_MSTR) Select DDR3 SDRAM  - 1 - DDR3 SDRAM device in use  - 0 - non-DDR3 SDRAM device in use Only present in designs that support DDR3. Programming Mode: Static Mask */
#define UDDRC_MSTR_DDR3(value)                (UDDRC_MSTR_DDR3_Msk & ((value) << UDDRC_MSTR_DDR3_Pos))
#define UDDRC_MSTR_MOBILE_Pos                 _U_(1)                                               /**< (UDDRC_MSTR) Select mDDR SDRAM  - 1 - Mobile/LPDDR SDRAM device in use  - 0 - non-mobile SDRAM device in use This is only present for designs supporting mDDR. Programming Mode: Static Position */
#define UDDRC_MSTR_MOBILE_Msk                 (_U_(0x1) << UDDRC_MSTR_MOBILE_Pos)                  /**< (UDDRC_MSTR) Select mDDR SDRAM  - 1 - Mobile/LPDDR SDRAM device in use  - 0 - non-mobile SDRAM device in use This is only present for designs supporting mDDR. Programming Mode: Static Mask */
#define UDDRC_MSTR_MOBILE(value)              (UDDRC_MSTR_MOBILE_Msk & ((value) << UDDRC_MSTR_MOBILE_Pos))
#define UDDRC_MSTR_LPDDR2_Pos                 _U_(2)                                               /**< (UDDRC_MSTR) Select LPDDR2 SDRAM  - 1 - LPDDR2 SDRAM device in use.  - 0 - non-LPDDR2 device in use Present only in designs configured to support LPDDR2. Programming Mode: Static Position */
#define UDDRC_MSTR_LPDDR2_Msk                 (_U_(0x1) << UDDRC_MSTR_LPDDR2_Pos)                  /**< (UDDRC_MSTR) Select LPDDR2 SDRAM  - 1 - LPDDR2 SDRAM device in use.  - 0 - non-LPDDR2 device in use Present only in designs configured to support LPDDR2. Programming Mode: Static Mask */
#define UDDRC_MSTR_LPDDR2(value)              (UDDRC_MSTR_LPDDR2_Msk & ((value) << UDDRC_MSTR_LPDDR2_Pos))
#define UDDRC_MSTR_LPDDR3_Pos                 _U_(3)                                               /**< (UDDRC_MSTR) Select LPDDR3 SDRAM  - 1 - LPDDR3 SDRAM device in use.  - 0 - non-LPDDR3 device in use Present only in designs configured to support LPDDR3. Programming Mode: Static Position */
#define UDDRC_MSTR_LPDDR3_Msk                 (_U_(0x1) << UDDRC_MSTR_LPDDR3_Pos)                  /**< (UDDRC_MSTR) Select LPDDR3 SDRAM  - 1 - LPDDR3 SDRAM device in use.  - 0 - non-LPDDR3 device in use Present only in designs configured to support LPDDR3. Programming Mode: Static Mask */
#define UDDRC_MSTR_LPDDR3(value)              (UDDRC_MSTR_LPDDR3_Msk & ((value) << UDDRC_MSTR_LPDDR3_Pos))
#define UDDRC_MSTR_BURST_MODE_Pos             _U_(8)                                               /**< (UDDRC_MSTR) Interleaved burst mode not supported for LpDDR3 - For DDR2 can be set to 1 Position */
#define UDDRC_MSTR_BURST_MODE_Msk             (_U_(0x1) << UDDRC_MSTR_BURST_MODE_Pos)              /**< (UDDRC_MSTR) Interleaved burst mode not supported for LpDDR3 - For DDR2 can be set to 1 Mask */
#define UDDRC_MSTR_BURST_MODE(value)          (UDDRC_MSTR_BURST_MODE_Msk & ((value) << UDDRC_MSTR_BURST_MODE_Pos))
#define UDDRC_MSTR_BURSTCHOP_Pos              _U_(9)                                               /**< (UDDRC_MSTR) When set, enable burst-chop (BC4 or 8 on-the-fly) in DDR3/DDR4. Burst Chop for Reads is exercised only in HIF configurations (UMCTL2_INCL_ARB not set) and if in full bus width mode (MSTR.data_bus_width = 00) and if MEMC_BURST_LENGTH=8 or 16. Burst Chop for Writes is exercised only if Partial Writes enabled (UMCTL2_PARTIAL_WR=1) and if CRC is disabled (CRCPARCTL1.crc_enable = 0).  BC4 (fixed) mode is not supported. Programming Mode: Static Position */
#define UDDRC_MSTR_BURSTCHOP_Msk              (_U_(0x1) << UDDRC_MSTR_BURSTCHOP_Pos)               /**< (UDDRC_MSTR) When set, enable burst-chop (BC4 or 8 on-the-fly) in DDR3/DDR4. Burst Chop for Reads is exercised only in HIF configurations (UMCTL2_INCL_ARB not set) and if in full bus width mode (MSTR.data_bus_width = 00) and if MEMC_BURST_LENGTH=8 or 16. Burst Chop for Writes is exercised only if Partial Writes enabled (UMCTL2_PARTIAL_WR=1) and if CRC is disabled (CRCPARCTL1.crc_enable = 0).  BC4 (fixed) mode is not supported. Programming Mode: Static Mask */
#define UDDRC_MSTR_BURSTCHOP(value)           (UDDRC_MSTR_BURSTCHOP_Msk & ((value) << UDDRC_MSTR_BURSTCHOP_Pos))
#define UDDRC_MSTR_EN_2T_TIMING_MODE_Pos      _U_(10)                                              /**< (UDDRC_MSTR) If 1, then uMCTL2 uses 2T timing. Otherwise, uses 1T timing. In 2T timing, all command signals (except chip select) are held for 2 clocks on the SDRAM bus. Chip select is asserted on the second cycle of the command  Note:   - 2T timing is not supported in LPDDR2/LPDDR3/LPDDR4 mode  - 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set  - 2T timing is not supported in DDR4 geardown mode.  - 2T timing is not supported in Shared-AC dual channel mode and the register value is don't care. Programming Mode: Static Position */
#define UDDRC_MSTR_EN_2T_TIMING_MODE_Msk      (_U_(0x1) << UDDRC_MSTR_EN_2T_TIMING_MODE_Pos)       /**< (UDDRC_MSTR) If 1, then uMCTL2 uses 2T timing. Otherwise, uses 1T timing. In 2T timing, all command signals (except chip select) are held for 2 clocks on the SDRAM bus. Chip select is asserted on the second cycle of the command  Note:   - 2T timing is not supported in LPDDR2/LPDDR3/LPDDR4 mode  - 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set  - 2T timing is not supported in DDR4 geardown mode.  - 2T timing is not supported in Shared-AC dual channel mode and the register value is don't care. Programming Mode: Static Mask */
#define UDDRC_MSTR_EN_2T_TIMING_MODE(value)   (UDDRC_MSTR_EN_2T_TIMING_MODE_Msk & ((value) << UDDRC_MSTR_EN_2T_TIMING_MODE_Pos))
#define UDDRC_MSTR_DATA_BUS_WIDTH_Pos         _U_(12)                                              /**< (UDDRC_MSTR) Selects proportion of DQ bus width that is used by the SDRAM  - 00 - Full DQ bus width to SDRAM  - 01 - Half DQ bus width to SDRAM  - 10 - Quarter DQ bus width to SDRAM  - 11 - Reserved. Note that half bus width mode is only supported when the SDRAM bus width is a multiple of 16, and quarter bus width mode is only supported when the SDRAM bus width is a multiple of 32 and the configuration parameter MEMC_QBUS_SUPPORT is set. Bus width refers to DQ bus width (excluding any ECC width). Programming Mode: Static Position */
#define UDDRC_MSTR_DATA_BUS_WIDTH_Msk         (_U_(0x3) << UDDRC_MSTR_DATA_BUS_WIDTH_Pos)          /**< (UDDRC_MSTR) Selects proportion of DQ bus width that is used by the SDRAM  - 00 - Full DQ bus width to SDRAM  - 01 - Half DQ bus width to SDRAM  - 10 - Quarter DQ bus width to SDRAM  - 11 - Reserved. Note that half bus width mode is only supported when the SDRAM bus width is a multiple of 16, and quarter bus width mode is only supported when the SDRAM bus width is a multiple of 32 and the configuration parameter MEMC_QBUS_SUPPORT is set. Bus width refers to DQ bus width (excluding any ECC width). Programming Mode: Static Mask */
#define UDDRC_MSTR_DATA_BUS_WIDTH(value)      (UDDRC_MSTR_DATA_BUS_WIDTH_Msk & ((value) << UDDRC_MSTR_DATA_BUS_WIDTH_Pos))
#define UDDRC_MSTR_DLL_OFF_MODE_Pos           _U_(15)                                              /**< (UDDRC_MSTR) Set to 1 when the uMCTL2 and DRAM has to be put in DLL-off mode for low frequency operation.  Set to 0 to put uMCTL2 and DRAM in DLL-on mode for normal frequency operation.  If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), dll_off_mode is not supported, and this bit must be set to '0'.  Programming Mode: Quasi-dynamic Group 2 Position */
#define UDDRC_MSTR_DLL_OFF_MODE_Msk           (_U_(0x1) << UDDRC_MSTR_DLL_OFF_MODE_Pos)            /**< (UDDRC_MSTR) Set to 1 when the uMCTL2 and DRAM has to be put in DLL-off mode for low frequency operation.  Set to 0 to put uMCTL2 and DRAM in DLL-on mode for normal frequency operation.  If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), dll_off_mode is not supported, and this bit must be set to '0'.  Programming Mode: Quasi-dynamic Group 2 Mask */
#define UDDRC_MSTR_DLL_OFF_MODE(value)        (UDDRC_MSTR_DLL_OFF_MODE_Msk & ((value) << UDDRC_MSTR_DLL_OFF_MODE_Pos))
#define UDDRC_MSTR_BURST_RDWR_Pos             _U_(16)                                              /**< (UDDRC_MSTR) SDRAM burst length used:  - 0001 - Burst length of 2 (only supported for mDDR)  - 0010 - Burst length of 4  - 0100 - Burst length of 8  - 1000 - Burst length of 16 (only supported for mDDR, LPDDR2, and LPDDR4)  All other values are reserved. This controls the burst size used to access the SDRAM. This must match the burst length mode register setting in the SDRAM. (For BC4/8 on-the-fly mode of DDR3 and DDR4, set this field to 0x0100) Burst length of 2 is not supported with AXI ports when MEMC_BURST_LENGTH is 8.   Burst length of 2 is only supported when the controller is operating in 1:1 frequency mode.    For DDR3, DDR4 and LPDDR3, this must be set to 0x0100 (BL8).    For LPDDR4, this must be set to 0x1000 (BL16). Programming Mode: Static Position */
#define UDDRC_MSTR_BURST_RDWR_Msk             (_U_(0xF) << UDDRC_MSTR_BURST_RDWR_Pos)              /**< (UDDRC_MSTR) SDRAM burst length used:  - 0001 - Burst length of 2 (only supported for mDDR)  - 0010 - Burst length of 4  - 0100 - Burst length of 8  - 1000 - Burst length of 16 (only supported for mDDR, LPDDR2, and LPDDR4)  All other values are reserved. This controls the burst size used to access the SDRAM. This must match the burst length mode register setting in the SDRAM. (For BC4/8 on-the-fly mode of DDR3 and DDR4, set this field to 0x0100) Burst length of 2 is not supported with AXI ports when MEMC_BURST_LENGTH is 8.   Burst length of 2 is only supported when the controller is operating in 1:1 frequency mode.    For DDR3, DDR4 and LPDDR3, this must be set to 0x0100 (BL8).    For LPDDR4, this must be set to 0x1000 (BL16). Programming Mode: Static Mask */
#define UDDRC_MSTR_BURST_RDWR(value)          (UDDRC_MSTR_BURST_RDWR_Msk & ((value) << UDDRC_MSTR_BURST_RDWR_Pos))
#define UDDRC_MSTR_Msk                        _U_(0x000FB70F)                                      /**< (UDDRC_MSTR) Register Mask  */

#define UDDRC_MSTR_DDR_Pos                    _U_(0)                                               /**< (UDDRC_MSTR Position) Select DDR3 SDRAM  - x - DDR3 SDRAM device in use  - x - non-DDR3 SDRAM device in use Only present in designs that support DDR3. Programming Mode: Static */
#define UDDRC_MSTR_DDR_Msk                    (_U_(0x1) << UDDRC_MSTR_DDR_Pos)                     /**< (UDDRC_MSTR Mask) DDR */
#define UDDRC_MSTR_DDR(value)                 (UDDRC_MSTR_DDR_Msk & ((value) << UDDRC_MSTR_DDR_Pos)) 
#define UDDRC_MSTR_LPDDR_Pos                  _U_(2)                                               /**< (UDDRC_MSTR Position) Select LPDDR2 SDRAM  - x - LPDDR2 SDRAM device in use.  - x - non-LPDDR2 device in use Present only in designs configured to support LPDDR2. Programming Mode: Static */
#define UDDRC_MSTR_LPDDR_Msk                  (_U_(0x3) << UDDRC_MSTR_LPDDR_Pos)                   /**< (UDDRC_MSTR Mask) LPDDR */
#define UDDRC_MSTR_LPDDR(value)               (UDDRC_MSTR_LPDDR_Msk & ((value) << UDDRC_MSTR_LPDDR_Pos)) 

/* -------- UDDRC_STAT : (UDDRC Offset: 0x04) ( R/ 32) Operating Mode Status Register -------- */
#define UDDRC_STAT_RESETVALUE                 _U_(0x00)                                            /**<  (UDDRC_STAT) Operating Mode Status Register  Reset Value */

#define UDDRC_STAT_OPERATING_MODE_Pos         _U_(0)                                               /**< (UDDRC_STAT) Operating mode. This is 3-bits wide in configurations with mDDR/LPDDR2/LPDDR3/LPDDR4/DDR4 support and 2-bits in all other configurations. non-mDDR/LPDDR2/LPDDR3/LPDDR4 and non-DDR4 designs:  - 00 - Init  - 01 - Normal  - 10 - Power-down  - 11 - Self refresh mDDR/LPDDR2/LPDDR3 or DDR4 designs:  - 000 - Init  - 001 - Normal  - 010 - Power-down  - 011 - Self refresh  - 1XX - Deep power-down / Maximum Power Saving Mode LPDDR4 designs:  - 000 - Init  - 001 - Normal  - 010 - Power-down  - 011 - Self refresh / Self refresh power-down  Programming Mode: Static Position */
#define UDDRC_STAT_OPERATING_MODE_Msk         (_U_(0x7) << UDDRC_STAT_OPERATING_MODE_Pos)          /**< (UDDRC_STAT) Operating mode. This is 3-bits wide in configurations with mDDR/LPDDR2/LPDDR3/LPDDR4/DDR4 support and 2-bits in all other configurations. non-mDDR/LPDDR2/LPDDR3/LPDDR4 and non-DDR4 designs:  - 00 - Init  - 01 - Normal  - 10 - Power-down  - 11 - Self refresh mDDR/LPDDR2/LPDDR3 or DDR4 designs:  - 000 - Init  - 001 - Normal  - 010 - Power-down  - 011 - Self refresh  - 1XX - Deep power-down / Maximum Power Saving Mode LPDDR4 designs:  - 000 - Init  - 001 - Normal  - 010 - Power-down  - 011 - Self refresh / Self refresh power-down  Programming Mode: Static Mask */
#define UDDRC_STAT_OPERATING_MODE(value)      (UDDRC_STAT_OPERATING_MODE_Msk & ((value) << UDDRC_STAT_OPERATING_MODE_Pos))
#define UDDRC_STAT_SELFREF_TYPE_Pos           _U_(4)                                               /**< (UDDRC_STAT) Flags if Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4) is entered and if it was under Automatic Self Refresh control only or not.      - 00 - SDRAM is not in Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4). If retry is enabled by CRCPARCTRL1.crc_parity_retry_enable, this also indicates SRE command is still in parity error window or retry is in-progress.  - 11 - SDRAM is in Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4), which was caused by Automatic Self Refresh only. If retry is enabled, this guarantees SRE command is executed correctly without parity error.  - 10 - SDRAM is in Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4), which was not caused solely under Automatic Self Refresh control. It could have been caused by Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw). If retry is enabled, this guarantees SRE command is executed correctly without parity error.  - 01 - SDRAM is in Self Refresh, which was caused by PHY Master Request. Programming Mode: Static Position */
#define UDDRC_STAT_SELFREF_TYPE_Msk           (_U_(0x3) << UDDRC_STAT_SELFREF_TYPE_Pos)            /**< (UDDRC_STAT) Flags if Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4) is entered and if it was under Automatic Self Refresh control only or not.      - 00 - SDRAM is not in Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4). If retry is enabled by CRCPARCTRL1.crc_parity_retry_enable, this also indicates SRE command is still in parity error window or retry is in-progress.  - 11 - SDRAM is in Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4), which was caused by Automatic Self Refresh only. If retry is enabled, this guarantees SRE command is executed correctly without parity error.  - 10 - SDRAM is in Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4), which was not caused solely under Automatic Self Refresh control. It could have been caused by Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw). If retry is enabled, this guarantees SRE command is executed correctly without parity error.  - 01 - SDRAM is in Self Refresh, which was caused by PHY Master Request. Programming Mode: Static Mask */
#define UDDRC_STAT_SELFREF_TYPE(value)        (UDDRC_STAT_SELFREF_TYPE_Msk & ((value) << UDDRC_STAT_SELFREF_TYPE_Pos))
#define UDDRC_STAT_SELFREF_CAM_NOT_EMPTY_Pos  _U_(12)                                              /**< (UDDRC_STAT) Self refresh with CAMs not empty. Set to 1 when Self Refresh is entered but CAMs are not drained. Cleared after exiting Self Refresh. Programming Mode: Static Position */
#define UDDRC_STAT_SELFREF_CAM_NOT_EMPTY_Msk  (_U_(0x1) << UDDRC_STAT_SELFREF_CAM_NOT_EMPTY_Pos)   /**< (UDDRC_STAT) Self refresh with CAMs not empty. Set to 1 when Self Refresh is entered but CAMs are not drained. Cleared after exiting Self Refresh. Programming Mode: Static Mask */
#define UDDRC_STAT_SELFREF_CAM_NOT_EMPTY(value) (UDDRC_STAT_SELFREF_CAM_NOT_EMPTY_Msk & ((value) << UDDRC_STAT_SELFREF_CAM_NOT_EMPTY_Pos))
#define UDDRC_STAT_Msk                        _U_(0x00001037)                                      /**< (UDDRC_STAT) Register Mask  */


/* -------- UDDRC_MRCTRL0 : (UDDRC Offset: 0x10) (R/W 32) Mode Register Read/Write Control Register 0 -------- */
#define UDDRC_MRCTRL0_RESETVALUE              _U_(0x10)                                            /**<  (UDDRC_MRCTRL0) Mode Register Read/Write Control Register 0  Reset Value */

#define UDDRC_MRCTRL0_MR_TYPE_Pos             _U_(0)                                               /**< (UDDRC_MRCTRL0) Indicates whether the mode register operation is read or write. Only used for LPDDR2/LPDDR3/LPDDR4/DDR4.  - 0 - Write  - 1 - Read Programming Mode: Dynamic Position */
#define UDDRC_MRCTRL0_MR_TYPE_Msk             (_U_(0x1) << UDDRC_MRCTRL0_MR_TYPE_Pos)              /**< (UDDRC_MRCTRL0) Indicates whether the mode register operation is read or write. Only used for LPDDR2/LPDDR3/LPDDR4/DDR4.  - 0 - Write  - 1 - Read Programming Mode: Dynamic Mask */
#define UDDRC_MRCTRL0_MR_TYPE(value)          (UDDRC_MRCTRL0_MR_TYPE_Msk & ((value) << UDDRC_MRCTRL0_MR_TYPE_Pos))
#define UDDRC_MRCTRL0_MR_RANK_Pos             _U_(4)                                               /**< (UDDRC_MRCTRL0) Controls which rank is accessed by MRCTRL0.mr_wr. Normally, it is desired to access all ranks, so all bits should be set to 1. However, for multi-rank UDIMMs/RDIMMs/LRDIMMs which implement address mirroring, it may be necessary to access ranks individually. Examples (assume uMCTL2 is configured for 4 ranks):     - 0x1 - select rank 0 only     - 0x2 - select rank 1 only     - 0x5 - select ranks 0 and 2     - 0xA - select ranks 1 and 3     - 0xF - select ranks 0, 1, 2 and 3 Programming Mode: Dynamic Position */
#define UDDRC_MRCTRL0_MR_RANK_Msk             (_U_(0x1) << UDDRC_MRCTRL0_MR_RANK_Pos)              /**< (UDDRC_MRCTRL0) Controls which rank is accessed by MRCTRL0.mr_wr. Normally, it is desired to access all ranks, so all bits should be set to 1. However, for multi-rank UDIMMs/RDIMMs/LRDIMMs which implement address mirroring, it may be necessary to access ranks individually. Examples (assume uMCTL2 is configured for 4 ranks):     - 0x1 - select rank 0 only     - 0x2 - select rank 1 only     - 0x5 - select ranks 0 and 2     - 0xA - select ranks 1 and 3     - 0xF - select ranks 0, 1, 2 and 3 Programming Mode: Dynamic Mask */
#define UDDRC_MRCTRL0_MR_RANK(value)          (UDDRC_MRCTRL0_MR_RANK_Msk & ((value) << UDDRC_MRCTRL0_MR_RANK_Pos))
#define UDDRC_MRCTRL0_MR_ADDR_Pos             _U_(12)                                              /**< (UDDRC_MRCTRL0) Address of the mode register that is to be written to.  - 0000 - MR0  - 0001 - MR1  - 0010 - MR2  - 0011 - MR3  - 0100 - MR4  - 0101 - MR5  - 0110 - MR6  - 0111 - MR7 Don't Care for LPDDR2/LPDDR3/LPDDR4 (see MRCTRL1.mr_data for mode register addressing in LPDDR2/LPDDR3/LPDDR4).  This signal is also used for writing to control words of the register chip on RDIMMs/LRDIMMs. In that case, it corresponds to the bank address bits sent to the RDIMM/LRDIMM.  In case of DDR4, the bit[3:2] corresponds to the bank group bits. Therefore, the bit[3] as well as the bit[2:0] must be set to an appropriate value which is considered both the Address Mirroring of UDIMMs/RDIMMs/LRDIMMs and the Output Inversion of RDIMMs/LRDIMMs. Programming Mode: Dynamic Position */
#define UDDRC_MRCTRL0_MR_ADDR_Msk             (_U_(0xF) << UDDRC_MRCTRL0_MR_ADDR_Pos)              /**< (UDDRC_MRCTRL0) Address of the mode register that is to be written to.  - 0000 - MR0  - 0001 - MR1  - 0010 - MR2  - 0011 - MR3  - 0100 - MR4  - 0101 - MR5  - 0110 - MR6  - 0111 - MR7 Don't Care for LPDDR2/LPDDR3/LPDDR4 (see MRCTRL1.mr_data for mode register addressing in LPDDR2/LPDDR3/LPDDR4).  This signal is also used for writing to control words of the register chip on RDIMMs/LRDIMMs. In that case, it corresponds to the bank address bits sent to the RDIMM/LRDIMM.  In case of DDR4, the bit[3:2] corresponds to the bank group bits. Therefore, the bit[3] as well as the bit[2:0] must be set to an appropriate value which is considered both the Address Mirroring of UDIMMs/RDIMMs/LRDIMMs and the Output Inversion of RDIMMs/LRDIMMs. Programming Mode: Dynamic Mask */
#define UDDRC_MRCTRL0_MR_ADDR(value)          (UDDRC_MRCTRL0_MR_ADDR_Msk & ((value) << UDDRC_MRCTRL0_MR_ADDR_Pos))
#define UDDRC_MRCTRL0_MR_WR_Pos               _U_(31)                                              /**< (UDDRC_MRCTRL0) Setting this register bit to 1 triggers a mode register read or write operation. When the MR operation is complete, the uMCTL2 automatically clears this bit.  The other register fields of this register must be written in a separate APB transaction, before setting this mr_wr bit. It is recommended NOT to set this signal if in Init, Deep power-down or MPSM operating modes. Programming Mode: Dynamic Position */
#define UDDRC_MRCTRL0_MR_WR_Msk               (_U_(0x1) << UDDRC_MRCTRL0_MR_WR_Pos)                /**< (UDDRC_MRCTRL0) Setting this register bit to 1 triggers a mode register read or write operation. When the MR operation is complete, the uMCTL2 automatically clears this bit.  The other register fields of this register must be written in a separate APB transaction, before setting this mr_wr bit. It is recommended NOT to set this signal if in Init, Deep power-down or MPSM operating modes. Programming Mode: Dynamic Mask */
#define UDDRC_MRCTRL0_MR_WR(value)            (UDDRC_MRCTRL0_MR_WR_Msk & ((value) << UDDRC_MRCTRL0_MR_WR_Pos))
#define UDDRC_MRCTRL0_Msk                     _U_(0x8000F011)                                      /**< (UDDRC_MRCTRL0) Register Mask  */


/* -------- UDDRC_MRCTRL1 : (UDDRC Offset: 0x14) (R/W 32) Mode Register Read/Write Control Register 1 -------- */
#define UDDRC_MRCTRL1_RESETVALUE              _U_(0x00)                                            /**<  (UDDRC_MRCTRL1) Mode Register Read/Write Control Register 1  Reset Value */

#define UDDRC_MRCTRL1_MR_DATA_Pos             _U_(0)                                               /**< (UDDRC_MRCTRL1) Mode register write data for all non-LPDDR2/non-LPDDR3/non-LPDDR4 modes. For LPDDR2/LPDDR3/LPDDR4, MRCTRL1[15:0] are interpreted as [15:8] MR Address [7:0] MR data for writes, don't care for reads. This is 18-bits wide in configurations with DDR4 support and 16-bits in all other configurations. Programming Mode: Dynamic Position */
#define UDDRC_MRCTRL1_MR_DATA_Msk             (_U_(0xFFFF) << UDDRC_MRCTRL1_MR_DATA_Pos)           /**< (UDDRC_MRCTRL1) Mode register write data for all non-LPDDR2/non-LPDDR3/non-LPDDR4 modes. For LPDDR2/LPDDR3/LPDDR4, MRCTRL1[15:0] are interpreted as [15:8] MR Address [7:0] MR data for writes, don't care for reads. This is 18-bits wide in configurations with DDR4 support and 16-bits in all other configurations. Programming Mode: Dynamic Mask */
#define UDDRC_MRCTRL1_MR_DATA(value)          (UDDRC_MRCTRL1_MR_DATA_Msk & ((value) << UDDRC_MRCTRL1_MR_DATA_Pos))
#define UDDRC_MRCTRL1_Msk                     _U_(0x0000FFFF)                                      /**< (UDDRC_MRCTRL1) Register Mask  */


/* -------- UDDRC_MRSTAT : (UDDRC Offset: 0x18) ( R/ 32) Mode Register Read/Write Status Register -------- */
#define UDDRC_MRSTAT_RESETVALUE               _U_(0x00)                                            /**<  (UDDRC_MRSTAT) Mode Register Read/Write Status Register  Reset Value */

#define UDDRC_MRSTAT_MR_WR_BUSY_Pos           _U_(0)                                               /**< (UDDRC_MRSTAT) The SoC core may initiate a MR write operation only if this signal is low. This signal goes high in the clock after the uMCTL2 accepts the MRW/MRR request. It goes low when the MRW/MRR command is issued to the SDRAM. It is recommended not to perform MRW/MRR commands when 'MRSTAT.mr_wr_busy' is high.  - 0 - Indicates that the SoC core can initiate a mode register write operation  - 1 - Indicates that mode register write operation is in progress Programming Mode: Dynamic Position */
#define UDDRC_MRSTAT_MR_WR_BUSY_Msk           (_U_(0x1) << UDDRC_MRSTAT_MR_WR_BUSY_Pos)            /**< (UDDRC_MRSTAT) The SoC core may initiate a MR write operation only if this signal is low. This signal goes high in the clock after the uMCTL2 accepts the MRW/MRR request. It goes low when the MRW/MRR command is issued to the SDRAM. It is recommended not to perform MRW/MRR commands when 'MRSTAT.mr_wr_busy' is high.  - 0 - Indicates that the SoC core can initiate a mode register write operation  - 1 - Indicates that mode register write operation is in progress Programming Mode: Dynamic Mask */
#define UDDRC_MRSTAT_MR_WR_BUSY(value)        (UDDRC_MRSTAT_MR_WR_BUSY_Msk & ((value) << UDDRC_MRSTAT_MR_WR_BUSY_Pos))
#define UDDRC_MRSTAT_Msk                      _U_(0x00000001)                                      /**< (UDDRC_MRSTAT) Register Mask  */


/* -------- UDDRC_DERATEEN : (UDDRC Offset: 0x20) (R/W 32) Temperature Derate Enable Register -------- */
#define UDDRC_DERATEEN_RESETVALUE             _U_(0x00)                                            /**<  (UDDRC_DERATEEN) Temperature Derate Enable Register  Reset Value */

#define UDDRC_DERATEEN_DERATE_ENABLE_Pos      _U_(0)                                               /**< (UDDRC_DERATEEN) Enables derating  - 0 - Timing parameter derating is disabled  - 1 - Timing parameter derating is enabled using MR4 read value. Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4  This field must be set to '0' for non-LPDDR2/LPDDR3/LPDDR4 mode. Programming Mode: Dynamic Position */
#define UDDRC_DERATEEN_DERATE_ENABLE_Msk      (_U_(0x1) << UDDRC_DERATEEN_DERATE_ENABLE_Pos)       /**< (UDDRC_DERATEEN) Enables derating  - 0 - Timing parameter derating is disabled  - 1 - Timing parameter derating is enabled using MR4 read value. Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4  This field must be set to '0' for non-LPDDR2/LPDDR3/LPDDR4 mode. Programming Mode: Dynamic Mask */
#define UDDRC_DERATEEN_DERATE_ENABLE(value)   (UDDRC_DERATEEN_DERATE_ENABLE_Msk & ((value) << UDDRC_DERATEEN_DERATE_ENABLE_Pos))
#define UDDRC_DERATEEN_DERATE_VALUE_Pos       _U_(1)                                               /**< (UDDRC_DERATEEN) Derate value  - 0 - Derating uses +1  - 1 - Derating uses +2 Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4  Set to 0 for all LPDDR2 speed grades as derating value of +1.875 ns is less than a core_ddrc_core_clk period. For LPDDR3/4, if the period of core_ddrc_core_clk is less than 1.875ns, this register field should be set to 1; otherwise it should be set to 0.  Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DERATEEN_DERATE_VALUE_Msk       (_U_(0x3) << UDDRC_DERATEEN_DERATE_VALUE_Pos)        /**< (UDDRC_DERATEEN) Derate value  - 0 - Derating uses +1  - 1 - Derating uses +2 Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4  Set to 0 for all LPDDR2 speed grades as derating value of +1.875 ns is less than a core_ddrc_core_clk period. For LPDDR3/4, if the period of core_ddrc_core_clk is less than 1.875ns, this register field should be set to 1; otherwise it should be set to 0.  Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DERATEEN_DERATE_VALUE(value)    (UDDRC_DERATEEN_DERATE_VALUE_Msk & ((value) << UDDRC_DERATEEN_DERATE_VALUE_Pos))
#define UDDRC_DERATEEN_DERATE_BYTE_Pos        _U_(4)                                               /**< (UDDRC_DERATEEN) Derate byte Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4  Indicates which byte of the MRR data is used for derating. The maximum valid value depends on MEMC_DRAM_TOTAL_DATA_WIDTH.  Programming Mode: Static Position */
#define UDDRC_DERATEEN_DERATE_BYTE_Msk        (_U_(0xF) << UDDRC_DERATEEN_DERATE_BYTE_Pos)         /**< (UDDRC_DERATEEN) Derate byte Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4  Indicates which byte of the MRR data is used for derating. The maximum valid value depends on MEMC_DRAM_TOTAL_DATA_WIDTH.  Programming Mode: Static Mask */
#define UDDRC_DERATEEN_DERATE_BYTE(value)     (UDDRC_DERATEEN_DERATE_BYTE_Msk & ((value) << UDDRC_DERATEEN_DERATE_BYTE_Pos))
#define UDDRC_DERATEEN_DERATE_MR4_TUF_DIS_Pos _U_(12)                                              /**< (UDDRC_DERATEEN) Disable use of MR4 TUF flag (MR4[7]) bit.  - 0 - Use MR4 TUF flag (MR4[7])  - 1 - Do not use MR4 TUF Flag (MR4[7]) For LPDDR4, it is recommended to set this register to 1. For LPDDR2 and LPDDR3, please contact your memory vendor for recommended usage. This affects both the periodic derate logic (DERATEEN.derate_enable) and the derate_temp_limit_intr.  Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DERATEEN_DERATE_MR4_TUF_DIS_Msk (_U_(0x1) << UDDRC_DERATEEN_DERATE_MR4_TUF_DIS_Pos)  /**< (UDDRC_DERATEEN) Disable use of MR4 TUF flag (MR4[7]) bit.  - 0 - Use MR4 TUF flag (MR4[7])  - 1 - Do not use MR4 TUF Flag (MR4[7]) For LPDDR4, it is recommended to set this register to 1. For LPDDR2 and LPDDR3, please contact your memory vendor for recommended usage. This affects both the periodic derate logic (DERATEEN.derate_enable) and the derate_temp_limit_intr.  Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DERATEEN_DERATE_MR4_TUF_DIS(value) (UDDRC_DERATEEN_DERATE_MR4_TUF_DIS_Msk & ((value) << UDDRC_DERATEEN_DERATE_MR4_TUF_DIS_Pos))
#define UDDRC_DERATEEN_Msk                    _U_(0x000010F7)                                      /**< (UDDRC_DERATEEN) Register Mask  */


/* -------- UDDRC_DERATEINT : (UDDRC Offset: 0x24) (R/W 32) Temperature Derate Interval Register -------- */
#define UDDRC_DERATEINT_RESETVALUE            _U_(0x800000)                                        /**<  (UDDRC_DERATEINT) Temperature Derate Interval Register  Reset Value */

#define UDDRC_DERATEINT_MR4_READ_INTERVAL_Pos _U_(0)                                               /**< (UDDRC_DERATEINT) Interval between two MR4 reads, used to derate the timing parameters. Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4. This register must not be set to zero. Unit: DFI clock cycles. Programming Mode: Static Position */
#define UDDRC_DERATEINT_MR4_READ_INTERVAL_Msk (_U_(0xFFFFFFFF) << UDDRC_DERATEINT_MR4_READ_INTERVAL_Pos) /**< (UDDRC_DERATEINT) Interval between two MR4 reads, used to derate the timing parameters. Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4. This register must not be set to zero. Unit: DFI clock cycles. Programming Mode: Static Mask */
#define UDDRC_DERATEINT_MR4_READ_INTERVAL(value) (UDDRC_DERATEINT_MR4_READ_INTERVAL_Msk & ((value) << UDDRC_DERATEINT_MR4_READ_INTERVAL_Pos))
#define UDDRC_DERATEINT_Msk                   _U_(0xFFFFFFFF)                                      /**< (UDDRC_DERATEINT) Register Mask  */


/* -------- UDDRC_DERATECTL : (UDDRC Offset: 0x2C) (R/W 32) Temperature Derate Control Register -------- */
#define UDDRC_DERATECTL_RESETVALUE            _U_(0x01)                                            /**<  (UDDRC_DERATECTL) Temperature Derate Control Register  Reset Value */

#define UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_EN_Pos _U_(0)                                               /**< (UDDRC_DERATECTL) Interrupt enable bit for derate_temp_limit_intr output pin.   -  1 Enabled   -   0 Disabled  Programming Mode: Dynamic Position */
#define UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_EN_Msk (_U_(0x1) << UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_EN_Pos) /**< (UDDRC_DERATECTL) Interrupt enable bit for derate_temp_limit_intr output pin.   -  1 Enabled   -   0 Disabled  Programming Mode: Dynamic Mask */
#define UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_EN(value) (UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_EN_Msk & ((value) << UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_EN_Pos))
#define UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_CLR_Pos _U_(1)                                               /**< (UDDRC_DERATECTL) Interrupt clear bit for derate_temp_limit_intr.   At the end of the interrupt clear operation, the uMCTL2 automatically clears this bit. Programming Mode: Dynamic Position */
#define UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_CLR_Msk (_U_(0x1) << UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_CLR_Pos) /**< (UDDRC_DERATECTL) Interrupt clear bit for derate_temp_limit_intr.   At the end of the interrupt clear operation, the uMCTL2 automatically clears this bit. Programming Mode: Dynamic Mask */
#define UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_CLR(value) (UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_CLR_Msk & ((value) << UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_CLR_Pos))
#define UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_FORCE_Pos _U_(2)                                               /**< (UDDRC_DERATECTL) Interrupt force bit for derate_temp_limit_intr.    Setting this register to 1 will cause the derate_temp_limit_intr output pin to be asserted.   At the end of the interrupt force operation, the uMCTL2 automatically clears this bit. Programming Mode: Dynamic Position */
#define UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_FORCE_Msk (_U_(0x1) << UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_FORCE_Pos) /**< (UDDRC_DERATECTL) Interrupt force bit for derate_temp_limit_intr.    Setting this register to 1 will cause the derate_temp_limit_intr output pin to be asserted.   At the end of the interrupt force operation, the uMCTL2 automatically clears this bit. Programming Mode: Dynamic Mask */
#define UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_FORCE(value) (UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_FORCE_Msk & ((value) << UDDRC_DERATECTL_DERATE_TEMP_LIMIT_INTR_FORCE_Pos))
#define UDDRC_DERATECTL_Msk                   _U_(0x00000007)                                      /**< (UDDRC_DERATECTL) Register Mask  */


/* -------- UDDRC_PWRCTL : (UDDRC Offset: 0x30) (R/W 32) Low Power Control Register -------- */
#define UDDRC_PWRCTL_RESETVALUE               _U_(0x00)                                            /**<  (UDDRC_PWRCTL) Low Power Control Register  Reset Value */

#define UDDRC_PWRCTL_SELFREF_EN_Pos           _U_(0)                                               /**< (UDDRC_PWRCTL) If true then the uMCTL2 puts the SDRAM into Self Refresh after a programmable number of cycles "maximum idle clocks before Self Refresh (PWRTMG.selfref_to_x32)". This register bit may be re-programmed during the course of normal operation. Programming Mode: Dynamic Position */
#define UDDRC_PWRCTL_SELFREF_EN_Msk           (_U_(0x1) << UDDRC_PWRCTL_SELFREF_EN_Pos)            /**< (UDDRC_PWRCTL) If true then the uMCTL2 puts the SDRAM into Self Refresh after a programmable number of cycles "maximum idle clocks before Self Refresh (PWRTMG.selfref_to_x32)". This register bit may be re-programmed during the course of normal operation. Programming Mode: Dynamic Mask */
#define UDDRC_PWRCTL_SELFREF_EN(value)        (UDDRC_PWRCTL_SELFREF_EN_Msk & ((value) << UDDRC_PWRCTL_SELFREF_EN_Pos))
#define UDDRC_PWRCTL_POWERDOWN_EN_Pos         _U_(1)                                               /**< (UDDRC_PWRCTL) If true then the uMCTL2 goes into power-down after a programmable number of cycles "maximum idle clocks before power down" (PWRTMG.powerdown_to_x32). This register bit may be re-programmed during the course of normal operation. Programming Mode: Dynamic Position */
#define UDDRC_PWRCTL_POWERDOWN_EN_Msk         (_U_(0x1) << UDDRC_PWRCTL_POWERDOWN_EN_Pos)          /**< (UDDRC_PWRCTL) If true then the uMCTL2 goes into power-down after a programmable number of cycles "maximum idle clocks before power down" (PWRTMG.powerdown_to_x32). This register bit may be re-programmed during the course of normal operation. Programming Mode: Dynamic Mask */
#define UDDRC_PWRCTL_POWERDOWN_EN(value)      (UDDRC_PWRCTL_POWERDOWN_EN_Msk & ((value) << UDDRC_PWRCTL_POWERDOWN_EN_Pos))
#define UDDRC_PWRCTL_DEEPPOWERDOWN_EN_Pos     _U_(2)                                               /**< (UDDRC_PWRCTL) When this is 1, uMCTL2 puts the SDRAM into deep power-down mode when the transaction store is empty. This register must be reset to '0' to bring uMCTL2 out of deep power-down mode. Controller performs automatic SDRAM initialization on deep power-down exit. Present only in designs configured to support mDDR or LPDDR2 or LPDDR3. For non-mDDR/non-LPDDR2/non-LPDDR3, this register should not be set to 1. FOR PERFORMANCE ONLY. Programming Mode: Dynamic Position */
#define UDDRC_PWRCTL_DEEPPOWERDOWN_EN_Msk     (_U_(0x1) << UDDRC_PWRCTL_DEEPPOWERDOWN_EN_Pos)      /**< (UDDRC_PWRCTL) When this is 1, uMCTL2 puts the SDRAM into deep power-down mode when the transaction store is empty. This register must be reset to '0' to bring uMCTL2 out of deep power-down mode. Controller performs automatic SDRAM initialization on deep power-down exit. Present only in designs configured to support mDDR or LPDDR2 or LPDDR3. For non-mDDR/non-LPDDR2/non-LPDDR3, this register should not be set to 1. FOR PERFORMANCE ONLY. Programming Mode: Dynamic Mask */
#define UDDRC_PWRCTL_DEEPPOWERDOWN_EN(value)  (UDDRC_PWRCTL_DEEPPOWERDOWN_EN_Msk & ((value) << UDDRC_PWRCTL_DEEPPOWERDOWN_EN_Pos))
#define UDDRC_PWRCTL_EN_DFI_DRAM_CLK_DISABLE_Pos _U_(3)                                               /**< (UDDRC_PWRCTL) Enable the assertion of dfi_dram_clk_disable whenever a clock is not required by the SDRAM.  If set to 0, dfi_dram_clk_disable is never asserted.  Assertion of dfi_dram_clk_disable is as follows:  In DDR2/DDR3, can only be asserted in Self Refresh.  In DDR4, can be asserted in following:   - in Self Refresh.   - in Maximum Power Saving Mode In mDDR/LPDDR2/LPDDR3, can be asserted in following:   - in Self Refresh   - in Power Down   - in Deep Power Down   - during Normal operation (Clock Stop) In LPDDR4, can be asserted in following:   - in Self Refresh Power Down   - in Power Down   - during Normal operation (Clock Stop)  Programming Mode: Dynamic Position */
#define UDDRC_PWRCTL_EN_DFI_DRAM_CLK_DISABLE_Msk (_U_(0x1) << UDDRC_PWRCTL_EN_DFI_DRAM_CLK_DISABLE_Pos) /**< (UDDRC_PWRCTL) Enable the assertion of dfi_dram_clk_disable whenever a clock is not required by the SDRAM.  If set to 0, dfi_dram_clk_disable is never asserted.  Assertion of dfi_dram_clk_disable is as follows:  In DDR2/DDR3, can only be asserted in Self Refresh.  In DDR4, can be asserted in following:   - in Self Refresh.   - in Maximum Power Saving Mode In mDDR/LPDDR2/LPDDR3, can be asserted in following:   - in Self Refresh   - in Power Down   - in Deep Power Down   - during Normal operation (Clock Stop) In LPDDR4, can be asserted in following:   - in Self Refresh Power Down   - in Power Down   - during Normal operation (Clock Stop)  Programming Mode: Dynamic Mask */
#define UDDRC_PWRCTL_EN_DFI_DRAM_CLK_DISABLE(value) (UDDRC_PWRCTL_EN_DFI_DRAM_CLK_DISABLE_Msk & ((value) << UDDRC_PWRCTL_EN_DFI_DRAM_CLK_DISABLE_Pos))
#define UDDRC_PWRCTL_SELFREF_SW_Pos           _U_(5)                                               /**< (UDDRC_PWRCTL) A value of 1 to this register causes system to move to Self Refresh state immediately, as long as it is not in INIT or DPD/MPSM operating_mode. This is referred to as Software Entry/Exit to Self Refresh.   - 1 - Software Entry to Self Refresh   - 0 - Software Exit from Self Refresh  Programming Mode: Dynamic Position */
#define UDDRC_PWRCTL_SELFREF_SW_Msk           (_U_(0x1) << UDDRC_PWRCTL_SELFREF_SW_Pos)            /**< (UDDRC_PWRCTL) A value of 1 to this register causes system to move to Self Refresh state immediately, as long as it is not in INIT or DPD/MPSM operating_mode. This is referred to as Software Entry/Exit to Self Refresh.   - 1 - Software Entry to Self Refresh   - 0 - Software Exit from Self Refresh  Programming Mode: Dynamic Mask */
#define UDDRC_PWRCTL_SELFREF_SW(value)        (UDDRC_PWRCTL_SELFREF_SW_Msk & ((value) << UDDRC_PWRCTL_SELFREF_SW_Pos))
#define UDDRC_PWRCTL_DIS_CAM_DRAIN_SELFREF_Pos _U_(7)                                               /**< (UDDRC_PWRCTL) Indicates whether skipping CAM draining is allowed when entering Self-Refresh. This register field cannot be modified while PWRCTL.selfref_sw==1.   - 0 - CAMs must be empty before entering SR   - 1 - CAMs are not emptied before entering SR (unsupported)   Note, PWRCTL.dis_cam_drain_selfref=1 is unsupported in this release. PWRCTL.dis_cam_drain_selfref=0 is required.  Programming Mode: Dynamic Position */
#define UDDRC_PWRCTL_DIS_CAM_DRAIN_SELFREF_Msk (_U_(0x1) << UDDRC_PWRCTL_DIS_CAM_DRAIN_SELFREF_Pos) /**< (UDDRC_PWRCTL) Indicates whether skipping CAM draining is allowed when entering Self-Refresh. This register field cannot be modified while PWRCTL.selfref_sw==1.   - 0 - CAMs must be empty before entering SR   - 1 - CAMs are not emptied before entering SR (unsupported)   Note, PWRCTL.dis_cam_drain_selfref=1 is unsupported in this release. PWRCTL.dis_cam_drain_selfref=0 is required.  Programming Mode: Dynamic Mask */
#define UDDRC_PWRCTL_DIS_CAM_DRAIN_SELFREF(value) (UDDRC_PWRCTL_DIS_CAM_DRAIN_SELFREF_Msk & ((value) << UDDRC_PWRCTL_DIS_CAM_DRAIN_SELFREF_Pos))
#define UDDRC_PWRCTL_Msk                      _U_(0x000000AF)                                      /**< (UDDRC_PWRCTL) Register Mask  */


/* -------- UDDRC_PWRTMG : (UDDRC Offset: 0x34) (R/W 32) Low Power Timing Register -------- */
#define UDDRC_PWRTMG_RESETVALUE               _U_(0x402010)                                        /**<  (UDDRC_PWRTMG) Low Power Timing Register  Reset Value */

#define UDDRC_PWRTMG_POWERDOWN_TO_X32_Pos     _U_(0)                                               /**< (UDDRC_PWRTMG) After this many clocks of the DDRC command channel being idle the uMCTL2 automatically puts the SDRAM into power-down. The DDRC command channel is considered idle when there are no HIF commands outstanding. This must be enabled in the PWRCTL.powerdown_en. FOR PERFORMANCE ONLY. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Quasi-dynamic Group 4 Position */
#define UDDRC_PWRTMG_POWERDOWN_TO_X32_Msk     (_U_(0x1F) << UDDRC_PWRTMG_POWERDOWN_TO_X32_Pos)     /**< (UDDRC_PWRTMG) After this many clocks of the DDRC command channel being idle the uMCTL2 automatically puts the SDRAM into power-down. The DDRC command channel is considered idle when there are no HIF commands outstanding. This must be enabled in the PWRCTL.powerdown_en. FOR PERFORMANCE ONLY. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Quasi-dynamic Group 4 Mask */
#define UDDRC_PWRTMG_POWERDOWN_TO_X32(value)  (UDDRC_PWRTMG_POWERDOWN_TO_X32_Msk & ((value) << UDDRC_PWRTMG_POWERDOWN_TO_X32_Pos))
#define UDDRC_PWRTMG_T_DPD_X4096_Pos          _U_(8)                                               /**< (UDDRC_PWRTMG) Minimum deep power-down time. For mDDR, value from the JEDEC specification is 0 as mDDR exits from deep power-down mode immediately after PWRCTL.deeppowerdown_en is de-asserted. For LPDDR2/LPDDR3, value from the JEDEC specification is 500us. Present only in designs configured to support mDDR, LPDDR2 or LPDDR3. FOR PERFORMANCE ONLY. Unit: Multiples of 4096 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Quasi-dynamic Group 4 Position */
#define UDDRC_PWRTMG_T_DPD_X4096_Msk          (_U_(0xFF) << UDDRC_PWRTMG_T_DPD_X4096_Pos)          /**< (UDDRC_PWRTMG) Minimum deep power-down time. For mDDR, value from the JEDEC specification is 0 as mDDR exits from deep power-down mode immediately after PWRCTL.deeppowerdown_en is de-asserted. For LPDDR2/LPDDR3, value from the JEDEC specification is 500us. Present only in designs configured to support mDDR, LPDDR2 or LPDDR3. FOR PERFORMANCE ONLY. Unit: Multiples of 4096 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Quasi-dynamic Group 4 Mask */
#define UDDRC_PWRTMG_T_DPD_X4096(value)       (UDDRC_PWRTMG_T_DPD_X4096_Msk & ((value) << UDDRC_PWRTMG_T_DPD_X4096_Pos))
#define UDDRC_PWRTMG_SELFREF_TO_X32_Pos       _U_(16)                                              /**< (UDDRC_PWRTMG) After this many clocks of the DDRC command channel being idle the uMCTL2 automatically puts the SDRAM into Self Refresh. The DDRC command channel is considered idle when there are no HIF commands outstanding. This must be enabled in the PWRCTL.selfref_en. FOR PERFORMANCE ONLY. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Quasi-dynamic Group 4 Position */
#define UDDRC_PWRTMG_SELFREF_TO_X32_Msk       (_U_(0xFF) << UDDRC_PWRTMG_SELFREF_TO_X32_Pos)       /**< (UDDRC_PWRTMG) After this many clocks of the DDRC command channel being idle the uMCTL2 automatically puts the SDRAM into Self Refresh. The DDRC command channel is considered idle when there are no HIF commands outstanding. This must be enabled in the PWRCTL.selfref_en. FOR PERFORMANCE ONLY. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Quasi-dynamic Group 4 Mask */
#define UDDRC_PWRTMG_SELFREF_TO_X32(value)    (UDDRC_PWRTMG_SELFREF_TO_X32_Msk & ((value) << UDDRC_PWRTMG_SELFREF_TO_X32_Pos))
#define UDDRC_PWRTMG_Msk                      _U_(0x00FFFF1F)                                      /**< (UDDRC_PWRTMG) Register Mask  */


/* -------- UDDRC_HWLPCTL : (UDDRC Offset: 0x38) (R/W 32) Hardware Low Power Control Register -------- */
#define UDDRC_HWLPCTL_RESETVALUE              _U_(0x03)                                            /**<  (UDDRC_HWLPCTL) Hardware Low Power Control Register  Reset Value */

#define UDDRC_HWLPCTL_HW_LP_EN_Pos            _U_(0)                                               /**< (UDDRC_HWLPCTL) Enable for Hardware Low Power Interface.  Programming Mode: Quasi-dynamic Group 2 Position */
#define UDDRC_HWLPCTL_HW_LP_EN_Msk            (_U_(0x1) << UDDRC_HWLPCTL_HW_LP_EN_Pos)             /**< (UDDRC_HWLPCTL) Enable for Hardware Low Power Interface.  Programming Mode: Quasi-dynamic Group 2 Mask */
#define UDDRC_HWLPCTL_HW_LP_EN(value)         (UDDRC_HWLPCTL_HW_LP_EN_Msk & ((value) << UDDRC_HWLPCTL_HW_LP_EN_Pos))
#define UDDRC_HWLPCTL_HW_LP_EXIT_IDLE_EN_Pos  _U_(1)                                               /**< (UDDRC_HWLPCTL) When this bit is programmed to 1 the cactive_in_ddrc pin of the DDRC can be used to exit from the automatic clock stop, automatic power down or automatic self-refresh modes. Note, it will not cause exit of Self-Refresh that was caused by Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw). Programming Mode: Static Position */
#define UDDRC_HWLPCTL_HW_LP_EXIT_IDLE_EN_Msk  (_U_(0x1) << UDDRC_HWLPCTL_HW_LP_EXIT_IDLE_EN_Pos)   /**< (UDDRC_HWLPCTL) When this bit is programmed to 1 the cactive_in_ddrc pin of the DDRC can be used to exit from the automatic clock stop, automatic power down or automatic self-refresh modes. Note, it will not cause exit of Self-Refresh that was caused by Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw). Programming Mode: Static Mask */
#define UDDRC_HWLPCTL_HW_LP_EXIT_IDLE_EN(value) (UDDRC_HWLPCTL_HW_LP_EXIT_IDLE_EN_Msk & ((value) << UDDRC_HWLPCTL_HW_LP_EXIT_IDLE_EN_Pos))
#define UDDRC_HWLPCTL_HW_LP_IDLE_X32_Pos      _U_(16)                                              /**< (UDDRC_HWLPCTL) Hardware idle period. The cactive_ddrc output is driven low if the DDRC command channel is idle for hw_lp_idle * 32 cycles if not in INIT or DPD/MPSM operating_mode. The DDRC command channel is considered idle when there are no HIF commands outstanding. The hardware idle function is disabled when hw_lp_idle_x32=0. hw_lp_idle_x32=1 is an illegal value. FOR PERFORMANCE ONLY. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Position */
#define UDDRC_HWLPCTL_HW_LP_IDLE_X32_Msk      (_U_(0xFFF) << UDDRC_HWLPCTL_HW_LP_IDLE_X32_Pos)     /**< (UDDRC_HWLPCTL) Hardware idle period. The cactive_ddrc output is driven low if the DDRC command channel is idle for hw_lp_idle * 32 cycles if not in INIT or DPD/MPSM operating_mode. The DDRC command channel is considered idle when there are no HIF commands outstanding. The hardware idle function is disabled when hw_lp_idle_x32=0. hw_lp_idle_x32=1 is an illegal value. FOR PERFORMANCE ONLY. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Mask */
#define UDDRC_HWLPCTL_HW_LP_IDLE_X32(value)   (UDDRC_HWLPCTL_HW_LP_IDLE_X32_Msk & ((value) << UDDRC_HWLPCTL_HW_LP_IDLE_X32_Pos))
#define UDDRC_HWLPCTL_Msk                     _U_(0x0FFF0003)                                      /**< (UDDRC_HWLPCTL) Register Mask  */


/* -------- UDDRC_RFSHCTL0 : (UDDRC Offset: 0x50) (R/W 32) Refresh Control Register 0 -------- */
#define UDDRC_RFSHCTL0_RESETVALUE             _U_(0x210000)                                        /**<  (UDDRC_RFSHCTL0) Refresh Control Register 0  Reset Value */

#define UDDRC_RFSHCTL0_PER_BANK_REFRESH_Pos   _U_(2)                                               /**< (UDDRC_RFSHCTL0) - 1 - Per bank refresh  - 0 - All bank refresh Per bank refresh allows traffic to flow to other banks. Per bank refresh is not supported by all LPDDR2 devices but should be supported by all LPDDR3/LPDDR4 devices. Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4 Programming Mode: Static Position */
#define UDDRC_RFSHCTL0_PER_BANK_REFRESH_Msk   (_U_(0x1) << UDDRC_RFSHCTL0_PER_BANK_REFRESH_Pos)    /**< (UDDRC_RFSHCTL0) - 1 - Per bank refresh  - 0 - All bank refresh Per bank refresh allows traffic to flow to other banks. Per bank refresh is not supported by all LPDDR2 devices but should be supported by all LPDDR3/LPDDR4 devices. Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4 Programming Mode: Static Mask */
#define UDDRC_RFSHCTL0_PER_BANK_REFRESH(value) (UDDRC_RFSHCTL0_PER_BANK_REFRESH_Msk & ((value) << UDDRC_RFSHCTL0_PER_BANK_REFRESH_Pos))
#define UDDRC_RFSHCTL0_REFRESH_BURST_Pos      _U_(4)                                               /**< (UDDRC_RFSHCTL0) The programmed value + 1 is the number of refresh timeouts that is allowed to accumulate before traffic is blocked and the refreshes are forced to execute. Closing pages to perform a refresh is a one-time penalty that must be paid for each group of refreshes. Therefore, performing refreshes in a burst reduces the per-refresh penalty of these page closings. Higher numbers for RFSHCTL.refresh_burst slightly increases utilization; lower numbers decreases the worst-case latency associated with refreshes.  - 0 - single refresh  - 1 - burst-of-2 refresh  - 7 - burst-of-8 refresh For information on burst refresh feature refer to section 3.9 of DDR2 JEDEC specification - JESD79-2F.pdf. For DDR2/3, the refresh is always per-rank and not per-bank. The rank refresh can be accumulated over 8*tREFI cycles using the burst refresh feature.  In DDR4 mode, according to Fine Granularity feature, 8 refreshes can be postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode. If using PHY-initiated updates, care must be taken in the setting of RFSHCTL0.refresh_burst, to ensure that tRFCmax is not violated due to a PHY-initiated update occurring shortly before a refresh burst was due. In this situation, the refresh burst will be delayed until the PHY-initiated update is complete. In per-bank refresh mode of LPDDR2/LPDDR3/LPDDR4 (RFSHCTL0.per_bank_refresh = 1), 64 refreshes can be postponed. Programming Mode: Dynamic - Refresh Related Position */
#define UDDRC_RFSHCTL0_REFRESH_BURST_Msk      (_U_(0x3F) << UDDRC_RFSHCTL0_REFRESH_BURST_Pos)      /**< (UDDRC_RFSHCTL0) The programmed value + 1 is the number of refresh timeouts that is allowed to accumulate before traffic is blocked and the refreshes are forced to execute. Closing pages to perform a refresh is a one-time penalty that must be paid for each group of refreshes. Therefore, performing refreshes in a burst reduces the per-refresh penalty of these page closings. Higher numbers for RFSHCTL.refresh_burst slightly increases utilization; lower numbers decreases the worst-case latency associated with refreshes.  - 0 - single refresh  - 1 - burst-of-2 refresh  - 7 - burst-of-8 refresh For information on burst refresh feature refer to section 3.9 of DDR2 JEDEC specification - JESD79-2F.pdf. For DDR2/3, the refresh is always per-rank and not per-bank. The rank refresh can be accumulated over 8*tREFI cycles using the burst refresh feature.  In DDR4 mode, according to Fine Granularity feature, 8 refreshes can be postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode. If using PHY-initiated updates, care must be taken in the setting of RFSHCTL0.refresh_burst, to ensure that tRFCmax is not violated due to a PHY-initiated update occurring shortly before a refresh burst was due. In this situation, the refresh burst will be delayed until the PHY-initiated update is complete. In per-bank refresh mode of LPDDR2/LPDDR3/LPDDR4 (RFSHCTL0.per_bank_refresh = 1), 64 refreshes can be postponed. Programming Mode: Dynamic - Refresh Related Mask */
#define UDDRC_RFSHCTL0_REFRESH_BURST(value)   (UDDRC_RFSHCTL0_REFRESH_BURST_Msk & ((value) << UDDRC_RFSHCTL0_REFRESH_BURST_Pos))
#define UDDRC_RFSHCTL0_REFRESH_TO_X1_X32_Pos  _U_(12)                                              /**< (UDDRC_RFSHCTL0) If the refresh timer (tRFCnom, also known as tREFI) has expired at least once, then a speculative refresh may be performed. A speculative refresh is a refresh performed at a time when refresh would be useful. When the SDRAM bus is idle for a period of time determined by this RFSHCTL0.refresh_to_x1_x32 and the refresh timer has expired at least once since the last refresh, then a speculative refresh is performed. Speculative refreshes continues successively until there are no refreshes pending or until new reads or writes are issued to the uMCTL2. FOR PERFORMANCE ONLY.  Unit: DFI clock cycles or multiples of 32 DFI clock cycles, depending on RFSHTMG.t_rfc_nom_x1_sel. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Dynamic - Refresh Related Position */
#define UDDRC_RFSHCTL0_REFRESH_TO_X1_X32_Msk  (_U_(0x1F) << UDDRC_RFSHCTL0_REFRESH_TO_X1_X32_Pos)  /**< (UDDRC_RFSHCTL0) If the refresh timer (tRFCnom, also known as tREFI) has expired at least once, then a speculative refresh may be performed. A speculative refresh is a refresh performed at a time when refresh would be useful. When the SDRAM bus is idle for a period of time determined by this RFSHCTL0.refresh_to_x1_x32 and the refresh timer has expired at least once since the last refresh, then a speculative refresh is performed. Speculative refreshes continues successively until there are no refreshes pending or until new reads or writes are issued to the uMCTL2. FOR PERFORMANCE ONLY.  Unit: DFI clock cycles or multiples of 32 DFI clock cycles, depending on RFSHTMG.t_rfc_nom_x1_sel. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Dynamic - Refresh Related Mask */
#define UDDRC_RFSHCTL0_REFRESH_TO_X1_X32(value) (UDDRC_RFSHCTL0_REFRESH_TO_X1_X32_Msk & ((value) << UDDRC_RFSHCTL0_REFRESH_TO_X1_X32_Pos))
#define UDDRC_RFSHCTL0_REFRESH_MARGIN_Pos     _U_(20)                                              /**< (UDDRC_RFSHCTL0) Threshold value in number of DFI clock cycles before the critical refresh or page timer expires. A critical refresh is to be issued before this threshold is reached. It is recommended that this not be changed from the default value, currently shown as 0x2. It must always be less than internally used t_rfc_nom/32.  Note that internally used t_rfc_nom is equal to RFSHTMG.t_rfc_nom_x1_x32 * 32 if RFSHTMG.t_rfc_nom_x1_sel=0. If RFSHTMG.t_rfc_nom_x1_sel=1 (for LPDDR2/LPDDR3/LPDDR4 per-bank refresh only), internally used t_rfc_nom is equal to RFSHTMG.t_rfc_nom_x1_x32. Note that, in LPDDR2/LPDDR3/LPDDR4, internally used t_rfc_nom may be divided by four if derating is enabled (DERATEEN.derate_enable=1). Unit: Multiples of 32 DFI clock cycles. Programming Mode: Dynamic - Refresh Related Position */
#define UDDRC_RFSHCTL0_REFRESH_MARGIN_Msk     (_U_(0xF) << UDDRC_RFSHCTL0_REFRESH_MARGIN_Pos)      /**< (UDDRC_RFSHCTL0) Threshold value in number of DFI clock cycles before the critical refresh or page timer expires. A critical refresh is to be issued before this threshold is reached. It is recommended that this not be changed from the default value, currently shown as 0x2. It must always be less than internally used t_rfc_nom/32.  Note that internally used t_rfc_nom is equal to RFSHTMG.t_rfc_nom_x1_x32 * 32 if RFSHTMG.t_rfc_nom_x1_sel=0. If RFSHTMG.t_rfc_nom_x1_sel=1 (for LPDDR2/LPDDR3/LPDDR4 per-bank refresh only), internally used t_rfc_nom is equal to RFSHTMG.t_rfc_nom_x1_x32. Note that, in LPDDR2/LPDDR3/LPDDR4, internally used t_rfc_nom may be divided by four if derating is enabled (DERATEEN.derate_enable=1). Unit: Multiples of 32 DFI clock cycles. Programming Mode: Dynamic - Refresh Related Mask */
#define UDDRC_RFSHCTL0_REFRESH_MARGIN(value)  (UDDRC_RFSHCTL0_REFRESH_MARGIN_Msk & ((value) << UDDRC_RFSHCTL0_REFRESH_MARGIN_Pos))
#define UDDRC_RFSHCTL0_Msk                    _U_(0x00F1F3F4)                                      /**< (UDDRC_RFSHCTL0) Register Mask  */


/* -------- UDDRC_RFSHCTL3 : (UDDRC Offset: 0x60) (R/W 32) Refresh Control Register 3 -------- */
#define UDDRC_RFSHCTL3_RESETVALUE             _U_(0x00)                                            /**<  (UDDRC_RFSHCTL3) Refresh Control Register 3  Reset Value */

#define UDDRC_RFSHCTL3_DIS_AUTO_REFRESH_Pos   _U_(0)                                               /**< (UDDRC_RFSHCTL3) When '1', disable auto-refresh generated by the uMCTL2. When auto-refresh is disabled, the SoC core must generate refreshes using the registers DBGCMD.rankn_refresh. When dis_auto_refresh transitions from 0 to 1, any pending refreshes are immediately scheduled by the uMCTL2. If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), disable auto-refresh is not supported, and this bit must be set to '0'. (DDR4 only) If FGR mode is enabled (RFSHCTL3.refresh_mode > 0), disable auto-refresh is not supported, and this bit must be set to '0'. This register field is changeable on the fly. Programming Mode: Dynamic - Refresh Related Position */
#define UDDRC_RFSHCTL3_DIS_AUTO_REFRESH_Msk   (_U_(0x1) << UDDRC_RFSHCTL3_DIS_AUTO_REFRESH_Pos)    /**< (UDDRC_RFSHCTL3) When '1', disable auto-refresh generated by the uMCTL2. When auto-refresh is disabled, the SoC core must generate refreshes using the registers DBGCMD.rankn_refresh. When dis_auto_refresh transitions from 0 to 1, any pending refreshes are immediately scheduled by the uMCTL2. If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), disable auto-refresh is not supported, and this bit must be set to '0'. (DDR4 only) If FGR mode is enabled (RFSHCTL3.refresh_mode > 0), disable auto-refresh is not supported, and this bit must be set to '0'. This register field is changeable on the fly. Programming Mode: Dynamic - Refresh Related Mask */
#define UDDRC_RFSHCTL3_DIS_AUTO_REFRESH(value) (UDDRC_RFSHCTL3_DIS_AUTO_REFRESH_Msk & ((value) << UDDRC_RFSHCTL3_DIS_AUTO_REFRESH_Pos))
#define UDDRC_RFSHCTL3_REFRESH_UPDATE_LEVEL_Pos _U_(1)                                               /**< (UDDRC_RFSHCTL3) Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the refresh register(s) have been updated. refresh_update_level must not be toggled when the DDRC is in reset (core_ddrc_rstn = 0). The refresh register(s) are automatically updated when exiting reset. Programming Mode: Dynamic Position */
#define UDDRC_RFSHCTL3_REFRESH_UPDATE_LEVEL_Msk (_U_(0x1) << UDDRC_RFSHCTL3_REFRESH_UPDATE_LEVEL_Pos) /**< (UDDRC_RFSHCTL3) Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the refresh register(s) have been updated. refresh_update_level must not be toggled when the DDRC is in reset (core_ddrc_rstn = 0). The refresh register(s) are automatically updated when exiting reset. Programming Mode: Dynamic Mask */
#define UDDRC_RFSHCTL3_REFRESH_UPDATE_LEVEL(value) (UDDRC_RFSHCTL3_REFRESH_UPDATE_LEVEL_Msk & ((value) << UDDRC_RFSHCTL3_REFRESH_UPDATE_LEVEL_Pos))
#define UDDRC_RFSHCTL3_Msk                    _U_(0x00000003)                                      /**< (UDDRC_RFSHCTL3) Register Mask  */


/* -------- UDDRC_RFSHTMG : (UDDRC Offset: 0x64) (R/W 32) Refresh Timing Register -------- */
#define UDDRC_RFSHTMG_RESETVALUE              _U_(0x62008C)                                        /**<  (UDDRC_RFSHTMG) Refresh Timing Register  Reset Value */

#define UDDRC_RFSHTMG_T_RFC_MIN_Pos           _U_(0)                                               /**< (UDDRC_RFSHTMG) tRFC (min): Minimum time from refresh to refresh or activate.  When the controller is operating in 1:1 mode, t_rfc_min should be set to RoundUp(tRFCmin/tCK).  When the controller is operating in 1:2 mode, t_rfc_min should be set to RoundUp(RoundUp(tRFCmin/tCK)/2).  In LPDDR2/LPDDR3/LPDDR4 mode:   - if using all-bank refreshes, the tRFCmin value in the above equations is equal to tRFCab   - if using per-bank refreshes, the tRFCmin value in the above equations is equal to tRFCpb In DDR4 mode, the tRFCmin value in the above equations is different depending on the refresh mode (fixed 1X,2X,4X) and the device density. The user should program the appropriate value from the spec based on the 'refresh_mode' and the device density that is used.  Unit: DFI clock cycles. Programming Mode: Dynamic - Refresh Related Position */
#define UDDRC_RFSHTMG_T_RFC_MIN_Msk           (_U_(0x3FF) << UDDRC_RFSHTMG_T_RFC_MIN_Pos)          /**< (UDDRC_RFSHTMG) tRFC (min): Minimum time from refresh to refresh or activate.  When the controller is operating in 1:1 mode, t_rfc_min should be set to RoundUp(tRFCmin/tCK).  When the controller is operating in 1:2 mode, t_rfc_min should be set to RoundUp(RoundUp(tRFCmin/tCK)/2).  In LPDDR2/LPDDR3/LPDDR4 mode:   - if using all-bank refreshes, the tRFCmin value in the above equations is equal to tRFCab   - if using per-bank refreshes, the tRFCmin value in the above equations is equal to tRFCpb In DDR4 mode, the tRFCmin value in the above equations is different depending on the refresh mode (fixed 1X,2X,4X) and the device density. The user should program the appropriate value from the spec based on the 'refresh_mode' and the device density that is used.  Unit: DFI clock cycles. Programming Mode: Dynamic - Refresh Related Mask */
#define UDDRC_RFSHTMG_T_RFC_MIN(value)        (UDDRC_RFSHTMG_T_RFC_MIN_Msk & ((value) << UDDRC_RFSHTMG_T_RFC_MIN_Pos))
#define UDDRC_RFSHTMG_LPDDR3_TREFBW_EN_Pos    _U_(15)                                              /**< (UDDRC_RFSHTMG) Used only when LPDDR3 memory type is connected. Should only be changed when uMCTL2 is in reset. Specifies whether to use the tREFBW parameter (required by some LPDDR3 devices which comply with earlier versions of the LPDDR3 JEDEC specification) or not:    - 0 - tREFBW parameter not used    - 1 - tREFBW parameter used Programming Mode: Static Position */
#define UDDRC_RFSHTMG_LPDDR3_TREFBW_EN_Msk    (_U_(0x1) << UDDRC_RFSHTMG_LPDDR3_TREFBW_EN_Pos)     /**< (UDDRC_RFSHTMG) Used only when LPDDR3 memory type is connected. Should only be changed when uMCTL2 is in reset. Specifies whether to use the tREFBW parameter (required by some LPDDR3 devices which comply with earlier versions of the LPDDR3 JEDEC specification) or not:    - 0 - tREFBW parameter not used    - 1 - tREFBW parameter used Programming Mode: Static Mask */
#define UDDRC_RFSHTMG_LPDDR3_TREFBW_EN(value) (UDDRC_RFSHTMG_LPDDR3_TREFBW_EN_Msk & ((value) << UDDRC_RFSHTMG_LPDDR3_TREFBW_EN_Pos))
#define UDDRC_RFSHTMG_T_RFC_NOM_X1_X32_Pos    _U_(16)                                              /**< (UDDRC_RFSHTMG) Average time interval between refreshes per rank (Specification: 7.8us for DDR2, DDR3 and DDR4. See JEDEC specification for mDDR, LPDDR2, LPDDR3 and LPDDR4).    When the controller is operating in 1:1 mode, set this register to RoundDown(tREFI/tCK)    When the controller is operating in 1:2 mode, set this register to RoundDown(RoundDown(tREFI/tCK)/2)    In both the above cases, if RFSHTMG.t_rfc_nom_x1_sel = 0, divide the above result by 32 and round down.    For LPDDR2/LPDDR3/LPDDR4:   - if using all-bank refreshes (RFSHCTL0.per_bank_refresh = 0), use tREFIab in the above calculations   - if using per-bank refreshes (RFSHCTL0.per_bank_refresh = 1), use tREFIpb in the above calculations For DDR4 mode, tREFI value is different depending on the refresh mode. The user should program the appropriate value from the spec based on the value programmed in the refresh mode register.  Note that:   - RFSHTMG.t_rfc_nom_x1_x32 must be greater than 0x1.   - if RFSHTMG.t_rfc_nom_x1_sel == 1, RFSHTMG.t_rfc_nom_x1_x32 must be greater than RFSHTMG.t_rfc_min   - if RFSHTMG.t_rfc_nom_x1_sel == 0, RFSHTMG.t_rfc_nom_x1_x32 * 32 must be greater than RFSHTMG.t_rfc_min   - In non-DDR4 or DDR4 Fixed 1x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0xFFE.   - In DDR4 Fixed 2x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0x7FF.   - In DDR4 Fixed 4x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0x3FF. Unit: DFI clock cycles or multiples of 32 DFI clock cycles, depending on RFSHTMG.t_rfc_nom_x1_sel. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Dynamic - Refresh Related Position */
#define UDDRC_RFSHTMG_T_RFC_NOM_X1_X32_Msk    (_U_(0xFFF) << UDDRC_RFSHTMG_T_RFC_NOM_X1_X32_Pos)   /**< (UDDRC_RFSHTMG) Average time interval between refreshes per rank (Specification: 7.8us for DDR2, DDR3 and DDR4. See JEDEC specification for mDDR, LPDDR2, LPDDR3 and LPDDR4).    When the controller is operating in 1:1 mode, set this register to RoundDown(tREFI/tCK)    When the controller is operating in 1:2 mode, set this register to RoundDown(RoundDown(tREFI/tCK)/2)    In both the above cases, if RFSHTMG.t_rfc_nom_x1_sel = 0, divide the above result by 32 and round down.    For LPDDR2/LPDDR3/LPDDR4:   - if using all-bank refreshes (RFSHCTL0.per_bank_refresh = 0), use tREFIab in the above calculations   - if using per-bank refreshes (RFSHCTL0.per_bank_refresh = 1), use tREFIpb in the above calculations For DDR4 mode, tREFI value is different depending on the refresh mode. The user should program the appropriate value from the spec based on the value programmed in the refresh mode register.  Note that:   - RFSHTMG.t_rfc_nom_x1_x32 must be greater than 0x1.   - if RFSHTMG.t_rfc_nom_x1_sel == 1, RFSHTMG.t_rfc_nom_x1_x32 must be greater than RFSHTMG.t_rfc_min   - if RFSHTMG.t_rfc_nom_x1_sel == 0, RFSHTMG.t_rfc_nom_x1_x32 * 32 must be greater than RFSHTMG.t_rfc_min   - In non-DDR4 or DDR4 Fixed 1x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0xFFE.   - In DDR4 Fixed 2x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0x7FF.   - In DDR4 Fixed 4x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0x3FF. Unit: DFI clock cycles or multiples of 32 DFI clock cycles, depending on RFSHTMG.t_rfc_nom_x1_sel. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Dynamic - Refresh Related Mask */
#define UDDRC_RFSHTMG_T_RFC_NOM_X1_X32(value) (UDDRC_RFSHTMG_T_RFC_NOM_X1_X32_Msk & ((value) << UDDRC_RFSHTMG_T_RFC_NOM_X1_X32_Pos))
#define UDDRC_RFSHTMG_T_RFC_NOM_X1_SEL_Pos    _U_(31)                                              /**< (UDDRC_RFSHTMG) Specifies whether the RFSHTMG.t_rfc_nom_x1_x32 and RFSHCTL0.refresh_to_x1_x32 register values are x1 or x32.    - 0 - x32 register values are used    - 1 - x1 register values are used. This applies only when per-bank refresh is enabled (RFSHCTL0.per_bank_refresh=1); if per-bank refresh is not enabled, the x32 register values are used and this register field is ignored Programming Mode: Dynamic - Refresh Related Position */
#define UDDRC_RFSHTMG_T_RFC_NOM_X1_SEL_Msk    (_U_(0x1) << UDDRC_RFSHTMG_T_RFC_NOM_X1_SEL_Pos)     /**< (UDDRC_RFSHTMG) Specifies whether the RFSHTMG.t_rfc_nom_x1_x32 and RFSHCTL0.refresh_to_x1_x32 register values are x1 or x32.    - 0 - x32 register values are used    - 1 - x1 register values are used. This applies only when per-bank refresh is enabled (RFSHCTL0.per_bank_refresh=1); if per-bank refresh is not enabled, the x32 register values are used and this register field is ignored Programming Mode: Dynamic - Refresh Related Mask */
#define UDDRC_RFSHTMG_T_RFC_NOM_X1_SEL(value) (UDDRC_RFSHTMG_T_RFC_NOM_X1_SEL_Msk & ((value) << UDDRC_RFSHTMG_T_RFC_NOM_X1_SEL_Pos))
#define UDDRC_RFSHTMG_Msk                     _U_(0x8FFF83FF)                                      /**< (UDDRC_RFSHTMG) Register Mask  */


/* -------- UDDRC_CRCPARCTL0 : (UDDRC Offset: 0xC0) (R/W 32) CRC Parity Control Register0 -------- */
#define UDDRC_CRCPARCTL0_RESETVALUE           _U_(0x00)                                            /**<  (UDDRC_CRCPARCTL0) CRC Parity Control Register0  Reset Value */

#define UDDRC_CRCPARCTL0_DFI_ALERT_ERR_INT_EN_Pos _U_(0)                                               /**< (UDDRC_CRCPARCTL0) Interrupt enable bit for DFI alert error. If this bit is set, any parity/CRC error detected on the dfi_alert_n input will result in an interrupt being set on CRCPARSTAT.dfi_alert_err_int. Programming Mode: Dynamic Position */
#define UDDRC_CRCPARCTL0_DFI_ALERT_ERR_INT_EN_Msk (_U_(0x1) << UDDRC_CRCPARCTL0_DFI_ALERT_ERR_INT_EN_Pos) /**< (UDDRC_CRCPARCTL0) Interrupt enable bit for DFI alert error. If this bit is set, any parity/CRC error detected on the dfi_alert_n input will result in an interrupt being set on CRCPARSTAT.dfi_alert_err_int. Programming Mode: Dynamic Mask */
#define UDDRC_CRCPARCTL0_DFI_ALERT_ERR_INT_EN(value) (UDDRC_CRCPARCTL0_DFI_ALERT_ERR_INT_EN_Msk & ((value) << UDDRC_CRCPARCTL0_DFI_ALERT_ERR_INT_EN_Pos))
#define UDDRC_CRCPARCTL0_DFI_ALERT_ERR_INT_CLR_Pos _U_(1)                                               /**< (UDDRC_CRCPARCTL0) Interrupt clear bit for DFI alert error. If this bit is set, the alert error interrupt on CRCPARSTAT.dfi_alert_err_int will be cleared. uMCTL2 automatically clears this bit. Programming Mode: Dynamic Position */
#define UDDRC_CRCPARCTL0_DFI_ALERT_ERR_INT_CLR_Msk (_U_(0x1) << UDDRC_CRCPARCTL0_DFI_ALERT_ERR_INT_CLR_Pos) /**< (UDDRC_CRCPARCTL0) Interrupt clear bit for DFI alert error. If this bit is set, the alert error interrupt on CRCPARSTAT.dfi_alert_err_int will be cleared. uMCTL2 automatically clears this bit. Programming Mode: Dynamic Mask */
#define UDDRC_CRCPARCTL0_DFI_ALERT_ERR_INT_CLR(value) (UDDRC_CRCPARCTL0_DFI_ALERT_ERR_INT_CLR_Msk & ((value) << UDDRC_CRCPARCTL0_DFI_ALERT_ERR_INT_CLR_Pos))
#define UDDRC_CRCPARCTL0_DFI_ALERT_ERR_CNT_CLR_Pos _U_(2)                                               /**< (UDDRC_CRCPARCTL0) DFI alert error count clear. Clear bit for DFI alert error counter. Asserting this bit will clear the DFI alert error counter, CRCPARSTAT.dfi_alert_err_cnt. uMCTL2 automatically clears this bit. Programming Mode: Dynamic Position */
#define UDDRC_CRCPARCTL0_DFI_ALERT_ERR_CNT_CLR_Msk (_U_(0x1) << UDDRC_CRCPARCTL0_DFI_ALERT_ERR_CNT_CLR_Pos) /**< (UDDRC_CRCPARCTL0) DFI alert error count clear. Clear bit for DFI alert error counter. Asserting this bit will clear the DFI alert error counter, CRCPARSTAT.dfi_alert_err_cnt. uMCTL2 automatically clears this bit. Programming Mode: Dynamic Mask */
#define UDDRC_CRCPARCTL0_DFI_ALERT_ERR_CNT_CLR(value) (UDDRC_CRCPARCTL0_DFI_ALERT_ERR_CNT_CLR_Msk & ((value) << UDDRC_CRCPARCTL0_DFI_ALERT_ERR_CNT_CLR_Pos))
#define UDDRC_CRCPARCTL0_Msk                  _U_(0x00000007)                                      /**< (UDDRC_CRCPARCTL0) Register Mask  */


/* -------- UDDRC_CRCPARSTAT : (UDDRC Offset: 0xCC) ( R/ 32) CRC Parity Status Register -------- */
#define UDDRC_CRCPARSTAT_RESETVALUE           _U_(0x00)                                            /**<  (UDDRC_CRCPARSTAT) CRC Parity Status Register  Reset Value */

#define UDDRC_CRCPARSTAT_DFI_ALERT_ERR_CNT_Pos _U_(0)                                               /**< (UDDRC_CRCPARSTAT) DFI alert error count.   If a parity/CRC error is detected on dfi_alert_n, this counter be incremented.  This is independent of the setting of CRCPARCTL0.dfi_alert_err_int_en.  It will saturate at 0xFFFF, and can be cleared by asserting CRCPARCTL0.dfi_alert_err_cnt_clr. Programming Mode: Static Position */
#define UDDRC_CRCPARSTAT_DFI_ALERT_ERR_CNT_Msk (_U_(0xFFFF) << UDDRC_CRCPARSTAT_DFI_ALERT_ERR_CNT_Pos) /**< (UDDRC_CRCPARSTAT) DFI alert error count.   If a parity/CRC error is detected on dfi_alert_n, this counter be incremented.  This is independent of the setting of CRCPARCTL0.dfi_alert_err_int_en.  It will saturate at 0xFFFF, and can be cleared by asserting CRCPARCTL0.dfi_alert_err_cnt_clr. Programming Mode: Static Mask */
#define UDDRC_CRCPARSTAT_DFI_ALERT_ERR_CNT(value) (UDDRC_CRCPARSTAT_DFI_ALERT_ERR_CNT_Msk & ((value) << UDDRC_CRCPARSTAT_DFI_ALERT_ERR_CNT_Pos))
#define UDDRC_CRCPARSTAT_DFI_ALERT_ERR_INT_Pos _U_(16)                                              /**< (UDDRC_CRCPARSTAT) DFI alert error interrupt.   If a parity/CRC error is detected on dfi_alert_n, and the interrupt is enabled by CRCPARCTL0.dfi_alert_err_int_en, this interrupt bit will be set.  It will remain set until cleared by CRCPARCTL0.dfi_alert_err_int_clr Programming Mode: Static Position */
#define UDDRC_CRCPARSTAT_DFI_ALERT_ERR_INT_Msk (_U_(0x1) << UDDRC_CRCPARSTAT_DFI_ALERT_ERR_INT_Pos) /**< (UDDRC_CRCPARSTAT) DFI alert error interrupt.   If a parity/CRC error is detected on dfi_alert_n, and the interrupt is enabled by CRCPARCTL0.dfi_alert_err_int_en, this interrupt bit will be set.  It will remain set until cleared by CRCPARCTL0.dfi_alert_err_int_clr Programming Mode: Static Mask */
#define UDDRC_CRCPARSTAT_DFI_ALERT_ERR_INT(value) (UDDRC_CRCPARSTAT_DFI_ALERT_ERR_INT_Msk & ((value) << UDDRC_CRCPARSTAT_DFI_ALERT_ERR_INT_Pos))
#define UDDRC_CRCPARSTAT_Msk                  _U_(0x0001FFFF)                                      /**< (UDDRC_CRCPARSTAT) Register Mask  */


/* -------- UDDRC_INIT0 : (UDDRC Offset: 0xD0) (R/W 32) SDRAM Initialization Register 0 -------- */
#define UDDRC_INIT0_RESETVALUE                _U_(0x2004E)                                         /**<  (UDDRC_INIT0) SDRAM Initialization Register 0  Reset Value */

#define UDDRC_INIT0_PRE_CKE_X1024_Pos         _U_(0)                                               /**< (UDDRC_INIT0) Cycles to wait after reset before driving CKE high to start the SDRAM initialization sequence. DDR2 specifications typically require this to be programmed for a delay of >= 200 us. LPDDR2/LPDDR3: tINIT1 of 100 ns (min)  LPDDR4: tINIT3 of 2 ms (min)   When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. For DDR3/DDR4 RDIMMs, this should include the time needed to satisfy tSTAB. Unit: Multiples of 1024 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Position */
#define UDDRC_INIT0_PRE_CKE_X1024_Msk         (_U_(0xFFF) << UDDRC_INIT0_PRE_CKE_X1024_Pos)        /**< (UDDRC_INIT0) Cycles to wait after reset before driving CKE high to start the SDRAM initialization sequence. DDR2 specifications typically require this to be programmed for a delay of >= 200 us. LPDDR2/LPDDR3: tINIT1 of 100 ns (min)  LPDDR4: tINIT3 of 2 ms (min)   When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. For DDR3/DDR4 RDIMMs, this should include the time needed to satisfy tSTAB. Unit: Multiples of 1024 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Mask */
#define UDDRC_INIT0_PRE_CKE_X1024(value)      (UDDRC_INIT0_PRE_CKE_X1024_Msk & ((value) << UDDRC_INIT0_PRE_CKE_X1024_Pos))
#define UDDRC_INIT0_POST_CKE_X1024_Pos        _U_(16)                                              /**< (UDDRC_INIT0) Cycles to wait after driving CKE high to start the SDRAM initialization sequence. DDR2 typically requires a 400 ns delay, requiring this value to be programmed to 2 at all clock speeds. LPDDR2/LPDDR3 typically requires this to be programmed for a delay of 200 us. LPDDR4 typically requires this to be programmed for a delay of 2 us. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 1024 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Position */
#define UDDRC_INIT0_POST_CKE_X1024_Msk        (_U_(0x3FF) << UDDRC_INIT0_POST_CKE_X1024_Pos)       /**< (UDDRC_INIT0) Cycles to wait after driving CKE high to start the SDRAM initialization sequence. DDR2 typically requires a 400 ns delay, requiring this value to be programmed to 2 at all clock speeds. LPDDR2/LPDDR3 typically requires this to be programmed for a delay of 200 us. LPDDR4 typically requires this to be programmed for a delay of 2 us. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 1024 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Mask */
#define UDDRC_INIT0_POST_CKE_X1024(value)     (UDDRC_INIT0_POST_CKE_X1024_Msk & ((value) << UDDRC_INIT0_POST_CKE_X1024_Pos))
#define UDDRC_INIT0_SKIP_DRAM_INIT_Pos        _U_(30)                                              /**< (UDDRC_INIT0) If lower bit is enabled the SDRAM initialization routine is skipped. The upper bit decides what state the controller starts up in when reset is removed    - 00 - SDRAM Initialization routine is run after power-up  - 01 - SDRAM Initialization routine is skipped after power-up. Controller starts up in Normal Mode  - 11 - SDRAM Initialization routine is skipped after power-up. Controller starts up in Self-refresh Mode  - 10 - Reserved. Programming Mode: Quasi-dynamic Group 2 Position */
#define UDDRC_INIT0_SKIP_DRAM_INIT_Msk        (_U_(0x3) << UDDRC_INIT0_SKIP_DRAM_INIT_Pos)         /**< (UDDRC_INIT0) If lower bit is enabled the SDRAM initialization routine is skipped. The upper bit decides what state the controller starts up in when reset is removed    - 00 - SDRAM Initialization routine is run after power-up  - 01 - SDRAM Initialization routine is skipped after power-up. Controller starts up in Normal Mode  - 11 - SDRAM Initialization routine is skipped after power-up. Controller starts up in Self-refresh Mode  - 10 - Reserved. Programming Mode: Quasi-dynamic Group 2 Mask */
#define UDDRC_INIT0_SKIP_DRAM_INIT(value)     (UDDRC_INIT0_SKIP_DRAM_INIT_Msk & ((value) << UDDRC_INIT0_SKIP_DRAM_INIT_Pos))
#define UDDRC_INIT0_Msk                       _U_(0xC3FF0FFF)                                      /**< (UDDRC_INIT0) Register Mask  */


/* -------- UDDRC_INIT1 : (UDDRC Offset: 0xD4) (R/W 32) SDRAM Initialization Register 1 -------- */
#define UDDRC_INIT1_RESETVALUE                _U_(0x00)                                            /**<  (UDDRC_INIT1) SDRAM Initialization Register 1  Reset Value */

#define UDDRC_INIT1_PRE_OCD_X32_Pos           _U_(0)                                               /**< (UDDRC_INIT1) Wait period before driving the OCD complete command to SDRAM. There is no known specific requirement for this; it may be set to zero. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Position */
#define UDDRC_INIT1_PRE_OCD_X32_Msk           (_U_(0xF) << UDDRC_INIT1_PRE_OCD_X32_Pos)            /**< (UDDRC_INIT1) Wait period before driving the OCD complete command to SDRAM. There is no known specific requirement for this; it may be set to zero. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Mask */
#define UDDRC_INIT1_PRE_OCD_X32(value)        (UDDRC_INIT1_PRE_OCD_X32_Msk & ((value) << UDDRC_INIT1_PRE_OCD_X32_Pos))
#define UDDRC_INIT1_DRAM_RSTN_X1024_Pos       _U_(16)                                              /**< (UDDRC_INIT1) Number of cycles to assert SDRAM reset signal during init sequence. This is only present for designs supporting DDR3, DDR4 or LPDDR4 devices. For use with a Synopsys DDR PHY, this should be set to a minimum of 1. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 1024 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Position */
#define UDDRC_INIT1_DRAM_RSTN_X1024_Msk       (_U_(0x1FF) << UDDRC_INIT1_DRAM_RSTN_X1024_Pos)      /**< (UDDRC_INIT1) Number of cycles to assert SDRAM reset signal during init sequence. This is only present for designs supporting DDR3, DDR4 or LPDDR4 devices. For use with a Synopsys DDR PHY, this should be set to a minimum of 1. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 1024 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Mask */
#define UDDRC_INIT1_DRAM_RSTN_X1024(value)    (UDDRC_INIT1_DRAM_RSTN_X1024_Msk & ((value) << UDDRC_INIT1_DRAM_RSTN_X1024_Pos))
#define UDDRC_INIT1_Msk                       _U_(0x01FF000F)                                      /**< (UDDRC_INIT1) Register Mask  */


/* -------- UDDRC_INIT2 : (UDDRC Offset: 0xD8) (R/W 32) SDRAM Initialization Register 2 -------- */
#define UDDRC_INIT2_RESETVALUE                _U_(0xD05)                                           /**<  (UDDRC_INIT2) SDRAM Initialization Register 2  Reset Value */

#define UDDRC_INIT2_MIN_STABLE_CLOCK_X1_Pos   _U_(0)                                               /**< (UDDRC_INIT2) Time to wait after the first CKE high, tINIT2. Present only in designs configured to support LPDDR2/LPDDR3. LPDDR2/LPDDR3 typically requires 5 x tCK delay. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Static Position */
#define UDDRC_INIT2_MIN_STABLE_CLOCK_X1_Msk   (_U_(0xF) << UDDRC_INIT2_MIN_STABLE_CLOCK_X1_Pos)    /**< (UDDRC_INIT2) Time to wait after the first CKE high, tINIT2. Present only in designs configured to support LPDDR2/LPDDR3. LPDDR2/LPDDR3 typically requires 5 x tCK delay. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Static Mask */
#define UDDRC_INIT2_MIN_STABLE_CLOCK_X1(value) (UDDRC_INIT2_MIN_STABLE_CLOCK_X1_Msk & ((value) << UDDRC_INIT2_MIN_STABLE_CLOCK_X1_Pos))
#define UDDRC_INIT2_IDLE_AFTER_RESET_X32_Pos  _U_(8)                                               /**< (UDDRC_INIT2) Idle time after the reset command, tINIT4. Present only in designs configured to support LPDDR2. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Position */
#define UDDRC_INIT2_IDLE_AFTER_RESET_X32_Msk  (_U_(0xFF) << UDDRC_INIT2_IDLE_AFTER_RESET_X32_Pos)  /**< (UDDRC_INIT2) Idle time after the reset command, tINIT4. Present only in designs configured to support LPDDR2. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Mask */
#define UDDRC_INIT2_IDLE_AFTER_RESET_X32(value) (UDDRC_INIT2_IDLE_AFTER_RESET_X32_Msk & ((value) << UDDRC_INIT2_IDLE_AFTER_RESET_X32_Pos))
#define UDDRC_INIT2_Msk                       _U_(0x0000FF0F)                                      /**< (UDDRC_INIT2) Register Mask  */


/* -------- UDDRC_INIT3 : (UDDRC Offset: 0xDC) (R/W 32) SDRAM Initialization Register 3 -------- */
#define UDDRC_INIT3_RESETVALUE                _U_(0x510)                                           /**<  (UDDRC_INIT3) SDRAM Initialization Register 3  Reset Value */

#define UDDRC_INIT3_EMR_Pos                   _U_(0)                                               /**< (UDDRC_INIT3) DDR2: Value to write to EMR register. Bits 9:7 are for OCD and the setting in this register is ignored. The uMCTL2 sets those bits appropriately. DDR3/DDR4: Value to write to MR1 register  Set bit 7 to 0.  mDDR: Value to write to EMR register. LPDDR2/LPDDR3/LPDDR4 - Value to write to MR2 register Programming Mode: Quasi-dynamic Group 4 Position */
#define UDDRC_INIT3_EMR_Msk                   (_U_(0xFFFF) << UDDRC_INIT3_EMR_Pos)                 /**< (UDDRC_INIT3) DDR2: Value to write to EMR register. Bits 9:7 are for OCD and the setting in this register is ignored. The uMCTL2 sets those bits appropriately. DDR3/DDR4: Value to write to MR1 register  Set bit 7 to 0.  mDDR: Value to write to EMR register. LPDDR2/LPDDR3/LPDDR4 - Value to write to MR2 register Programming Mode: Quasi-dynamic Group 4 Mask */
#define UDDRC_INIT3_EMR(value)                (UDDRC_INIT3_EMR_Msk & ((value) << UDDRC_INIT3_EMR_Pos))
#define UDDRC_INIT3_MR_Pos                    _U_(16)                                              /**< (UDDRC_INIT3) DDR2: Value to write to MR register. Bit 8 is for DLL and the setting here is ignored. The uMCTL2 sets this bit appropriately. DDR3/DDR4: Value loaded into MR0 register. mDDR: Value to write to MR register. LPDDR2/LPDDR3/LPDDR4 - Value to write to MR1 register Programming Mode: Quasi-dynamic Group 1, Group 4 Position */
#define UDDRC_INIT3_MR_Msk                    (_U_(0xFFFF) << UDDRC_INIT3_MR_Pos)                  /**< (UDDRC_INIT3) DDR2: Value to write to MR register. Bit 8 is for DLL and the setting here is ignored. The uMCTL2 sets this bit appropriately. DDR3/DDR4: Value loaded into MR0 register. mDDR: Value to write to MR register. LPDDR2/LPDDR3/LPDDR4 - Value to write to MR1 register Programming Mode: Quasi-dynamic Group 1, Group 4 Mask */
#define UDDRC_INIT3_MR(value)                 (UDDRC_INIT3_MR_Msk & ((value) << UDDRC_INIT3_MR_Pos))
#define UDDRC_INIT3_Msk                       _U_(0xFFFFFFFF)                                      /**< (UDDRC_INIT3) Register Mask  */


/* -------- UDDRC_INIT4 : (UDDRC Offset: 0xE0) (R/W 32) SDRAM Initialization Register 4 -------- */
#define UDDRC_INIT4_RESETVALUE                _U_(0x00)                                            /**<  (UDDRC_INIT4) SDRAM Initialization Register 4  Reset Value */

#define UDDRC_INIT4_EMR3_Pos                  _U_(0)                                               /**< (UDDRC_INIT4) DDR2: Value to write to EMR3 register. DDR3/DDR4: Value to write to MR3 register mDDR/LPDDR2/LPDDR3: Unused LPDDR4: Value to write to MR13 register Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_INIT4_EMR3_Msk                  (_U_(0xFFFF) << UDDRC_INIT4_EMR3_Pos)                /**< (UDDRC_INIT4) DDR2: Value to write to EMR3 register. DDR3/DDR4: Value to write to MR3 register mDDR/LPDDR2/LPDDR3: Unused LPDDR4: Value to write to MR13 register Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_INIT4_EMR3(value)               (UDDRC_INIT4_EMR3_Msk & ((value) << UDDRC_INIT4_EMR3_Pos))
#define UDDRC_INIT4_EMR2_Pos                  _U_(16)                                              /**< (UDDRC_INIT4) DDR2: Value to write to EMR2 register. DDR3/DDR4: Value to write to MR2 register LPDDR2/LPDDR3/LPDDR4: Value to write to MR3 register mDDR: Unused Programming Mode: Quasi-dynamic Group 4 Position */
#define UDDRC_INIT4_EMR2_Msk                  (_U_(0xFFFF) << UDDRC_INIT4_EMR2_Pos)                /**< (UDDRC_INIT4) DDR2: Value to write to EMR2 register. DDR3/DDR4: Value to write to MR2 register LPDDR2/LPDDR3/LPDDR4: Value to write to MR3 register mDDR: Unused Programming Mode: Quasi-dynamic Group 4 Mask */
#define UDDRC_INIT4_EMR2(value)               (UDDRC_INIT4_EMR2_Msk & ((value) << UDDRC_INIT4_EMR2_Pos))
#define UDDRC_INIT4_Msk                       _U_(0xFFFFFFFF)                                      /**< (UDDRC_INIT4) Register Mask  */


/* -------- UDDRC_INIT5 : (UDDRC Offset: 0xE4) (R/W 32) SDRAM Initialization Register 5 -------- */
#define UDDRC_INIT5_RESETVALUE                _U_(0x100004)                                        /**<  (UDDRC_INIT5) SDRAM Initialization Register 5  Reset Value */

#define UDDRC_INIT5_MAX_AUTO_INIT_X1024_Pos   _U_(0)                                               /**< (UDDRC_INIT5) Maximum duration of the auto initialization, tINIT5. Present only in designs configured to support LPDDR2/LPDDR3. LPDDR2/LPDDR3 typically requires 10 us. Unit: Multiples of 1024 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Position */
#define UDDRC_INIT5_MAX_AUTO_INIT_X1024_Msk   (_U_(0x3FF) << UDDRC_INIT5_MAX_AUTO_INIT_X1024_Pos)  /**< (UDDRC_INIT5) Maximum duration of the auto initialization, tINIT5. Present only in designs configured to support LPDDR2/LPDDR3. LPDDR2/LPDDR3 typically requires 10 us. Unit: Multiples of 1024 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Mask */
#define UDDRC_INIT5_MAX_AUTO_INIT_X1024(value) (UDDRC_INIT5_MAX_AUTO_INIT_X1024_Msk & ((value) << UDDRC_INIT5_MAX_AUTO_INIT_X1024_Pos))
#define UDDRC_INIT5_DEV_ZQINIT_X32_Pos        _U_(16)                                              /**< (UDDRC_INIT5) ZQ initial calibration, tZQINIT. Present only in designs configured to support DDR3 or DDR4 or LPDDR2/LPDDR3. DDR3 typically requires 512 SDRAM clock cycles. DDR4 requires 1024 SDRAM clock cycles. LPDDR2/LPDDR3 requires 1 us. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Position */
#define UDDRC_INIT5_DEV_ZQINIT_X32_Msk        (_U_(0xFF) << UDDRC_INIT5_DEV_ZQINIT_X32_Pos)        /**< (UDDRC_INIT5) ZQ initial calibration, tZQINIT. Present only in designs configured to support DDR3 or DDR4 or LPDDR2/LPDDR3. DDR3 typically requires 512 SDRAM clock cycles. DDR4 requires 1024 SDRAM clock cycles. LPDDR2/LPDDR3 requires 1 us. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Mask */
#define UDDRC_INIT5_DEV_ZQINIT_X32(value)     (UDDRC_INIT5_DEV_ZQINIT_X32_Msk & ((value) << UDDRC_INIT5_DEV_ZQINIT_X32_Pos))
#define UDDRC_INIT5_Msk                       _U_(0x00FF03FF)                                      /**< (UDDRC_INIT5) Register Mask  */


/* -------- UDDRC_DIMMCTL : (UDDRC Offset: 0xF0) (R/W 32) DIMM Control Register -------- */
#define UDDRC_DIMMCTL_RESETVALUE              _U_(0x00)                                            /**<  (UDDRC_DIMMCTL) DIMM Control Register  Reset Value */

#define UDDRC_DIMMCTL_DIMM_STAGGER_CS_EN_Pos  _U_(0)                                               /**< (UDDRC_DIMMCTL) Staggering enable for multi-rank accesses (for multi-rank UDIMM, RDIMM and LRDIMM implementations only).  This is not supported for mDDR, LPDDR2, LPDDR3 or LPDDR4 SDRAMs. Note: Even if this bit is set it does not take care of software driven MR commands (via MRCTRL0/MRCTRL1), where software is responsible to send them to seperate ranks as appropriate.     - 1 - (DDR4) Send MRS commands to each ranks seperately     - 1 - (non-DDR4) Send all commands to even and odd ranks seperately     - 0 - Do not stagger accesses Programming Mode: Static Position */
#define UDDRC_DIMMCTL_DIMM_STAGGER_CS_EN_Msk  (_U_(0x1) << UDDRC_DIMMCTL_DIMM_STAGGER_CS_EN_Pos)   /**< (UDDRC_DIMMCTL) Staggering enable for multi-rank accesses (for multi-rank UDIMM, RDIMM and LRDIMM implementations only).  This is not supported for mDDR, LPDDR2, LPDDR3 or LPDDR4 SDRAMs. Note: Even if this bit is set it does not take care of software driven MR commands (via MRCTRL0/MRCTRL1), where software is responsible to send them to seperate ranks as appropriate.     - 1 - (DDR4) Send MRS commands to each ranks seperately     - 1 - (non-DDR4) Send all commands to even and odd ranks seperately     - 0 - Do not stagger accesses Programming Mode: Static Mask */
#define UDDRC_DIMMCTL_DIMM_STAGGER_CS_EN(value) (UDDRC_DIMMCTL_DIMM_STAGGER_CS_EN_Msk & ((value) << UDDRC_DIMMCTL_DIMM_STAGGER_CS_EN_Pos))
#define UDDRC_DIMMCTL_DIMM_ADDR_MIRR_EN_Pos   _U_(1)                                               /**< (UDDRC_DIMMCTL) Address Mirroring Enable (for multi-rank UDIMM implementations and multi-rank DDR4 RDIMM/LRDIMM implementations). Some UDIMMs and DDR4 RDIMMs/LRDIMMs implement address mirroring for odd ranks, which means that the following address, bank address and bank group bits are swapped: (A3, A4), (A5, A6), (A7, A8), (BA0, BA1) and also (A11, A13), (BG0, BG1) for the DDR4. Setting this bit ensures that, for mode register accesses during the automatic initialization routine, these bits are swapped within the uMCTL2 to compensate for this UDIMM/RDIMM/LRDIMM swapping. In addition to the automatic initialization routine, in case of DDR4 UDIMM/RDIMM/LRDIMM, they are swapped during the automatic MRS access to enable/disable of a particular DDR4 feature. Note: This has no effect on the address of any other memory accesses, or of software-driven mode register accesses. This is not supported for mDDR, LPDDR2, LPDDR3 or LPDDR4 SDRAMs. Note: In case of x16 DDR4 DIMMs, BG1 output of MRS for the odd ranks is same as BG0 because BG1 is invalid, hence dimm_dis_bg_mirroring register must be set to 1.     - 1 - For odd ranks, implement address mirroring for MRS commands to during initialization and for any automatic DDR4 MRS commands (to be used if UDIMM/RDIMM/LRDIMM implements address mirroring)     - 0 - Do not implement address mirroring Programming Mode: Static Position */
#define UDDRC_DIMMCTL_DIMM_ADDR_MIRR_EN_Msk   (_U_(0x1) << UDDRC_DIMMCTL_DIMM_ADDR_MIRR_EN_Pos)    /**< (UDDRC_DIMMCTL) Address Mirroring Enable (for multi-rank UDIMM implementations and multi-rank DDR4 RDIMM/LRDIMM implementations). Some UDIMMs and DDR4 RDIMMs/LRDIMMs implement address mirroring for odd ranks, which means that the following address, bank address and bank group bits are swapped: (A3, A4), (A5, A6), (A7, A8), (BA0, BA1) and also (A11, A13), (BG0, BG1) for the DDR4. Setting this bit ensures that, for mode register accesses during the automatic initialization routine, these bits are swapped within the uMCTL2 to compensate for this UDIMM/RDIMM/LRDIMM swapping. In addition to the automatic initialization routine, in case of DDR4 UDIMM/RDIMM/LRDIMM, they are swapped during the automatic MRS access to enable/disable of a particular DDR4 feature. Note: This has no effect on the address of any other memory accesses, or of software-driven mode register accesses. This is not supported for mDDR, LPDDR2, LPDDR3 or LPDDR4 SDRAMs. Note: In case of x16 DDR4 DIMMs, BG1 output of MRS for the odd ranks is same as BG0 because BG1 is invalid, hence dimm_dis_bg_mirroring register must be set to 1.     - 1 - For odd ranks, implement address mirroring for MRS commands to during initialization and for any automatic DDR4 MRS commands (to be used if UDIMM/RDIMM/LRDIMM implements address mirroring)     - 0 - Do not implement address mirroring Programming Mode: Static Mask */
#define UDDRC_DIMMCTL_DIMM_ADDR_MIRR_EN(value) (UDDRC_DIMMCTL_DIMM_ADDR_MIRR_EN_Msk & ((value) << UDDRC_DIMMCTL_DIMM_ADDR_MIRR_EN_Pos))
#define UDDRC_DIMMCTL_Msk                     _U_(0x00000003)                                      /**< (UDDRC_DIMMCTL) Register Mask  */


/* -------- UDDRC_DRAMTMG0 : (UDDRC Offset: 0x100) (R/W 32) SDRAM Timing Register 0 -------- */
#define UDDRC_DRAMTMG0_RESETVALUE             _U_(0xF101B0F)                                       /**<  (UDDRC_DRAMTMG0) SDRAM Timing Register 0  Reset Value */

#define UDDRC_DRAMTMG0_T_RAS_MIN_Pos          _U_(0)                                               /**< (UDDRC_DRAMTMG0) tRAS(min):  Minimum time between activate and precharge to the same bank. When the controller is operating in 1:2 frequency mode, 1T mode, program this to tRAS(min)/2. No rounding up. When the controller is operating in 1:2 frequency ratio mode, 2T mode or LPDDR4 mode, program this to (tRAS(min)/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG0_T_RAS_MIN_Msk          (_U_(0x3F) << UDDRC_DRAMTMG0_T_RAS_MIN_Pos)          /**< (UDDRC_DRAMTMG0) tRAS(min):  Minimum time between activate and precharge to the same bank. When the controller is operating in 1:2 frequency mode, 1T mode, program this to tRAS(min)/2. No rounding up. When the controller is operating in 1:2 frequency ratio mode, 2T mode or LPDDR4 mode, program this to (tRAS(min)/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG0_T_RAS_MIN(value)       (UDDRC_DRAMTMG0_T_RAS_MIN_Msk & ((value) << UDDRC_DRAMTMG0_T_RAS_MIN_Pos))
#define UDDRC_DRAMTMG0_T_RAS_MAX_Pos          _U_(8)                                               /**< (UDDRC_DRAMTMG0) tRAS(max):  Maximum time between activate and precharge to same bank. This is the maximum time that a page can be kept open Minimum value of this register is 1. Zero is invalid.     When the controller is operating in 1:1 frequency ratio mode, t_ras_max should be set to RoundDown(tRAS(max)/tCK/1024).     When the controller is operating in 1:2 frequency ratio mode, t_ras_max should be set to RoundDown((RoundDown(tRAS(max)/tCK/1024)-1)/2). Unit: Multiples of 1024 DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG0_T_RAS_MAX_Msk          (_U_(0x7F) << UDDRC_DRAMTMG0_T_RAS_MAX_Pos)          /**< (UDDRC_DRAMTMG0) tRAS(max):  Maximum time between activate and precharge to same bank. This is the maximum time that a page can be kept open Minimum value of this register is 1. Zero is invalid.     When the controller is operating in 1:1 frequency ratio mode, t_ras_max should be set to RoundDown(tRAS(max)/tCK/1024).     When the controller is operating in 1:2 frequency ratio mode, t_ras_max should be set to RoundDown((RoundDown(tRAS(max)/tCK/1024)-1)/2). Unit: Multiples of 1024 DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG0_T_RAS_MAX(value)       (UDDRC_DRAMTMG0_T_RAS_MAX_Msk & ((value) << UDDRC_DRAMTMG0_T_RAS_MAX_Pos))
#define UDDRC_DRAMTMG0_T_FAW0_Pos             _U_(16)                                              /**< (UDDRC_DRAMTMG0) tFAW Valid only when 8 or more banks(or banks 0 bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG0_T_FAW0_Msk             (_U_(0x1) << UDDRC_DRAMTMG0_T_FAW0_Pos)              /**< (UDDRC_DRAMTMG0) tFAW Valid only when 8 or more banks(or banks 0 bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG0_T_FAW0(value)          (UDDRC_DRAMTMG0_T_FAW0_Msk & ((value) << UDDRC_DRAMTMG0_T_FAW0_Pos))
#define UDDRC_DRAMTMG0_T_FAW1_Pos             _U_(17)                                              /**< (UDDRC_DRAMTMG0) tFAW Valid only when 8 or more banks(or banks 1 bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG0_T_FAW1_Msk             (_U_(0x1) << UDDRC_DRAMTMG0_T_FAW1_Pos)              /**< (UDDRC_DRAMTMG0) tFAW Valid only when 8 or more banks(or banks 1 bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG0_T_FAW1(value)          (UDDRC_DRAMTMG0_T_FAW1_Msk & ((value) << UDDRC_DRAMTMG0_T_FAW1_Pos))
#define UDDRC_DRAMTMG0_T_FAW2_Pos             _U_(18)                                              /**< (UDDRC_DRAMTMG0) tFAW Valid only when 8 or more banks(or banks 2 bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG0_T_FAW2_Msk             (_U_(0x1) << UDDRC_DRAMTMG0_T_FAW2_Pos)              /**< (UDDRC_DRAMTMG0) tFAW Valid only when 8 or more banks(or banks 2 bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG0_T_FAW2(value)          (UDDRC_DRAMTMG0_T_FAW2_Msk & ((value) << UDDRC_DRAMTMG0_T_FAW2_Pos))
#define UDDRC_DRAMTMG0_T_FAW3_Pos             _U_(19)                                              /**< (UDDRC_DRAMTMG0) tFAW Valid only when 8 or more banks(or banks 3 bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG0_T_FAW3_Msk             (_U_(0x1) << UDDRC_DRAMTMG0_T_FAW3_Pos)              /**< (UDDRC_DRAMTMG0) tFAW Valid only when 8 or more banks(or banks 3 bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG0_T_FAW3(value)          (UDDRC_DRAMTMG0_T_FAW3_Msk & ((value) << UDDRC_DRAMTMG0_T_FAW3_Pos))
#define UDDRC_DRAMTMG0_T_FAW4_Pos             _U_(20)                                              /**< (UDDRC_DRAMTMG0) tFAW Valid only when 8 or more banks(or banks 4 bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG0_T_FAW4_Msk             (_U_(0x1) << UDDRC_DRAMTMG0_T_FAW4_Pos)              /**< (UDDRC_DRAMTMG0) tFAW Valid only when 8 or more banks(or banks 4 bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG0_T_FAW4(value)          (UDDRC_DRAMTMG0_T_FAW4_Msk & ((value) << UDDRC_DRAMTMG0_T_FAW4_Pos))
#define UDDRC_DRAMTMG0_T_FAW5_Pos             _U_(21)                                              /**< (UDDRC_DRAMTMG0) tFAW Valid only when 8 or more banks(or banks 5 bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG0_T_FAW5_Msk             (_U_(0x1) << UDDRC_DRAMTMG0_T_FAW5_Pos)              /**< (UDDRC_DRAMTMG0) tFAW Valid only when 8 or more banks(or banks 5 bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG0_T_FAW5(value)          (UDDRC_DRAMTMG0_T_FAW5_Msk & ((value) << UDDRC_DRAMTMG0_T_FAW5_Pos))
#define UDDRC_DRAMTMG0_WR2PRE_Pos             _U_(24)                                              /**< (UDDRC_DRAMTMG0) Minimum time between write and precharge to same bank. Specifications: WL + BL/2 + tWR = approximately 8 cycles + 15 ns = 14 clocks @400MHz and less for lower frequencies where:  - WL = write latency  - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM. BST (burst terminate) is not supported at present.  - tWR = Write recovery time. This comes directly from the SDRAM specification.  Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 for this parameter. When the controller is operating in 1:2 frequency ratio mode, 1T mode, divide the above value by 2. No rounding up. When the controller is operating in 1:2 frequency ratio mode, 2T mode or LPDDR4 mode, divide the above value by 2 and round it up to the next integer value.  Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 Position */
#define UDDRC_DRAMTMG0_WR2PRE_Msk             (_U_(0x7F) << UDDRC_DRAMTMG0_WR2PRE_Pos)             /**< (UDDRC_DRAMTMG0) Minimum time between write and precharge to same bank. Specifications: WL + BL/2 + tWR = approximately 8 cycles + 15 ns = 14 clocks @400MHz and less for lower frequencies where:  - WL = write latency  - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM. BST (burst terminate) is not supported at present.  - tWR = Write recovery time. This comes directly from the SDRAM specification.  Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 for this parameter. When the controller is operating in 1:2 frequency ratio mode, 1T mode, divide the above value by 2. No rounding up. When the controller is operating in 1:2 frequency ratio mode, 2T mode or LPDDR4 mode, divide the above value by 2 and round it up to the next integer value.  Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG0_WR2PRE(value)          (UDDRC_DRAMTMG0_WR2PRE_Msk & ((value) << UDDRC_DRAMTMG0_WR2PRE_Pos))
#define UDDRC_DRAMTMG0_Msk                    _U_(0x7F3F7F3F)                                      /**< (UDDRC_DRAMTMG0) Register Mask  */

#define UDDRC_DRAMTMG0_T_FAW_Pos              _U_(16)                                              /**< (UDDRC_DRAMTMG0 Position) tFAW Valid only when 8 or more banks(or banks x bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in x:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to xxx independent of the x:x/x:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 */
#define UDDRC_DRAMTMG0_T_FAW_Msk              (_U_(0x3F) << UDDRC_DRAMTMG0_T_FAW_Pos)              /**< (UDDRC_DRAMTMG0 Mask) T_FAW */
#define UDDRC_DRAMTMG0_T_FAW(value)           (UDDRC_DRAMTMG0_T_FAW_Msk & ((value) << UDDRC_DRAMTMG0_T_FAW_Pos)) 

/* -------- UDDRC_DRAMTMG1 : (UDDRC Offset: 0x104) (R/W 32) SDRAM Timing Register 1 -------- */
#define UDDRC_DRAMTMG1_RESETVALUE             _U_(0x80414)                                         /**<  (UDDRC_DRAMTMG1) SDRAM Timing Register 1  Reset Value */

#define UDDRC_DRAMTMG1_T_RC_Pos               _U_(0)                                               /**< (UDDRC_DRAMTMG1) tRC:  Minimum time between activates to same bank. When the controller is operating in 1:2 frequency ratio mode, program this to (tRC/2) and round up to next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG1_T_RC_Msk               (_U_(0x7F) << UDDRC_DRAMTMG1_T_RC_Pos)               /**< (UDDRC_DRAMTMG1) tRC:  Minimum time between activates to same bank. When the controller is operating in 1:2 frequency ratio mode, program this to (tRC/2) and round up to next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG1_T_RC(value)            (UDDRC_DRAMTMG1_T_RC_Msk & ((value) << UDDRC_DRAMTMG1_T_RC_Pos))
#define UDDRC_DRAMTMG1_RD2PRE_Pos             _U_(8)                                               /**< (UDDRC_DRAMTMG1) tRTP:  Minimum time from read to precharge of same bank.  - DDR2: tAL + BL/2 + max(tRTP, 2) - 2  - DDR3: tAL + max (tRTP, 4)  - DDR4: Max of following two equations:            tAL + max (tRTP, 4) or,             RL + BL/2 - tRP (*).  - mDDR: BL/2  - LPDDR2: Depends on if it's LPDDR2-S2 or LPDDR2-S4:            LPDDR2-S2: BL/2 + tRTP - 1.            LPDDR2-S4: BL/2 + max(tRTP,2) - 2.  - LPDDR3: BL/2 +  max(tRTP,4) - 4  - LPDDR4: BL/2 + max(tRTP,8) - 8 (*) When both DDR4 SDRAM and ST-MRAM are used simultaneously, use SDRAM's tRP value for calculation.  When the controller is operating in 1:2 mode, 1T mode, divide the above value by 2. No rounding up.  When the controller is operating in 1:2 mode, 2T mode or LPDDR4 mode, divide the above value by 2 and round it up to the next integer value.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 Position */
#define UDDRC_DRAMTMG1_RD2PRE_Msk             (_U_(0x3F) << UDDRC_DRAMTMG1_RD2PRE_Pos)             /**< (UDDRC_DRAMTMG1) tRTP:  Minimum time from read to precharge of same bank.  - DDR2: tAL + BL/2 + max(tRTP, 2) - 2  - DDR3: tAL + max (tRTP, 4)  - DDR4: Max of following two equations:            tAL + max (tRTP, 4) or,             RL + BL/2 - tRP (*).  - mDDR: BL/2  - LPDDR2: Depends on if it's LPDDR2-S2 or LPDDR2-S4:            LPDDR2-S2: BL/2 + tRTP - 1.            LPDDR2-S4: BL/2 + max(tRTP,2) - 2.  - LPDDR3: BL/2 +  max(tRTP,4) - 4  - LPDDR4: BL/2 + max(tRTP,8) - 8 (*) When both DDR4 SDRAM and ST-MRAM are used simultaneously, use SDRAM's tRP value for calculation.  When the controller is operating in 1:2 mode, 1T mode, divide the above value by 2. No rounding up.  When the controller is operating in 1:2 mode, 2T mode or LPDDR4 mode, divide the above value by 2 and round it up to the next integer value.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG1_RD2PRE(value)          (UDDRC_DRAMTMG1_RD2PRE_Msk & ((value) << UDDRC_DRAMTMG1_RD2PRE_Pos))
#define UDDRC_DRAMTMG1_T_XP_Pos               _U_(16)                                              /**< (UDDRC_DRAMTMG1) tXP: Minimum time after power-down exit to any operation.  For DDR3, this should be programmed to tXPDLL if slow powerdown exit is selected in MR0[12].   If C/A parity for DDR4 is used, set to (tXP+PL) instead.  If LPDDR4 is selected and its spec has tCKELPD parameter, set to the larger of tXP and tCKELPD instead. When the controller is operating in 1:2 frequency ratio mode, program this to (tXP/2) and round it up to the next integer value. Units: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG1_T_XP_Msk               (_U_(0x1F) << UDDRC_DRAMTMG1_T_XP_Pos)               /**< (UDDRC_DRAMTMG1) tXP: Minimum time after power-down exit to any operation.  For DDR3, this should be programmed to tXPDLL if slow powerdown exit is selected in MR0[12].   If C/A parity for DDR4 is used, set to (tXP+PL) instead.  If LPDDR4 is selected and its spec has tCKELPD parameter, set to the larger of tXP and tCKELPD instead. When the controller is operating in 1:2 frequency ratio mode, program this to (tXP/2) and round it up to the next integer value. Units: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG1_T_XP(value)            (UDDRC_DRAMTMG1_T_XP_Msk & ((value) << UDDRC_DRAMTMG1_T_XP_Pos))
#define UDDRC_DRAMTMG1_Msk                    _U_(0x001F3F7F)                                      /**< (UDDRC_DRAMTMG1) Register Mask  */


/* -------- UDDRC_DRAMTMG2 : (UDDRC Offset: 0x108) (R/W 32) SDRAM Timing Register 2 -------- */
#define UDDRC_DRAMTMG2_RESETVALUE             _U_(0x305060D)                                       /**<  (UDDRC_DRAMTMG2) SDRAM Timing Register 2  Reset Value */

#define UDDRC_DRAMTMG2_WR2RD_Pos              _U_(0)                                               /**< (UDDRC_DRAMTMG2) DDR4: CWL + PL + BL/2 + tWTR_L LPDDR2/3/4: WL + BL/2 + tWTR + 1 Others: CWL + BL/2 + tWTR In DDR4, minimum time from write command to read command for same bank group. In others, minimum time from write command to read command. Includes time for bus turnaround, recovery times, and all per-bank, per-rank, and global constraints.  Please see the relevant PHY databook for details of what should be included here. Where:  - CWL = CAS write latency  - WL = Write latency  - PL = Parity latency  - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - tWTR_L = internal write to read command delay for same bank group. This comes directly from the SDRAM specification.   - tWTR = internal write to read command delay. This comes directly from the SDRAM specification.  After PHY has completed training the value programmed may need to be increased. Refer to relevant PHY documentation.  Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 operation.  WTR_L should be increased by one if DDR4 2tCK write preamble is used. When the controller is operating in 1:2 mode, divide the value calculated using the above equation by 2, and round it up to next integer.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 Position */
#define UDDRC_DRAMTMG2_WR2RD_Msk              (_U_(0x3F) << UDDRC_DRAMTMG2_WR2RD_Pos)              /**< (UDDRC_DRAMTMG2) DDR4: CWL + PL + BL/2 + tWTR_L LPDDR2/3/4: WL + BL/2 + tWTR + 1 Others: CWL + BL/2 + tWTR In DDR4, minimum time from write command to read command for same bank group. In others, minimum time from write command to read command. Includes time for bus turnaround, recovery times, and all per-bank, per-rank, and global constraints.  Please see the relevant PHY databook for details of what should be included here. Where:  - CWL = CAS write latency  - WL = Write latency  - PL = Parity latency  - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - tWTR_L = internal write to read command delay for same bank group. This comes directly from the SDRAM specification.   - tWTR = internal write to read command delay. This comes directly from the SDRAM specification.  After PHY has completed training the value programmed may need to be increased. Refer to relevant PHY documentation.  Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 operation.  WTR_L should be increased by one if DDR4 2tCK write preamble is used. When the controller is operating in 1:2 mode, divide the value calculated using the above equation by 2, and round it up to next integer.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG2_WR2RD(value)           (UDDRC_DRAMTMG2_WR2RD_Msk & ((value) << UDDRC_DRAMTMG2_WR2RD_Pos))
#define UDDRC_DRAMTMG2_RD2WR_Pos              _U_(8)                                               /**< (UDDRC_DRAMTMG2) DDR2/3/mDDR: RL + BL/2 + 2 - WL  DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL  LPDDR2/LPDDR3: RL + BL/2 + RU(tDQSCKmax/tCK) + 1 - WL  LPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE + RD_POSTAMBLE - WL  LPDDR4(DQ ODT is Enabled) : RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE - ODTLon - RU(tODTon(min)/tCK) + 1  Minimum time from read command to write command. Include time for bus turnaround and all per-bank, per-rank, and global constraints.  Please see the relevant PHY databook for details of what should be included here. Where:  - WL = write latency  - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - RL = read latency = CAS latency  - WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble).  This is unique to DDR4 and LPDDR4.  - RD_POSTAMBLE = 0.5 (0.5tCK read postamble), 1.5 (1.5tCK read postamble).  This is unique to LPDDR4. After PHY has completed training the value programmed may need to be increased. Refer to relevant PHY documentation.  For LPDDR2/LPDDR3/LPDDR4, if derating is enabled (DERATEEN.derate_enable=1), derated tDQSCKmax should be used.  When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the above equation by 2, and round it up to next integer.  Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 Position */
#define UDDRC_DRAMTMG2_RD2WR_Msk              (_U_(0x3F) << UDDRC_DRAMTMG2_RD2WR_Pos)              /**< (UDDRC_DRAMTMG2) DDR2/3/mDDR: RL + BL/2 + 2 - WL  DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL  LPDDR2/LPDDR3: RL + BL/2 + RU(tDQSCKmax/tCK) + 1 - WL  LPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE + RD_POSTAMBLE - WL  LPDDR4(DQ ODT is Enabled) : RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE - ODTLon - RU(tODTon(min)/tCK) + 1  Minimum time from read command to write command. Include time for bus turnaround and all per-bank, per-rank, and global constraints.  Please see the relevant PHY databook for details of what should be included here. Where:  - WL = write latency  - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - RL = read latency = CAS latency  - WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble).  This is unique to DDR4 and LPDDR4.  - RD_POSTAMBLE = 0.5 (0.5tCK read postamble), 1.5 (1.5tCK read postamble).  This is unique to LPDDR4. After PHY has completed training the value programmed may need to be increased. Refer to relevant PHY documentation.  For LPDDR2/LPDDR3/LPDDR4, if derating is enabled (DERATEEN.derate_enable=1), derated tDQSCKmax should be used.  When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the above equation by 2, and round it up to next integer.  Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG2_RD2WR(value)           (UDDRC_DRAMTMG2_RD2WR_Msk & ((value) << UDDRC_DRAMTMG2_RD2WR_Pos))
#define UDDRC_DRAMTMG2_READ_LATENCY_Pos       _U_(16)                                              /**< (UDDRC_DRAMTMG2) Set to RL Time from read command to read data on SDRAM interface. This must be set to RL. Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to adjust the value of RL to compensate for the extra cycle of latency through the RDIMM/LRDIMM. When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the above equation by 2, and round it up to next integer. This register field is not required for DDR2 and DDR3, as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols For all protocols, in addition to programming this register field, it is necessary to program DFITMG0 and DFITMG1 to control the read and write latencies Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 Position */
#define UDDRC_DRAMTMG2_READ_LATENCY_Msk       (_U_(0x3F) << UDDRC_DRAMTMG2_READ_LATENCY_Pos)       /**< (UDDRC_DRAMTMG2) Set to RL Time from read command to read data on SDRAM interface. This must be set to RL. Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to adjust the value of RL to compensate for the extra cycle of latency through the RDIMM/LRDIMM. When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the above equation by 2, and round it up to next integer. This register field is not required for DDR2 and DDR3, as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols For all protocols, in addition to programming this register field, it is necessary to program DFITMG0 and DFITMG1 to control the read and write latencies Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG2_READ_LATENCY(value)    (UDDRC_DRAMTMG2_READ_LATENCY_Msk & ((value) << UDDRC_DRAMTMG2_READ_LATENCY_Pos))
#define UDDRC_DRAMTMG2_WRITE_LATENCY_Pos      _U_(24)                                              /**< (UDDRC_DRAMTMG2) Set to WL Time from write command to write data on SDRAM interface. This must be set to WL. For mDDR, it should normally be set to 1. Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to adjust the value of WL to compensate for the extra cycle of latency through the RDIMM/LRDIMM. When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the above equation by 2, and round it up to next integer. This register field is not required for DDR2 and DDR3, as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols For all protocols, in addition to programming this register field, it is necessary to program DFITMG0 and DFITMG1 to control the read and write latencies Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 Position */
#define UDDRC_DRAMTMG2_WRITE_LATENCY_Msk      (_U_(0x3F) << UDDRC_DRAMTMG2_WRITE_LATENCY_Pos)      /**< (UDDRC_DRAMTMG2) Set to WL Time from write command to write data on SDRAM interface. This must be set to WL. For mDDR, it should normally be set to 1. Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to adjust the value of WL to compensate for the extra cycle of latency through the RDIMM/LRDIMM. When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the above equation by 2, and round it up to next integer. This register field is not required for DDR2 and DDR3, as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols For all protocols, in addition to programming this register field, it is necessary to program DFITMG0 and DFITMG1 to control the read and write latencies Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG2_WRITE_LATENCY(value)   (UDDRC_DRAMTMG2_WRITE_LATENCY_Msk & ((value) << UDDRC_DRAMTMG2_WRITE_LATENCY_Pos))
#define UDDRC_DRAMTMG2_Msk                    _U_(0x3F3F3F3F)                                      /**< (UDDRC_DRAMTMG2) Register Mask  */


/* -------- UDDRC_DRAMTMG3 : (UDDRC Offset: 0x10C) (R/W 32) SDRAM Timing Register 3 -------- */
#define UDDRC_DRAMTMG3_RESETVALUE             _U_(0x50400C)                                        /**<  (UDDRC_DRAMTMG3) SDRAM Timing Register 3  Reset Value */

#define UDDRC_DRAMTMG3_T_MOD_Pos              _U_(0)                                               /**< (UDDRC_DRAMTMG3) tMOD: Parameter used only in DDR3 and DDR4. Cycles between load mode command and following non-load mode command. If C/A parity for DDR4 is used, set to tMOD_PAR(tMOD+PL) instead. If CAL mode is enabled (DFITMG1.dfi_t_cmd_lat > 0), tCAL (=DFITMG1.dfi_cmd_lat) should be added to the above calculations. If MPR writes for DDR4 are used, set to tMOD + AL (or tMPD_PAR + AL if C/A parity is also used). Set to tMOD if controller is operating in 1:1 frequency ratio mode, or tMOD/2 (rounded up to next integer) if controller is operating in 1:2 frequency ratio mode. Note that if using RDIMM/LRDIMM, depending on the PHY, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency applied to mode register writes by the RDIMM/LRDIMM chip. Also note that if using LRDIMM, the minimum value of this register is tMRD_L2 if controller is operating in 1:1 frequency ratio mode, or tMRD_L2/2 (rounded up to next integer) if controller is operating in 1:2 frequency ratio mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG3_T_MOD_Msk              (_U_(0x3FF) << UDDRC_DRAMTMG3_T_MOD_Pos)             /**< (UDDRC_DRAMTMG3) tMOD: Parameter used only in DDR3 and DDR4. Cycles between load mode command and following non-load mode command. If C/A parity for DDR4 is used, set to tMOD_PAR(tMOD+PL) instead. If CAL mode is enabled (DFITMG1.dfi_t_cmd_lat > 0), tCAL (=DFITMG1.dfi_cmd_lat) should be added to the above calculations. If MPR writes for DDR4 are used, set to tMOD + AL (or tMPD_PAR + AL if C/A parity is also used). Set to tMOD if controller is operating in 1:1 frequency ratio mode, or tMOD/2 (rounded up to next integer) if controller is operating in 1:2 frequency ratio mode. Note that if using RDIMM/LRDIMM, depending on the PHY, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency applied to mode register writes by the RDIMM/LRDIMM chip. Also note that if using LRDIMM, the minimum value of this register is tMRD_L2 if controller is operating in 1:1 frequency ratio mode, or tMRD_L2/2 (rounded up to next integer) if controller is operating in 1:2 frequency ratio mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG3_T_MOD(value)           (UDDRC_DRAMTMG3_T_MOD_Msk & ((value) << UDDRC_DRAMTMG3_T_MOD_Pos))
#define UDDRC_DRAMTMG3_T_MRD_Pos              _U_(12)                                              /**< (UDDRC_DRAMTMG3) tMRD: Cycles to wait after a mode register write or read. Depending on the connected SDRAM, tMRD represents: DDR2/mDDR: Time from MRS to any command DDR3/4: Time from MRS to MRS command LPDDR2: not used LPDDR3/4: Time from MRS to non-MRS command. When the controller is operating in 1:2 frequency ratio mode, program this to (tMRD/2) and round it up to the next integer value. If C/A parity for DDR4 is used, set to tMRD_PAR(tMOD+PL) instead. If CAL mode is enabled (DFITMG1.dfi_t_cmd_lat > 0), tCAL (=DFITMG1.dfi_cmd_lat) should be added to the above calculations. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG3_T_MRD_Msk              (_U_(0x3F) << UDDRC_DRAMTMG3_T_MRD_Pos)              /**< (UDDRC_DRAMTMG3) tMRD: Cycles to wait after a mode register write or read. Depending on the connected SDRAM, tMRD represents: DDR2/mDDR: Time from MRS to any command DDR3/4: Time from MRS to MRS command LPDDR2: not used LPDDR3/4: Time from MRS to non-MRS command. When the controller is operating in 1:2 frequency ratio mode, program this to (tMRD/2) and round it up to the next integer value. If C/A parity for DDR4 is used, set to tMRD_PAR(tMOD+PL) instead. If CAL mode is enabled (DFITMG1.dfi_t_cmd_lat > 0), tCAL (=DFITMG1.dfi_cmd_lat) should be added to the above calculations. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG3_T_MRD(value)           (UDDRC_DRAMTMG3_T_MRD_Msk & ((value) << UDDRC_DRAMTMG3_T_MRD_Pos))
#define UDDRC_DRAMTMG3_T_MRW_Pos              _U_(20)                                              /**< (UDDRC_DRAMTMG3) Time to wait after a mode register write or read (MRW or MRR). Present only in designs configured to support LPDDR2, LPDDR3 or LPDDR4. LPDDR2 typically requires value of 5. LPDDR3 typically requires value of 10. LPDDR4: Set this to the larger of tMRW and tMRWCKEL. For LPDDR2, this register is used for the time from a MRW/MRR to all other commands. When the controller is operating in 1:2 frequency ratio mode, program this to the above values divided by 2 and round it up to the next integer value. For LDPDR3, this register is used for the time from a MRW/MRR to a MRW/MRR. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG3_T_MRW_Msk              (_U_(0x3FF) << UDDRC_DRAMTMG3_T_MRW_Pos)             /**< (UDDRC_DRAMTMG3) Time to wait after a mode register write or read (MRW or MRR). Present only in designs configured to support LPDDR2, LPDDR3 or LPDDR4. LPDDR2 typically requires value of 5. LPDDR3 typically requires value of 10. LPDDR4: Set this to the larger of tMRW and tMRWCKEL. For LPDDR2, this register is used for the time from a MRW/MRR to all other commands. When the controller is operating in 1:2 frequency ratio mode, program this to the above values divided by 2 and round it up to the next integer value. For LDPDR3, this register is used for the time from a MRW/MRR to a MRW/MRR. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG3_T_MRW(value)           (UDDRC_DRAMTMG3_T_MRW_Msk & ((value) << UDDRC_DRAMTMG3_T_MRW_Pos))
#define UDDRC_DRAMTMG3_Msk                    _U_(0x3FF3F3FF)                                      /**< (UDDRC_DRAMTMG3) Register Mask  */


/* -------- UDDRC_DRAMTMG4 : (UDDRC Offset: 0x110) (R/W 32) SDRAM Timing Register 4 -------- */
#define UDDRC_DRAMTMG4_RESETVALUE             _U_(0x5040405)                                       /**<  (UDDRC_DRAMTMG4) SDRAM Timing Register 4  Reset Value */

#define UDDRC_DRAMTMG4_T_RP_Pos               _U_(0)                                               /**< (UDDRC_DRAMTMG4) tRP:  Minimum time from single-bank precharge to activate of same bank.      When the controller is operating in 1:1 frequency ratio mode, t_rp should be set to RoundUp(tRP/tCK).      When the controller is operating in 1:2 frequency ratio mode, t_rp should be set to RoundDown(RoundUp(tRP/tCK)/2) + 1.      When the controller is operating in 1:2 frequency ratio mode in LPDDR4, t_rp should be set to RoundUp(RoundUp(tRP/tCK)/2).      Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG4_T_RP_Msk               (_U_(0x1F) << UDDRC_DRAMTMG4_T_RP_Pos)               /**< (UDDRC_DRAMTMG4) tRP:  Minimum time from single-bank precharge to activate of same bank.      When the controller is operating in 1:1 frequency ratio mode, t_rp should be set to RoundUp(tRP/tCK).      When the controller is operating in 1:2 frequency ratio mode, t_rp should be set to RoundDown(RoundUp(tRP/tCK)/2) + 1.      When the controller is operating in 1:2 frequency ratio mode in LPDDR4, t_rp should be set to RoundUp(RoundUp(tRP/tCK)/2).      Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG4_T_RP(value)            (UDDRC_DRAMTMG4_T_RP_Msk & ((value) << UDDRC_DRAMTMG4_T_RP_Pos))
#define UDDRC_DRAMTMG4_T_RRD_Pos              _U_(8)                                               /**< (UDDRC_DRAMTMG4) DDR4: tRRD_L: Minimum time between activates from bank "a" to bank "b" for same bank group. Others: tRRD: Minimum time between activates from bank "a" to bank "b" When the controller is operating in 1:2 frequency ratio mode, program this to (tRRD_L/2 or tRRD/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG4_T_RRD_Msk              (_U_(0xF) << UDDRC_DRAMTMG4_T_RRD_Pos)               /**< (UDDRC_DRAMTMG4) DDR4: tRRD_L: Minimum time between activates from bank "a" to bank "b" for same bank group. Others: tRRD: Minimum time between activates from bank "a" to bank "b" When the controller is operating in 1:2 frequency ratio mode, program this to (tRRD_L/2 or tRRD/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG4_T_RRD(value)           (UDDRC_DRAMTMG4_T_RRD_Msk & ((value) << UDDRC_DRAMTMG4_T_RRD_Pos))
#define UDDRC_DRAMTMG4_T_CCD_Pos              _U_(16)                                              /**< (UDDRC_DRAMTMG4) DDR4: tCCD_L: This is the minimum time between two reads or two writes for same bank group. Others: tCCD: This is the minimum time between two reads or two writes. When the controller is operating in 1:2 frequency ratio mode, program this to (tCCD_L/2 or tCCD/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG4_T_CCD_Msk              (_U_(0xF) << UDDRC_DRAMTMG4_T_CCD_Pos)               /**< (UDDRC_DRAMTMG4) DDR4: tCCD_L: This is the minimum time between two reads or two writes for same bank group. Others: tCCD: This is the minimum time between two reads or two writes. When the controller is operating in 1:2 frequency ratio mode, program this to (tCCD_L/2 or tCCD/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG4_T_CCD(value)           (UDDRC_DRAMTMG4_T_CCD_Msk & ((value) << UDDRC_DRAMTMG4_T_CCD_Pos))
#define UDDRC_DRAMTMG4_T_RCD_Pos              _U_(24)                                              /**< (UDDRC_DRAMTMG4) tRCD - tAL: Minimum time from activate to read or write command to same bank. When the controller is operating in 1:2 frequency ratio mode, program this to ((tRCD - tAL)/2) and round it up to the next integer value.  Minimum value allowed for this register is 1, which implies minimum (tRCD - tAL) value to be 2 when the controller is operating in 1:2 frequency ratio mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 Position */
#define UDDRC_DRAMTMG4_T_RCD_Msk              (_U_(0x1F) << UDDRC_DRAMTMG4_T_RCD_Pos)              /**< (UDDRC_DRAMTMG4) tRCD - tAL: Minimum time from activate to read or write command to same bank. When the controller is operating in 1:2 frequency ratio mode, program this to ((tRCD - tAL)/2) and round it up to the next integer value.  Minimum value allowed for this register is 1, which implies minimum (tRCD - tAL) value to be 2 when the controller is operating in 1:2 frequency ratio mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG4_T_RCD(value)           (UDDRC_DRAMTMG4_T_RCD_Msk & ((value) << UDDRC_DRAMTMG4_T_RCD_Pos))
#define UDDRC_DRAMTMG4_Msk                    _U_(0x1F0F0F1F)                                      /**< (UDDRC_DRAMTMG4) Register Mask  */


/* -------- UDDRC_DRAMTMG5 : (UDDRC Offset: 0x114) (R/W 32) SDRAM Timing Register 5 -------- */
#define UDDRC_DRAMTMG5_RESETVALUE             _U_(0x5050403)                                       /**<  (UDDRC_DRAMTMG5) SDRAM Timing Register 5  Reset Value */

#define UDDRC_DRAMTMG5_T_CKE_Pos              _U_(0)                                               /**< (UDDRC_DRAMTMG5) Minimum number of cycles of CKE HIGH/LOW during power-down and self refresh.  - LPDDR2/LPDDR3 mode: Set this to the larger of tCKE or tCKESR  - LPDDR4 mode: Set this to the larger of tCKE or tSR.  - Non-LPDDR2/non-LPDDR3/non-LPDDR4 designs: Set this to tCKE value. When the controller is operating in 1:2 frequency ratio mode, program this to (value described above)/2 and round it up to the next integer value.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG5_T_CKE_Msk              (_U_(0x1F) << UDDRC_DRAMTMG5_T_CKE_Pos)              /**< (UDDRC_DRAMTMG5) Minimum number of cycles of CKE HIGH/LOW during power-down and self refresh.  - LPDDR2/LPDDR3 mode: Set this to the larger of tCKE or tCKESR  - LPDDR4 mode: Set this to the larger of tCKE or tSR.  - Non-LPDDR2/non-LPDDR3/non-LPDDR4 designs: Set this to tCKE value. When the controller is operating in 1:2 frequency ratio mode, program this to (value described above)/2 and round it up to the next integer value.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG5_T_CKE(value)           (UDDRC_DRAMTMG5_T_CKE_Msk & ((value) << UDDRC_DRAMTMG5_T_CKE_Pos))
#define UDDRC_DRAMTMG5_T_CKESR_Pos            _U_(8)                                               /**< (UDDRC_DRAMTMG5) Minimum CKE low width for Self refresh or Self refresh power down entry to exit timing in memory clock cycles.   Recommended settings:     - mDDR: tRFC     - LPDDR2: tCKESR     - LPDDR3: tCKESR     - LPDDR4: max(tCKE, tSR)     - DDR2: tCKE      - DDR3: tCKE + 1       - DDR4: tCKE + 1 (+ PL(parity latency)(*))  (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register should be increased by PL.  When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG5_T_CKESR_Msk            (_U_(0x3F) << UDDRC_DRAMTMG5_T_CKESR_Pos)            /**< (UDDRC_DRAMTMG5) Minimum CKE low width for Self refresh or Self refresh power down entry to exit timing in memory clock cycles.   Recommended settings:     - mDDR: tRFC     - LPDDR2: tCKESR     - LPDDR3: tCKESR     - LPDDR4: max(tCKE, tSR)     - DDR2: tCKE      - DDR3: tCKE + 1       - DDR4: tCKE + 1 (+ PL(parity latency)(*))  (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register should be increased by PL.  When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG5_T_CKESR(value)         (UDDRC_DRAMTMG5_T_CKESR_Msk & ((value) << UDDRC_DRAMTMG5_T_CKESR_Pos))
#define UDDRC_DRAMTMG5_T_CKSRE_Pos            _U_(16)                                              /**< (UDDRC_DRAMTMG5) This is the time after Self Refresh Down Entry that CK is maintained as a valid clock. Specifies the clock disable delay after SRE.      Recommended settings:     - mDDR: 0     - LPDDR2: 2     - LPDDR3: 2     - LPDDR4: tCKELCK     - DDR2: 1      - DDR3: max (10 ns, 5 tCK)     - DDR4: max (10 ns, 5 tCK) (+ PL(parity latency)(*)) (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register should be increased by PL.  When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG5_T_CKSRE_Msk            (_U_(0xF) << UDDRC_DRAMTMG5_T_CKSRE_Pos)             /**< (UDDRC_DRAMTMG5) This is the time after Self Refresh Down Entry that CK is maintained as a valid clock. Specifies the clock disable delay after SRE.      Recommended settings:     - mDDR: 0     - LPDDR2: 2     - LPDDR3: 2     - LPDDR4: tCKELCK     - DDR2: 1      - DDR3: max (10 ns, 5 tCK)     - DDR4: max (10 ns, 5 tCK) (+ PL(parity latency)(*)) (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register should be increased by PL.  When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG5_T_CKSRE(value)         (UDDRC_DRAMTMG5_T_CKSRE_Msk & ((value) << UDDRC_DRAMTMG5_T_CKSRE_Pos))
#define UDDRC_DRAMTMG5_T_CKSRX_Pos            _U_(24)                                              /**< (UDDRC_DRAMTMG5) This is the time before Self Refresh Exit that CK is maintained as a valid clock before issuing SRX. Specifies the clock stable time before SRX.       Recommended settings:     - mDDR: 1     - LPDDR2: 2     - LPDDR3: 2     - LPDDR4: tCKCKEH     - DDR2: 1       - DDR3: tCKSRX      - DDR4: tCKSRX  When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG5_T_CKSRX_Msk            (_U_(0xF) << UDDRC_DRAMTMG5_T_CKSRX_Pos)             /**< (UDDRC_DRAMTMG5) This is the time before Self Refresh Exit that CK is maintained as a valid clock before issuing SRX. Specifies the clock stable time before SRX.       Recommended settings:     - mDDR: 1     - LPDDR2: 2     - LPDDR3: 2     - LPDDR4: tCKCKEH     - DDR2: 1       - DDR3: tCKSRX      - DDR4: tCKSRX  When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG5_T_CKSRX(value)         (UDDRC_DRAMTMG5_T_CKSRX_Msk & ((value) << UDDRC_DRAMTMG5_T_CKSRX_Pos))
#define UDDRC_DRAMTMG5_Msk                    _U_(0x0F0F3F1F)                                      /**< (UDDRC_DRAMTMG5) Register Mask  */


/* -------- UDDRC_DRAMTMG6 : (UDDRC Offset: 0x118) (R/W 32) SDRAM Timing Register 6 -------- */
#define UDDRC_DRAMTMG6_RESETVALUE             _U_(0x2020005)                                       /**<  (UDDRC_DRAMTMG6) SDRAM Timing Register 6  Reset Value */

#define UDDRC_DRAMTMG6_T_CKCSX_Pos            _U_(0)                                               /**< (UDDRC_DRAMTMG6) This is the time before Clock Stop Exit that CK is maintained as a valid clock before issuing Clock Stop Exit. Specifies the clock stable time before next command after Clock Stop Exit.       Recommended settings:     - mDDR: 1     - LPDDR2: tXP + 2     - LPDDR3: tXP + 2     - LPDDR4: tXP + 2 When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.   This is only present for designs supporting mDDR or LPDDR2/LPDDR3/LPDDR4 devices.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG6_T_CKCSX_Msk            (_U_(0xF) << UDDRC_DRAMTMG6_T_CKCSX_Pos)             /**< (UDDRC_DRAMTMG6) This is the time before Clock Stop Exit that CK is maintained as a valid clock before issuing Clock Stop Exit. Specifies the clock stable time before next command after Clock Stop Exit.       Recommended settings:     - mDDR: 1     - LPDDR2: tXP + 2     - LPDDR3: tXP + 2     - LPDDR4: tXP + 2 When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.   This is only present for designs supporting mDDR or LPDDR2/LPDDR3/LPDDR4 devices.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG6_T_CKCSX(value)         (UDDRC_DRAMTMG6_T_CKCSX_Msk & ((value) << UDDRC_DRAMTMG6_T_CKCSX_Pos))
#define UDDRC_DRAMTMG6_T_CKDPDX_Pos           _U_(16)                                              /**< (UDDRC_DRAMTMG6) This is the time before Deep Power Down Exit that CK is maintained as a valid clock before issuing DPDX. Specifies the clock stable time before DPDX.       Recommended settings:     - mDDR: 1     - LPDDR2: 2     - LPDDR3: 2 When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.   This is only present for designs supporting mDDR or LPDDR2 devices.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG6_T_CKDPDX_Msk           (_U_(0xF) << UDDRC_DRAMTMG6_T_CKDPDX_Pos)            /**< (UDDRC_DRAMTMG6) This is the time before Deep Power Down Exit that CK is maintained as a valid clock before issuing DPDX. Specifies the clock stable time before DPDX.       Recommended settings:     - mDDR: 1     - LPDDR2: 2     - LPDDR3: 2 When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.   This is only present for designs supporting mDDR or LPDDR2 devices.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG6_T_CKDPDX(value)        (UDDRC_DRAMTMG6_T_CKDPDX_Msk & ((value) << UDDRC_DRAMTMG6_T_CKDPDX_Pos))
#define UDDRC_DRAMTMG6_T_CKDPDE_Pos           _U_(24)                                              /**< (UDDRC_DRAMTMG6) This is the time after Deep Power Down Entry that CK is maintained as a valid clock. Specifies the clock disable delay after DPDE.   Recommended settings:     - mDDR: 0     - LPDDR2: 2     - LPDDR3: 2 When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.   This is only present for designs supporting mDDR or LPDDR2/LPDDR3 devices.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG6_T_CKDPDE_Msk           (_U_(0xF) << UDDRC_DRAMTMG6_T_CKDPDE_Pos)            /**< (UDDRC_DRAMTMG6) This is the time after Deep Power Down Entry that CK is maintained as a valid clock. Specifies the clock disable delay after DPDE.   Recommended settings:     - mDDR: 0     - LPDDR2: 2     - LPDDR3: 2 When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.   This is only present for designs supporting mDDR or LPDDR2/LPDDR3 devices.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG6_T_CKDPDE(value)        (UDDRC_DRAMTMG6_T_CKDPDE_Msk & ((value) << UDDRC_DRAMTMG6_T_CKDPDE_Pos))
#define UDDRC_DRAMTMG6_Msk                    _U_(0x0F0F000F)                                      /**< (UDDRC_DRAMTMG6) Register Mask  */


/* -------- UDDRC_DRAMTMG7 : (UDDRC Offset: 0x11C) (R/W 32) SDRAM Timing Register 7 -------- */
#define UDDRC_DRAMTMG7_RESETVALUE             _U_(0x202)                                           /**<  (UDDRC_DRAMTMG7) SDRAM Timing Register 7  Reset Value */

#define UDDRC_DRAMTMG7_T_CKPDX_Pos            _U_(0)                                               /**< (UDDRC_DRAMTMG7) This is the time before Power Down Exit that CK is maintained as a valid clock before issuing PDX. Specifies the clock stable time before PDX.       Recommended settings:     - mDDR: 0     - LPDDR2: 2     - LPDDR3: 2     - LPDDR4: tCKCKEH When using DDR2/3/4 SDRAM, this register should be set to the same value as DRAMTMG5.t_cksrx. When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.   This is only present for designs supporting mDDR or LPDDR2/LPDDR3/LPDDR4 devices.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG7_T_CKPDX_Msk            (_U_(0xF) << UDDRC_DRAMTMG7_T_CKPDX_Pos)             /**< (UDDRC_DRAMTMG7) This is the time before Power Down Exit that CK is maintained as a valid clock before issuing PDX. Specifies the clock stable time before PDX.       Recommended settings:     - mDDR: 0     - LPDDR2: 2     - LPDDR3: 2     - LPDDR4: tCKCKEH When using DDR2/3/4 SDRAM, this register should be set to the same value as DRAMTMG5.t_cksrx. When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.   This is only present for designs supporting mDDR or LPDDR2/LPDDR3/LPDDR4 devices.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG7_T_CKPDX(value)         (UDDRC_DRAMTMG7_T_CKPDX_Msk & ((value) << UDDRC_DRAMTMG7_T_CKPDX_Pos))
#define UDDRC_DRAMTMG7_T_CKPDE_Pos            _U_(8)                                               /**< (UDDRC_DRAMTMG7) This is the time after Power Down Entry that CK is maintained as a valid clock. Specifies the clock disable delay after PDE.       Recommended settings:     - mDDR: 0     - LPDDR2: 2     - LPDDR3: 2     - LPDDR4: tCKELCK When using DDR2/3/4 SDRAM, this register should be set to the same value as DRAMTMG5.t_cksre. When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.   This is only present for designs supporting mDDR or LPDDR2/LPDDR3/LPDDR4 devices.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG7_T_CKPDE_Msk            (_U_(0xF) << UDDRC_DRAMTMG7_T_CKPDE_Pos)             /**< (UDDRC_DRAMTMG7) This is the time after Power Down Entry that CK is maintained as a valid clock. Specifies the clock disable delay after PDE.       Recommended settings:     - mDDR: 0     - LPDDR2: 2     - LPDDR3: 2     - LPDDR4: tCKELCK When using DDR2/3/4 SDRAM, this register should be set to the same value as DRAMTMG5.t_cksre. When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.   This is only present for designs supporting mDDR or LPDDR2/LPDDR3/LPDDR4 devices.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG7_T_CKPDE(value)         (UDDRC_DRAMTMG7_T_CKPDE_Msk & ((value) << UDDRC_DRAMTMG7_T_CKPDE_Pos))
#define UDDRC_DRAMTMG7_Msk                    _U_(0x00000F0F)                                      /**< (UDDRC_DRAMTMG7) Register Mask  */


/* -------- UDDRC_DRAMTMG8 : (UDDRC Offset: 0x120) (R/W 32) SDRAM Timing Register 8 -------- */
#define UDDRC_DRAMTMG8_RESETVALUE             _U_(0x4405)                                          /**<  (UDDRC_DRAMTMG8) SDRAM Timing Register 8  Reset Value */

#define UDDRC_DRAMTMG8_T_XS_X32_Pos           _U_(0)                                               /**< (UDDRC_DRAMTMG8) tXS: Exit Self Refresh to commands not requiring a locked DLL. When the controller is operating in 1:2 frequency ratio mode, program this to the above value divided by 2 and round up to next integer value. Note: Used only for DDR2, DDR3 and DDR4 SDRAMs. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG8_T_XS_X32_Msk           (_U_(0x7F) << UDDRC_DRAMTMG8_T_XS_X32_Pos)           /**< (UDDRC_DRAMTMG8) tXS: Exit Self Refresh to commands not requiring a locked DLL. When the controller is operating in 1:2 frequency ratio mode, program this to the above value divided by 2 and round up to next integer value. Note: Used only for DDR2, DDR3 and DDR4 SDRAMs. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG8_T_XS_X32(value)        (UDDRC_DRAMTMG8_T_XS_X32_Msk & ((value) << UDDRC_DRAMTMG8_T_XS_X32_Pos))
#define UDDRC_DRAMTMG8_T_XS_DLL_X32_Pos       _U_(8)                                               /**< (UDDRC_DRAMTMG8) tXSDLL: Exit Self Refresh to commands requiring a locked DLL. When the controller is operating in 1:2 frequency ratio mode, program this to the above value divided by 2 and round up to next integer value. Note: Used only for DDR2, DDR3 and DDR4 SDRAMs. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG8_T_XS_DLL_X32_Msk       (_U_(0x7F) << UDDRC_DRAMTMG8_T_XS_DLL_X32_Pos)       /**< (UDDRC_DRAMTMG8) tXSDLL: Exit Self Refresh to commands requiring a locked DLL. When the controller is operating in 1:2 frequency ratio mode, program this to the above value divided by 2 and round up to next integer value. Note: Used only for DDR2, DDR3 and DDR4 SDRAMs. Unit: Multiples of 32 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG8_T_XS_DLL_X32(value)    (UDDRC_DRAMTMG8_T_XS_DLL_X32_Msk & ((value) << UDDRC_DRAMTMG8_T_XS_DLL_X32_Pos))
#define UDDRC_DRAMTMG8_Msk                    _U_(0x00007F7F)                                      /**< (UDDRC_DRAMTMG8) Register Mask  */


/* -------- UDDRC_DRAMTMG14 : (UDDRC Offset: 0x138) (R/W 32) SDRAM Timing Register 14 -------- */
#define UDDRC_DRAMTMG14_RESETVALUE            _U_(0xA0)                                            /**<  (UDDRC_DRAMTMG14) SDRAM Timing Register 14  Reset Value */

#define UDDRC_DRAMTMG14_T_XSR_Pos             _U_(0)                                               /**< (UDDRC_DRAMTMG14) tXSR: Exit Self Refresh to any command. When the controller is operating in 1:2 frequency ratio mode, program this to the above value divided by 2 and round up to next integer value.   The value 0xfff is illegal for this register field.  Note: Used only for mDDR/LPDDR2/LPDDR3/LPDDR4 mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG14_T_XSR_Msk             (_U_(0xFFF) << UDDRC_DRAMTMG14_T_XSR_Pos)            /**< (UDDRC_DRAMTMG14) tXSR: Exit Self Refresh to any command. When the controller is operating in 1:2 frequency ratio mode, program this to the above value divided by 2 and round up to next integer value.   The value 0xfff is illegal for this register field.  Note: Used only for mDDR/LPDDR2/LPDDR3/LPDDR4 mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG14_T_XSR(value)          (UDDRC_DRAMTMG14_T_XSR_Msk & ((value) << UDDRC_DRAMTMG14_T_XSR_Pos))
#define UDDRC_DRAMTMG14_Msk                   _U_(0x00000FFF)                                      /**< (UDDRC_DRAMTMG14) Register Mask  */


/* -------- UDDRC_DRAMTMG15 : (UDDRC Offset: 0x13C) (R/W 32) SDRAM Timing Register 15 -------- */
#define UDDRC_DRAMTMG15_RESETVALUE            _U_(0x00)                                            /**<  (UDDRC_DRAMTMG15) SDRAM Timing Register 15  Reset Value */

#define UDDRC_DRAMTMG15_T_STAB_X32_Pos        _U_(0)                                               /**< (UDDRC_DRAMTMG15) tSTAB: Stabilization time. It is required in the following two cases for DDR3/DDR4 RDIMM :     - when exiting power saving mode, if the clock was stopped, after re-enabling it the clock must be stable for a time specified by tSTAB    - in the case of input clock frequency change (DDR4)    - after issuing control words that refers to clock timing   (Specification: 6us for DDR3, 5us for DDR4)  When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.  Unit: Multiples of 32 DFI clock cycles.  Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG15_T_STAB_X32_Msk        (_U_(0xFF) << UDDRC_DRAMTMG15_T_STAB_X32_Pos)        /**< (UDDRC_DRAMTMG15) tSTAB: Stabilization time. It is required in the following two cases for DDR3/DDR4 RDIMM :     - when exiting power saving mode, if the clock was stopped, after re-enabling it the clock must be stable for a time specified by tSTAB    - in the case of input clock frequency change (DDR4)    - after issuing control words that refers to clock timing   (Specification: 6us for DDR3, 5us for DDR4)  When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer.  Unit: Multiples of 32 DFI clock cycles.  Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG15_T_STAB_X32(value)     (UDDRC_DRAMTMG15_T_STAB_X32_Msk & ((value) << UDDRC_DRAMTMG15_T_STAB_X32_Pos))
#define UDDRC_DRAMTMG15_EN_DFI_LP_T_STAB_Pos  _U_(31)                                              /**< (UDDRC_DRAMTMG15) - 1 - Enable using tSTAB when exiting DFI LP. Needs to be set when the PHY is stopping the clock during DFI LP to save maximum power.   - 0 - Disable using tSTAB when exiting DFI LP Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_DRAMTMG15_EN_DFI_LP_T_STAB_Msk  (_U_(0x1) << UDDRC_DRAMTMG15_EN_DFI_LP_T_STAB_Pos)   /**< (UDDRC_DRAMTMG15) - 1 - Enable using tSTAB when exiting DFI LP. Needs to be set when the PHY is stopping the clock during DFI LP to save maximum power.   - 0 - Disable using tSTAB when exiting DFI LP Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_DRAMTMG15_EN_DFI_LP_T_STAB(value) (UDDRC_DRAMTMG15_EN_DFI_LP_T_STAB_Msk & ((value) << UDDRC_DRAMTMG15_EN_DFI_LP_T_STAB_Pos))
#define UDDRC_DRAMTMG15_Msk                   _U_(0x800000FF)                                      /**< (UDDRC_DRAMTMG15) Register Mask  */


/* -------- UDDRC_ZQCTL0 : (UDDRC Offset: 0x180) (R/W 32) ZQ Control Register 0 -------- */
#define UDDRC_ZQCTL0_RESETVALUE               _U_(0x2000040)                                       /**<  (UDDRC_ZQCTL0) ZQ Control Register 0  Reset Value */

#define UDDRC_ZQCTL0_T_ZQ_SHORT_NOP_Pos       _U_(0)                                               /**< (UDDRC_ZQCTL0) tZQCS for DDR3/DD4/LPDDR2/LPDDR3, tZQLAT for LPDDR4: Number of DFI clock cycles of NOP required after a ZQCS (ZQ calibration short)/MPC(ZQ Latch) command is issued to SDRAM. When the controller is operating in 1:2 frequency ratio mode, program this to tZQCS/2 and round it up to the next integer value. This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices. Unit: DFI clock cycles. Programming Mode: Static Position */
#define UDDRC_ZQCTL0_T_ZQ_SHORT_NOP_Msk       (_U_(0x3FF) << UDDRC_ZQCTL0_T_ZQ_SHORT_NOP_Pos)      /**< (UDDRC_ZQCTL0) tZQCS for DDR3/DD4/LPDDR2/LPDDR3, tZQLAT for LPDDR4: Number of DFI clock cycles of NOP required after a ZQCS (ZQ calibration short)/MPC(ZQ Latch) command is issued to SDRAM. When the controller is operating in 1:2 frequency ratio mode, program this to tZQCS/2 and round it up to the next integer value. This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices. Unit: DFI clock cycles. Programming Mode: Static Mask */
#define UDDRC_ZQCTL0_T_ZQ_SHORT_NOP(value)    (UDDRC_ZQCTL0_T_ZQ_SHORT_NOP_Msk & ((value) << UDDRC_ZQCTL0_T_ZQ_SHORT_NOP_Pos))
#define UDDRC_ZQCTL0_T_ZQ_LONG_NOP_Pos        _U_(16)                                              /**< (UDDRC_ZQCTL0) tZQoper for DDR3/DDR4, tZQCL for LPDDR2/LPDDR3, tZQCAL for LPDDR4: Number of DFI clock cycles of NOP required after a ZQCL (ZQ calibration long)/MPC(ZQ Start) command is issued to SDRAM. When the controller is operating in 1:2 frequency ratio mode: DDR3/DDR4: program this to tZQoper/2 and round it up to the next integer value. LPDDR2/LPDDR3: program this to tZQCL/2 and round it up to the next integer value. LPDDR4: program this to tZQCAL/2 and round it up to the next integer value. This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices. Unit: DFI clock cycles. Programming Mode: Static Position */
#define UDDRC_ZQCTL0_T_ZQ_LONG_NOP_Msk        (_U_(0x7FF) << UDDRC_ZQCTL0_T_ZQ_LONG_NOP_Pos)       /**< (UDDRC_ZQCTL0) tZQoper for DDR3/DDR4, tZQCL for LPDDR2/LPDDR3, tZQCAL for LPDDR4: Number of DFI clock cycles of NOP required after a ZQCL (ZQ calibration long)/MPC(ZQ Start) command is issued to SDRAM. When the controller is operating in 1:2 frequency ratio mode: DDR3/DDR4: program this to tZQoper/2 and round it up to the next integer value. LPDDR2/LPDDR3: program this to tZQCL/2 and round it up to the next integer value. LPDDR4: program this to tZQCAL/2 and round it up to the next integer value. This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices. Unit: DFI clock cycles. Programming Mode: Static Mask */
#define UDDRC_ZQCTL0_T_ZQ_LONG_NOP(value)     (UDDRC_ZQCTL0_T_ZQ_LONG_NOP_Msk & ((value) << UDDRC_ZQCTL0_T_ZQ_LONG_NOP_Pos))
#define UDDRC_ZQCTL0_ZQ_RESISTOR_SHARED_Pos   _U_(29)                                              /**< (UDDRC_ZQCTL0) - 1 - Denotes that ZQ resistor is shared between ranks. Means ZQinit/ZQCL/ZQCS/MPC(ZQ calibration) commands are sent to one rank at a time with tZQinit/tZQCL/tZQCS/tZQCAL/tZQLAT timing met between commands so that commands to different ranks do not overlap.   - 0 - ZQ resistor is not shared. This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices. Programming Mode: Static Position */
#define UDDRC_ZQCTL0_ZQ_RESISTOR_SHARED_Msk   (_U_(0x1) << UDDRC_ZQCTL0_ZQ_RESISTOR_SHARED_Pos)    /**< (UDDRC_ZQCTL0) - 1 - Denotes that ZQ resistor is shared between ranks. Means ZQinit/ZQCL/ZQCS/MPC(ZQ calibration) commands are sent to one rank at a time with tZQinit/tZQCL/tZQCS/tZQCAL/tZQLAT timing met between commands so that commands to different ranks do not overlap.   - 0 - ZQ resistor is not shared. This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices. Programming Mode: Static Mask */
#define UDDRC_ZQCTL0_ZQ_RESISTOR_SHARED(value) (UDDRC_ZQCTL0_ZQ_RESISTOR_SHARED_Msk & ((value) << UDDRC_ZQCTL0_ZQ_RESISTOR_SHARED_Pos))
#define UDDRC_ZQCTL0_DIS_SRX_ZQCL_Pos         _U_(30)                                              /**< (UDDRC_ZQCTL0) - 1 - Disable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit. Only applicable when run in DDR3 or DDR4 or LPDDR2 or LPDDR3 or LPDDR4 mode.  - 0 - Enable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit. Only applicable when run in DDR3 or DDR4 or LPDDR2 or LPDDR3 or LPDDR4 mode. This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices. Programming Mode: Quasi-dynamic Group 2, Group 4 Position */
#define UDDRC_ZQCTL0_DIS_SRX_ZQCL_Msk         (_U_(0x1) << UDDRC_ZQCTL0_DIS_SRX_ZQCL_Pos)          /**< (UDDRC_ZQCTL0) - 1 - Disable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit. Only applicable when run in DDR3 or DDR4 or LPDDR2 or LPDDR3 or LPDDR4 mode.  - 0 - Enable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit. Only applicable when run in DDR3 or DDR4 or LPDDR2 or LPDDR3 or LPDDR4 mode. This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices. Programming Mode: Quasi-dynamic Group 2, Group 4 Mask */
#define UDDRC_ZQCTL0_DIS_SRX_ZQCL(value)      (UDDRC_ZQCTL0_DIS_SRX_ZQCL_Msk & ((value) << UDDRC_ZQCTL0_DIS_SRX_ZQCL_Pos))
#define UDDRC_ZQCTL0_DIS_AUTO_ZQ_Pos          _U_(31)                                              /**< (UDDRC_ZQCTL0) - 1 - Disable uMCTL2 generation of ZQCS/MPC(ZQ calibration) command.  Register DBGCMD.zq_calib_short can be used instead to issue ZQ calibration request from APB module.  - 0 - Internally generate ZQCS/MPC(ZQ calibration) commands based on ZQCTL1.t_zq_short_interval_x1024. This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices. Programming Mode: Dynamic Position */
#define UDDRC_ZQCTL0_DIS_AUTO_ZQ_Msk          (_U_(0x1) << UDDRC_ZQCTL0_DIS_AUTO_ZQ_Pos)           /**< (UDDRC_ZQCTL0) - 1 - Disable uMCTL2 generation of ZQCS/MPC(ZQ calibration) command.  Register DBGCMD.zq_calib_short can be used instead to issue ZQ calibration request from APB module.  - 0 - Internally generate ZQCS/MPC(ZQ calibration) commands based on ZQCTL1.t_zq_short_interval_x1024. This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices. Programming Mode: Dynamic Mask */
#define UDDRC_ZQCTL0_DIS_AUTO_ZQ(value)       (UDDRC_ZQCTL0_DIS_AUTO_ZQ_Msk & ((value) << UDDRC_ZQCTL0_DIS_AUTO_ZQ_Pos))
#define UDDRC_ZQCTL0_Msk                      _U_(0xE7FF03FF)                                      /**< (UDDRC_ZQCTL0) Register Mask  */


/* -------- UDDRC_ZQCTL1 : (UDDRC Offset: 0x184) (R/W 32) ZQ Control Register 1 -------- */
#define UDDRC_ZQCTL1_RESETVALUE               _U_(0x2000100)                                       /**<  (UDDRC_ZQCTL1) ZQ Control Register 1  Reset Value */

#define UDDRC_ZQCTL1_T_ZQ_SHORT_INTERVAL_X1024_Pos _U_(0)                                               /**< (UDDRC_ZQCTL1) Average interval to wait between automatically issuing ZQCS (ZQ calibration short)/MPC(ZQ calibration) commands to DDR3/DDR4/LPDDR2/LPDDR3/LPDDR4 devices. Meaningless, if ZQCTL0.dis_auto_zq=1. This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices. Unit: Multiples of 1024 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Position */
#define UDDRC_ZQCTL1_T_ZQ_SHORT_INTERVAL_X1024_Msk (_U_(0xFFFFF) << UDDRC_ZQCTL1_T_ZQ_SHORT_INTERVAL_X1024_Pos) /**< (UDDRC_ZQCTL1) Average interval to wait between automatically issuing ZQCS (ZQ calibration short)/MPC(ZQ calibration) commands to DDR3/DDR4/LPDDR2/LPDDR3/LPDDR4 devices. Meaningless, if ZQCTL0.dis_auto_zq=1. This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4 devices. Unit: Multiples of 1024 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Mask */
#define UDDRC_ZQCTL1_T_ZQ_SHORT_INTERVAL_X1024(value) (UDDRC_ZQCTL1_T_ZQ_SHORT_INTERVAL_X1024_Msk & ((value) << UDDRC_ZQCTL1_T_ZQ_SHORT_INTERVAL_X1024_Pos))
#define UDDRC_ZQCTL1_T_ZQ_RESET_NOP_Pos       _U_(20)                                              /**< (UDDRC_ZQCTL1) tZQReset: Number of DFI clock cycles of NOP required after a ZQReset (ZQ calibration Reset) command is issued to SDRAM. When the controller is operating in 1:2 frequency ratio mode, program this to tZQReset/2 and round it up to the next integer value. This is only present for designs supporting LPDDR2/LPDDR3/LPDDR4 devices. Unit: DFI clock cycles. Programming Mode: Static Position */
#define UDDRC_ZQCTL1_T_ZQ_RESET_NOP_Msk       (_U_(0x3FF) << UDDRC_ZQCTL1_T_ZQ_RESET_NOP_Pos)      /**< (UDDRC_ZQCTL1) tZQReset: Number of DFI clock cycles of NOP required after a ZQReset (ZQ calibration Reset) command is issued to SDRAM. When the controller is operating in 1:2 frequency ratio mode, program this to tZQReset/2 and round it up to the next integer value. This is only present for designs supporting LPDDR2/LPDDR3/LPDDR4 devices. Unit: DFI clock cycles. Programming Mode: Static Mask */
#define UDDRC_ZQCTL1_T_ZQ_RESET_NOP(value)    (UDDRC_ZQCTL1_T_ZQ_RESET_NOP_Msk & ((value) << UDDRC_ZQCTL1_T_ZQ_RESET_NOP_Pos))
#define UDDRC_ZQCTL1_Msk                      _U_(0x3FFFFFFF)                                      /**< (UDDRC_ZQCTL1) Register Mask  */


/* -------- UDDRC_ZQCTL2 : (UDDRC Offset: 0x188) (R/W 32) ZQ Control Register 2 -------- */
#define UDDRC_ZQCTL2_RESETVALUE               _U_(0x00)                                            /**<  (UDDRC_ZQCTL2) ZQ Control Register 2  Reset Value */

#define UDDRC_ZQCTL2_ZQ_RESET_Pos             _U_(0)                                               /**< (UDDRC_ZQCTL2) Setting this register bit to 1 triggers a ZQ Reset operation. When the ZQ Reset operation is complete, the uMCTL2 automatically clears this bit. It is recommended NOT to set this register bit if in Init, in Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) or Deep power-down operating modes. For Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) it will be scheduled after SR(except LPDDR4) or SPRD(LPDDR4) has been exited. For Deep power down, it will not be scheduled, although ZQSTAT.zq_reset_busy will be de-asserted. This is only present for designs supporting LPDDR2/LPDDR3/LPDDR4 devices. Programming Mode: Dynamic Position */
#define UDDRC_ZQCTL2_ZQ_RESET_Msk             (_U_(0x1) << UDDRC_ZQCTL2_ZQ_RESET_Pos)              /**< (UDDRC_ZQCTL2) Setting this register bit to 1 triggers a ZQ Reset operation. When the ZQ Reset operation is complete, the uMCTL2 automatically clears this bit. It is recommended NOT to set this register bit if in Init, in Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) or Deep power-down operating modes. For Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) it will be scheduled after SR(except LPDDR4) or SPRD(LPDDR4) has been exited. For Deep power down, it will not be scheduled, although ZQSTAT.zq_reset_busy will be de-asserted. This is only present for designs supporting LPDDR2/LPDDR3/LPDDR4 devices. Programming Mode: Dynamic Mask */
#define UDDRC_ZQCTL2_ZQ_RESET(value)          (UDDRC_ZQCTL2_ZQ_RESET_Msk & ((value) << UDDRC_ZQCTL2_ZQ_RESET_Pos))
#define UDDRC_ZQCTL2_Msk                      _U_(0x00000001)                                      /**< (UDDRC_ZQCTL2) Register Mask  */


/* -------- UDDRC_ZQSTAT : (UDDRC Offset: 0x18C) ( R/ 32) ZQ Status Register -------- */
#define UDDRC_ZQSTAT_RESETVALUE               _U_(0x00)                                            /**<  (UDDRC_ZQSTAT) ZQ Status Register  Reset Value */

#define UDDRC_ZQSTAT_ZQ_RESET_BUSY_Pos        _U_(0)                                               /**< (UDDRC_ZQSTAT) SoC core may initiate a ZQ Reset operation only if this signal is low. This signal goes high in the clock after the uMCTL2 accepts the ZQ Reset request. It goes low when the ZQ Reset command is issued to the SDRAM and the associated NOP period is over. It is recommended not to perform ZQ Reset commands when this signal is high.  - 0 - Indicates that the SoC core can initiate a ZQ Reset operation  - 1 - Indicates that ZQ Reset operation is in progress Programming Mode: Dynamic Position */
#define UDDRC_ZQSTAT_ZQ_RESET_BUSY_Msk        (_U_(0x1) << UDDRC_ZQSTAT_ZQ_RESET_BUSY_Pos)         /**< (UDDRC_ZQSTAT) SoC core may initiate a ZQ Reset operation only if this signal is low. This signal goes high in the clock after the uMCTL2 accepts the ZQ Reset request. It goes low when the ZQ Reset command is issued to the SDRAM and the associated NOP period is over. It is recommended not to perform ZQ Reset commands when this signal is high.  - 0 - Indicates that the SoC core can initiate a ZQ Reset operation  - 1 - Indicates that ZQ Reset operation is in progress Programming Mode: Dynamic Mask */
#define UDDRC_ZQSTAT_ZQ_RESET_BUSY(value)     (UDDRC_ZQSTAT_ZQ_RESET_BUSY_Msk & ((value) << UDDRC_ZQSTAT_ZQ_RESET_BUSY_Pos))
#define UDDRC_ZQSTAT_Msk                      _U_(0x00000001)                                      /**< (UDDRC_ZQSTAT) Register Mask  */


/* -------- UDDRC_DFITMG0 : (UDDRC Offset: 0x190) (R/W 32) DFI Timing Register 0 -------- */
#define UDDRC_DFITMG0_RESETVALUE              _U_(0x7020002)                                       /**<  (UDDRC_DFITMG0) DFI Timing Register 0  Reset Value */

#define UDDRC_DFITMG0_DFI_TPHY_WRLAT_Pos      _U_(0)                                               /**< (UDDRC_DFITMG0) Write latency Number of clocks from the write command to write data enable (dfi_wrdata_en).  This corresponds to the DFI timing parameter tphy_wrlat. Refer to PHY specification for correct value.Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of tphy_wrlat. This is to compensate for the extra cycle(s) of latency through the RDIMM/LRDIMM. For LPDDR4, dfi_tphy_wrlat>60 is not supported. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_wrdata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 1, Group 4 Position */
#define UDDRC_DFITMG0_DFI_TPHY_WRLAT_Msk      (_U_(0x3F) << UDDRC_DFITMG0_DFI_TPHY_WRLAT_Pos)      /**< (UDDRC_DFITMG0) Write latency Number of clocks from the write command to write data enable (dfi_wrdata_en).  This corresponds to the DFI timing parameter tphy_wrlat. Refer to PHY specification for correct value.Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of tphy_wrlat. This is to compensate for the extra cycle(s) of latency through the RDIMM/LRDIMM. For LPDDR4, dfi_tphy_wrlat>60 is not supported. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_wrdata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 1, Group 4 Mask */
#define UDDRC_DFITMG0_DFI_TPHY_WRLAT(value)   (UDDRC_DFITMG0_DFI_TPHY_WRLAT_Msk & ((value) << UDDRC_DFITMG0_DFI_TPHY_WRLAT_Pos))
#define UDDRC_DFITMG0_DFI_TPHY_WRDATA_Pos     _U_(8)                                               /**< (UDDRC_DFITMG0) Specifies the number of clock cycles between when dfi_wrdata_en is asserted to when the associated write data is driven on the dfi_wrdata signal.  This corresponds to the DFI timing parameter tphy_wrdata.  Refer to PHY specification for correct value. Note, max supported value is 8. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_wrdata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 4 Position */
#define UDDRC_DFITMG0_DFI_TPHY_WRDATA_Msk     (_U_(0x3F) << UDDRC_DFITMG0_DFI_TPHY_WRDATA_Pos)     /**< (UDDRC_DFITMG0) Specifies the number of clock cycles between when dfi_wrdata_en is asserted to when the associated write data is driven on the dfi_wrdata signal.  This corresponds to the DFI timing parameter tphy_wrdata.  Refer to PHY specification for correct value. Note, max supported value is 8. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_wrdata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 4 Mask */
#define UDDRC_DFITMG0_DFI_TPHY_WRDATA(value)  (UDDRC_DFITMG0_DFI_TPHY_WRDATA_Msk & ((value) << UDDRC_DFITMG0_DFI_TPHY_WRDATA_Pos))
#define UDDRC_DFITMG0_DFI_WRDATA_USE_DFI_PHY_CLK_Pos _U_(15)                                              /**< (UDDRC_DFITMG0) Defines whether dfi_wrdata_en/dfi_wrdata/dfi_wrdata_mask is generated using HDR (DFI clock) or SDR (DFI PHY clock) values Selects whether value in DFITMG0.dfi_tphy_wrlat  is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles Selects whether value in DFITMG0.dfi_tphy_wrdata is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles  - 0 in terms of HDR (DFI clock) cycles  - 1 in terms of SDR (DFI PHY clock) cycles Refer to PHY specification for correct value. If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:  - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field should be set to 0  - Else, it must be set to 1  Programming Mode: Static Position */
#define UDDRC_DFITMG0_DFI_WRDATA_USE_DFI_PHY_CLK_Msk (_U_(0x1) << UDDRC_DFITMG0_DFI_WRDATA_USE_DFI_PHY_CLK_Pos) /**< (UDDRC_DFITMG0) Defines whether dfi_wrdata_en/dfi_wrdata/dfi_wrdata_mask is generated using HDR (DFI clock) or SDR (DFI PHY clock) values Selects whether value in DFITMG0.dfi_tphy_wrlat  is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles Selects whether value in DFITMG0.dfi_tphy_wrdata is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles  - 0 in terms of HDR (DFI clock) cycles  - 1 in terms of SDR (DFI PHY clock) cycles Refer to PHY specification for correct value. If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:  - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field should be set to 0  - Else, it must be set to 1  Programming Mode: Static Mask */
#define UDDRC_DFITMG0_DFI_WRDATA_USE_DFI_PHY_CLK(value) (UDDRC_DFITMG0_DFI_WRDATA_USE_DFI_PHY_CLK_Msk & ((value) << UDDRC_DFITMG0_DFI_WRDATA_USE_DFI_PHY_CLK_Pos))
#define UDDRC_DFITMG0_DFI_T_RDDATA_EN_Pos     _U_(16)                                              /**< (UDDRC_DFITMG0) Time from the assertion of a read command on the DFI interface to the assertion of the dfi_rddata_en signal. Refer to PHY specification for correct value. This corresponds to the DFI parameter trddata_en. Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of trddata_en. This is to compensate for the extra cycle(s) of latency through the RDIMM/LRDIMM. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_rddata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 1, Group 4 Position */
#define UDDRC_DFITMG0_DFI_T_RDDATA_EN_Msk     (_U_(0x7F) << UDDRC_DFITMG0_DFI_T_RDDATA_EN_Pos)     /**< (UDDRC_DFITMG0) Time from the assertion of a read command on the DFI interface to the assertion of the dfi_rddata_en signal. Refer to PHY specification for correct value. This corresponds to the DFI parameter trddata_en. Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of trddata_en. This is to compensate for the extra cycle(s) of latency through the RDIMM/LRDIMM. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_rddata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 1, Group 4 Mask */
#define UDDRC_DFITMG0_DFI_T_RDDATA_EN(value)  (UDDRC_DFITMG0_DFI_T_RDDATA_EN_Msk & ((value) << UDDRC_DFITMG0_DFI_T_RDDATA_EN_Pos))
#define UDDRC_DFITMG0_DFI_RDDATA_USE_DFI_PHY_CLK_Pos _U_(23)                                              /**< (UDDRC_DFITMG0) Defines whether dfi_rddata_en/dfi_rddata/dfi_rddata_valid is generated using HDR (DFI clock) or SDR (DFI PHY clock) values.   Selects whether value in DFITMG0.dfi_t_rddata_en is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles:  - 0 in terms of HDR (DFI clock) cycles  - 1 in terms of SDR (DFI PHY clock) cycles Refer to PHY specification for correct value. If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:  - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field should be set to 0  - Else, it must be set to 1  Programming Mode: Static Position */
#define UDDRC_DFITMG0_DFI_RDDATA_USE_DFI_PHY_CLK_Msk (_U_(0x1) << UDDRC_DFITMG0_DFI_RDDATA_USE_DFI_PHY_CLK_Pos) /**< (UDDRC_DFITMG0) Defines whether dfi_rddata_en/dfi_rddata/dfi_rddata_valid is generated using HDR (DFI clock) or SDR (DFI PHY clock) values.   Selects whether value in DFITMG0.dfi_t_rddata_en is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles:  - 0 in terms of HDR (DFI clock) cycles  - 1 in terms of SDR (DFI PHY clock) cycles Refer to PHY specification for correct value. If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:  - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field should be set to 0  - Else, it must be set to 1  Programming Mode: Static Mask */
#define UDDRC_DFITMG0_DFI_RDDATA_USE_DFI_PHY_CLK(value) (UDDRC_DFITMG0_DFI_RDDATA_USE_DFI_PHY_CLK_Msk & ((value) << UDDRC_DFITMG0_DFI_RDDATA_USE_DFI_PHY_CLK_Pos))
#define UDDRC_DFITMG0_DFI_T_CTRL_DELAY_Pos    _U_(24)                                              /**< (UDDRC_DFITMG0) Specifies the number of DFI clock cycles after an assertion or de-assertion of the DFI control signals that the control signals at the PHY-DRAM interface reflect the assertion or de-assertion. If the DFI clock and the memory clock are not phase-aligned, this timing parameter should be rounded up to the next integer value. Note that if using RDIMM/LRDIMM, it is necessary to increment this parameter by RDIMM's/LRDIMM's extra cycle of latency in terms of DFI clock. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4 Position */
#define UDDRC_DFITMG0_DFI_T_CTRL_DELAY_Msk    (_U_(0x1F) << UDDRC_DFITMG0_DFI_T_CTRL_DELAY_Pos)    /**< (UDDRC_DFITMG0) Specifies the number of DFI clock cycles after an assertion or de-assertion of the DFI control signals that the control signals at the PHY-DRAM interface reflect the assertion or de-assertion. If the DFI clock and the memory clock are not phase-aligned, this timing parameter should be rounded up to the next integer value. Note that if using RDIMM/LRDIMM, it is necessary to increment this parameter by RDIMM's/LRDIMM's extra cycle of latency in terms of DFI clock. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4 Mask */
#define UDDRC_DFITMG0_DFI_T_CTRL_DELAY(value) (UDDRC_DFITMG0_DFI_T_CTRL_DELAY_Msk & ((value) << UDDRC_DFITMG0_DFI_T_CTRL_DELAY_Pos))
#define UDDRC_DFITMG0_Msk                     _U_(0x1FFFBF3F)                                      /**< (UDDRC_DFITMG0) Register Mask  */


/* -------- UDDRC_DFITMG1 : (UDDRC Offset: 0x194) (R/W 32) DFI Timing Register 1 -------- */
#define UDDRC_DFITMG1_RESETVALUE              _U_(0x404)                                           /**<  (UDDRC_DFITMG1) DFI Timing Register 1  Reset Value */

#define UDDRC_DFITMG1_DFI_T_DRAM_CLK_ENABLE_Pos _U_(0)                                               /**< (UDDRC_DFITMG1) Specifies the number of DFI clock cycles from the de-assertion of the dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the clock to the DRAM memory devices, at the PHY-DRAM boundary. If the DFI clock and the memory clock are not phase aligned, this timing parameter should be rounded up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4 Position */
#define UDDRC_DFITMG1_DFI_T_DRAM_CLK_ENABLE_Msk (_U_(0x1F) << UDDRC_DFITMG1_DFI_T_DRAM_CLK_ENABLE_Pos) /**< (UDDRC_DFITMG1) Specifies the number of DFI clock cycles from the de-assertion of the dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the clock to the DRAM memory devices, at the PHY-DRAM boundary. If the DFI clock and the memory clock are not phase aligned, this timing parameter should be rounded up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4 Mask */
#define UDDRC_DFITMG1_DFI_T_DRAM_CLK_ENABLE(value) (UDDRC_DFITMG1_DFI_T_DRAM_CLK_ENABLE_Msk & ((value) << UDDRC_DFITMG1_DFI_T_DRAM_CLK_ENABLE_Pos))
#define UDDRC_DFITMG1_DFI_T_DRAM_CLK_DISABLE_Pos _U_(8)                                               /**< (UDDRC_DFITMG1) Specifies the number of DFI clock cycles from the assertion of the dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory devices, at the PHY-DRAM boundary, maintains a low value. If the DFI clock and the memory clock are not phase aligned, this timing parameter should be rounded up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4 Position */
#define UDDRC_DFITMG1_DFI_T_DRAM_CLK_DISABLE_Msk (_U_(0x1F) << UDDRC_DFITMG1_DFI_T_DRAM_CLK_DISABLE_Pos) /**< (UDDRC_DFITMG1) Specifies the number of DFI clock cycles from the assertion of the dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory devices, at the PHY-DRAM boundary, maintains a low value. If the DFI clock and the memory clock are not phase aligned, this timing parameter should be rounded up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4 Mask */
#define UDDRC_DFITMG1_DFI_T_DRAM_CLK_DISABLE(value) (UDDRC_DFITMG1_DFI_T_DRAM_CLK_DISABLE_Msk & ((value) << UDDRC_DFITMG1_DFI_T_DRAM_CLK_DISABLE_Pos))
#define UDDRC_DFITMG1_DFI_T_WRDATA_DELAY_Pos  _U_(16)                                              /**< (UDDRC_DFITMG1) Specifies the number of DFI clock cycles between when the dfi_wrdata_en signal is asserted and when the corresponding write data transfer is completed on the DRAM bus.  This corresponds to the DFI timing parameter twrdata_delay.  Refer to PHY specification for correct value.  For DFI 3.0 PHY, set to twrdata_delay, a new timing parameter introduced in DFI 3.0. For DFI 2.1 PHY, set to tphy_wrdata + (delay of DFI write data to the DRAM).  Value to be programmed is in terms of DFI clocks, not PHY clocks. In FREQ_RATIO=2, divide PHY's value by 2 and round up to next integer. If using DFITMG0.dfi_wrdata_use_dfi_phy_clk=1, add 1 to the value.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4 Position */
#define UDDRC_DFITMG1_DFI_T_WRDATA_DELAY_Msk  (_U_(0x1F) << UDDRC_DFITMG1_DFI_T_WRDATA_DELAY_Pos)  /**< (UDDRC_DFITMG1) Specifies the number of DFI clock cycles between when the dfi_wrdata_en signal is asserted and when the corresponding write data transfer is completed on the DRAM bus.  This corresponds to the DFI timing parameter twrdata_delay.  Refer to PHY specification for correct value.  For DFI 3.0 PHY, set to twrdata_delay, a new timing parameter introduced in DFI 3.0. For DFI 2.1 PHY, set to tphy_wrdata + (delay of DFI write data to the DRAM).  Value to be programmed is in terms of DFI clocks, not PHY clocks. In FREQ_RATIO=2, divide PHY's value by 2 and round up to next integer. If using DFITMG0.dfi_wrdata_use_dfi_phy_clk=1, add 1 to the value.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4 Mask */
#define UDDRC_DFITMG1_DFI_T_WRDATA_DELAY(value) (UDDRC_DFITMG1_DFI_T_WRDATA_DELAY_Msk & ((value) << UDDRC_DFITMG1_DFI_T_WRDATA_DELAY_Pos))
#define UDDRC_DFITMG1_DFI_T_PARIN_LAT_Pos     _U_(24)                                              /**< (UDDRC_DFITMG1) Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is asserted and when the associated dfi_parity_in signal is driven. Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 4 Position */
#define UDDRC_DFITMG1_DFI_T_PARIN_LAT_Msk     (_U_(0x3) << UDDRC_DFITMG1_DFI_T_PARIN_LAT_Pos)      /**< (UDDRC_DFITMG1) Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is asserted and when the associated dfi_parity_in signal is driven. Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 4 Mask */
#define UDDRC_DFITMG1_DFI_T_PARIN_LAT(value)  (UDDRC_DFITMG1_DFI_T_PARIN_LAT_Msk & ((value) << UDDRC_DFITMG1_DFI_T_PARIN_LAT_Pos))
#define UDDRC_DFITMG1_Msk                     _U_(0x031F1F1F)                                      /**< (UDDRC_DFITMG1) Register Mask  */


/* -------- UDDRC_DFILPCFG0 : (UDDRC Offset: 0x198) (R/W 32) DFI Low Power Configuration Register 0 -------- */
#define UDDRC_DFILPCFG0_RESETVALUE            _U_(0x7000000)                                       /**<  (UDDRC_DFILPCFG0) DFI Low Power Configuration Register 0  Reset Value */

#define UDDRC_DFILPCFG0_DFI_LP_EN_PD_Pos      _U_(0)                                               /**< (UDDRC_DFILPCFG0) Enables DFI Low Power interface handshaking during Power Down Entry/Exit.   - 0 - Disabled    - 1 - Enabled Programming Mode: Static Position */
#define UDDRC_DFILPCFG0_DFI_LP_EN_PD_Msk      (_U_(0x1) << UDDRC_DFILPCFG0_DFI_LP_EN_PD_Pos)       /**< (UDDRC_DFILPCFG0) Enables DFI Low Power interface handshaking during Power Down Entry/Exit.   - 0 - Disabled    - 1 - Enabled Programming Mode: Static Mask */
#define UDDRC_DFILPCFG0_DFI_LP_EN_PD(value)   (UDDRC_DFILPCFG0_DFI_LP_EN_PD_Msk & ((value) << UDDRC_DFILPCFG0_DFI_LP_EN_PD_Pos))
#define UDDRC_DFILPCFG0_DFI_LP_WAKEUP_PD_Pos  _U_(4)                                               /**< (UDDRC_DFILPCFG0) Value in DFI clock cycles to drive on dfi_lp_wakeup signal when Power Down mode is entered.  Determines the DFI's tlp_wakeup time:   - 0x0 - 16 cycles   - 0x1 - 32 cycles   - 0x2 - 64 cycles   - 0x3 - 128 cycles   - 0x4 - 256 cycles   - 0x5 - 512 cycles   - 0x6 - 1024 cycles   - 0x7 - 2048 cycles   - 0x8 - 4096 cycles   - 0x9 - 8192 cycles   - 0xA - 16384 cycles   - 0xB - 32768 cycles   - 0xC - 65536 cycles   - 0xD - 131072 cycles   - 0xE - 262144 cycles   - 0xF - Unlimited Unit: DFI clock cycles. Programming Mode: Static Position */
#define UDDRC_DFILPCFG0_DFI_LP_WAKEUP_PD_Msk  (_U_(0xF) << UDDRC_DFILPCFG0_DFI_LP_WAKEUP_PD_Pos)   /**< (UDDRC_DFILPCFG0) Value in DFI clock cycles to drive on dfi_lp_wakeup signal when Power Down mode is entered.  Determines the DFI's tlp_wakeup time:   - 0x0 - 16 cycles   - 0x1 - 32 cycles   - 0x2 - 64 cycles   - 0x3 - 128 cycles   - 0x4 - 256 cycles   - 0x5 - 512 cycles   - 0x6 - 1024 cycles   - 0x7 - 2048 cycles   - 0x8 - 4096 cycles   - 0x9 - 8192 cycles   - 0xA - 16384 cycles   - 0xB - 32768 cycles   - 0xC - 65536 cycles   - 0xD - 131072 cycles   - 0xE - 262144 cycles   - 0xF - Unlimited Unit: DFI clock cycles. Programming Mode: Static Mask */
#define UDDRC_DFILPCFG0_DFI_LP_WAKEUP_PD(value) (UDDRC_DFILPCFG0_DFI_LP_WAKEUP_PD_Msk & ((value) << UDDRC_DFILPCFG0_DFI_LP_WAKEUP_PD_Pos))
#define UDDRC_DFILPCFG0_DFI_LP_EN_SR_Pos      _U_(8)                                               /**< (UDDRC_DFILPCFG0) Enables DFI Low Power interface handshaking during Self Refresh Entry/Exit.   - 0 - Disabled    - 1 - Enabled Programming Mode: Static Position */
#define UDDRC_DFILPCFG0_DFI_LP_EN_SR_Msk      (_U_(0x1) << UDDRC_DFILPCFG0_DFI_LP_EN_SR_Pos)       /**< (UDDRC_DFILPCFG0) Enables DFI Low Power interface handshaking during Self Refresh Entry/Exit.   - 0 - Disabled    - 1 - Enabled Programming Mode: Static Mask */
#define UDDRC_DFILPCFG0_DFI_LP_EN_SR(value)   (UDDRC_DFILPCFG0_DFI_LP_EN_SR_Msk & ((value) << UDDRC_DFILPCFG0_DFI_LP_EN_SR_Pos))
#define UDDRC_DFILPCFG0_DFI_LP_WAKEUP_SR_Pos  _U_(12)                                              /**< (UDDRC_DFILPCFG0) Value in DFI clock cycles to drive on dfi_lp_wakeup signal when Self Refresh mode is entered.  Determines the DFI's tlp_wakeup time:   - 0x0 - 16 cycles   - 0x1 - 32 cycles   - 0x2 - 64 cycles   - 0x3 - 128 cycles   - 0x4 - 256 cycles   - 0x5 - 512 cycles   - 0x6 - 1024 cycles   - 0x7 - 2048 cycles   - 0x8 - 4096 cycles   - 0x9 - 8192 cycles   - 0xA - 16384 cycles   - 0xB - 32768 cycles   - 0xC - 65536 cycles   - 0xD - 131072 cycles   - 0xE - 262144 cycles   - 0xF - Unlimited Unit: DFI clock cycles. Programming Mode: Static Position */
#define UDDRC_DFILPCFG0_DFI_LP_WAKEUP_SR_Msk  (_U_(0xF) << UDDRC_DFILPCFG0_DFI_LP_WAKEUP_SR_Pos)   /**< (UDDRC_DFILPCFG0) Value in DFI clock cycles to drive on dfi_lp_wakeup signal when Self Refresh mode is entered.  Determines the DFI's tlp_wakeup time:   - 0x0 - 16 cycles   - 0x1 - 32 cycles   - 0x2 - 64 cycles   - 0x3 - 128 cycles   - 0x4 - 256 cycles   - 0x5 - 512 cycles   - 0x6 - 1024 cycles   - 0x7 - 2048 cycles   - 0x8 - 4096 cycles   - 0x9 - 8192 cycles   - 0xA - 16384 cycles   - 0xB - 32768 cycles   - 0xC - 65536 cycles   - 0xD - 131072 cycles   - 0xE - 262144 cycles   - 0xF - Unlimited Unit: DFI clock cycles. Programming Mode: Static Mask */
#define UDDRC_DFILPCFG0_DFI_LP_WAKEUP_SR(value) (UDDRC_DFILPCFG0_DFI_LP_WAKEUP_SR_Msk & ((value) << UDDRC_DFILPCFG0_DFI_LP_WAKEUP_SR_Pos))
#define UDDRC_DFILPCFG0_DFI_LP_EN_DPD_Pos     _U_(16)                                              /**< (UDDRC_DFILPCFG0) Enables DFI Low Power interface handshaking during Deep Power Down Entry/Exit.   - 0 - Disabled    - 1 - Enabled  This is only present for designs supporting mDDR or LPDDR2/LPDDR3 devices. Programming Mode: Static Position */
#define UDDRC_DFILPCFG0_DFI_LP_EN_DPD_Msk     (_U_(0x1) << UDDRC_DFILPCFG0_DFI_LP_EN_DPD_Pos)      /**< (UDDRC_DFILPCFG0) Enables DFI Low Power interface handshaking during Deep Power Down Entry/Exit.   - 0 - Disabled    - 1 - Enabled  This is only present for designs supporting mDDR or LPDDR2/LPDDR3 devices. Programming Mode: Static Mask */
#define UDDRC_DFILPCFG0_DFI_LP_EN_DPD(value)  (UDDRC_DFILPCFG0_DFI_LP_EN_DPD_Msk & ((value) << UDDRC_DFILPCFG0_DFI_LP_EN_DPD_Pos))
#define UDDRC_DFILPCFG0_DFI_LP_WAKEUP_DPD_Pos _U_(20)                                              /**< (UDDRC_DFILPCFG0) Value in DFI clock cycles to drive on dfi_lp_wakeup signal when Deep Power Down mode is entered.  Determines the DFI's tlp_wakeup time:   - 0x0 - 16 cycles   - 0x1 - 32 cycles   - 0x2 - 64 cycles   - 0x3 - 128 cycles   - 0x4 - 256 cycles   - 0x5 - 512 cycles   - 0x6 - 1024 cycles   - 0x7 - 2048 cycles   - 0x8 - 4096 cycles   - 0x9 - 8192 cycles   - 0xA - 16384 cycles   - 0xB - 32768 cycles   - 0xC - 65536 cycles   - 0xD - 131072 cycles   - 0xE - 262144 cycles   - 0xF - Unlimited This is only present for designs supporting mDDR or LPDDR2/LPDDR3 devices.  Unit: DFI clock cycles. Programming Mode: Static Position */
#define UDDRC_DFILPCFG0_DFI_LP_WAKEUP_DPD_Msk (_U_(0xF) << UDDRC_DFILPCFG0_DFI_LP_WAKEUP_DPD_Pos)  /**< (UDDRC_DFILPCFG0) Value in DFI clock cycles to drive on dfi_lp_wakeup signal when Deep Power Down mode is entered.  Determines the DFI's tlp_wakeup time:   - 0x0 - 16 cycles   - 0x1 - 32 cycles   - 0x2 - 64 cycles   - 0x3 - 128 cycles   - 0x4 - 256 cycles   - 0x5 - 512 cycles   - 0x6 - 1024 cycles   - 0x7 - 2048 cycles   - 0x8 - 4096 cycles   - 0x9 - 8192 cycles   - 0xA - 16384 cycles   - 0xB - 32768 cycles   - 0xC - 65536 cycles   - 0xD - 131072 cycles   - 0xE - 262144 cycles   - 0xF - Unlimited This is only present for designs supporting mDDR or LPDDR2/LPDDR3 devices.  Unit: DFI clock cycles. Programming Mode: Static Mask */
#define UDDRC_DFILPCFG0_DFI_LP_WAKEUP_DPD(value) (UDDRC_DFILPCFG0_DFI_LP_WAKEUP_DPD_Msk & ((value) << UDDRC_DFILPCFG0_DFI_LP_WAKEUP_DPD_Pos))
#define UDDRC_DFILPCFG0_DFI_TLP_RESP_Pos      _U_(24)                                              /**< (UDDRC_DFILPCFG0) Setting in DFI clock cycles for DFI's tlp_resp time.  Same value is used for both Power Down, Self Refresh, Deep Power Down and Maximum Power Saving modes.  Refer to PHY databook for recommended values Unit: DFI clock cycles. Programming Mode: Static Position */
#define UDDRC_DFILPCFG0_DFI_TLP_RESP_Msk      (_U_(0x1F) << UDDRC_DFILPCFG0_DFI_TLP_RESP_Pos)      /**< (UDDRC_DFILPCFG0) Setting in DFI clock cycles for DFI's tlp_resp time.  Same value is used for both Power Down, Self Refresh, Deep Power Down and Maximum Power Saving modes.  Refer to PHY databook for recommended values Unit: DFI clock cycles. Programming Mode: Static Mask */
#define UDDRC_DFILPCFG0_DFI_TLP_RESP(value)   (UDDRC_DFILPCFG0_DFI_TLP_RESP_Msk & ((value) << UDDRC_DFILPCFG0_DFI_TLP_RESP_Pos))
#define UDDRC_DFILPCFG0_Msk                   _U_(0x1FF1F1F1)                                      /**< (UDDRC_DFILPCFG0) Register Mask  */


/* -------- UDDRC_DFIUPD0 : (UDDRC Offset: 0x1A0) (R/W 32) DFI Update Register 0 -------- */
#define UDDRC_DFIUPD0_RESETVALUE              _U_(0x400003)                                        /**<  (UDDRC_DFIUPD0) DFI Update Register 0  Reset Value */

#define UDDRC_DFIUPD0_DFI_T_CTRLUP_MIN_Pos    _U_(0)                                               /**< (UDDRC_DFIUPD0) Specifies the minimum number of DFI clock cycles that the dfi_ctrlupd_req signal must be asserted. The uMCTL2 expects the PHY to respond within this time.  If the PHY does not respond, the uMCTL2 will de-assert dfi_ctrlupd_req after dfi_t_ctrlup_min + 2 cycles.  Lowest value to assign to this variable is 0x3. Unit: DFI clock cycles. Programming Mode: Static Position */
#define UDDRC_DFIUPD0_DFI_T_CTRLUP_MIN_Msk    (_U_(0x3FF) << UDDRC_DFIUPD0_DFI_T_CTRLUP_MIN_Pos)   /**< (UDDRC_DFIUPD0) Specifies the minimum number of DFI clock cycles that the dfi_ctrlupd_req signal must be asserted. The uMCTL2 expects the PHY to respond within this time.  If the PHY does not respond, the uMCTL2 will de-assert dfi_ctrlupd_req after dfi_t_ctrlup_min + 2 cycles.  Lowest value to assign to this variable is 0x3. Unit: DFI clock cycles. Programming Mode: Static Mask */
#define UDDRC_DFIUPD0_DFI_T_CTRLUP_MIN(value) (UDDRC_DFIUPD0_DFI_T_CTRLUP_MIN_Msk & ((value) << UDDRC_DFIUPD0_DFI_T_CTRLUP_MIN_Pos))
#define UDDRC_DFIUPD0_DFI_T_CTRLUP_MAX_Pos    _U_(16)                                              /**< (UDDRC_DFIUPD0) Specifies the maximum number of DFI clock cycles that the dfi_ctrlupd_req signal can assert. Lowest value to assign to this variable is 0x40. Unit: DFI clock cycles. Programming Mode: Static Position */
#define UDDRC_DFIUPD0_DFI_T_CTRLUP_MAX_Msk    (_U_(0x3FF) << UDDRC_DFIUPD0_DFI_T_CTRLUP_MAX_Pos)   /**< (UDDRC_DFIUPD0) Specifies the maximum number of DFI clock cycles that the dfi_ctrlupd_req signal can assert. Lowest value to assign to this variable is 0x40. Unit: DFI clock cycles. Programming Mode: Static Mask */
#define UDDRC_DFIUPD0_DFI_T_CTRLUP_MAX(value) (UDDRC_DFIUPD0_DFI_T_CTRLUP_MAX_Msk & ((value) << UDDRC_DFIUPD0_DFI_T_CTRLUP_MAX_Pos))
#define UDDRC_DFIUPD0_CTRLUPD_PRE_SRX_Pos     _U_(29)                                              /**< (UDDRC_DFIUPD0) Selects dfi_ctrlupd_req requirements at SRX:   - 0 : send ctrlupd after SRX   - 1 : send ctrlupd before SRX   If DFIUPD0.dis_auto_ctrlupd_srx=1, this register has no impact, because no dfi_ctrlupd_req will be issued when SRX.  Programming Mode: Static Position */
#define UDDRC_DFIUPD0_CTRLUPD_PRE_SRX_Msk     (_U_(0x1) << UDDRC_DFIUPD0_CTRLUPD_PRE_SRX_Pos)      /**< (UDDRC_DFIUPD0) Selects dfi_ctrlupd_req requirements at SRX:   - 0 : send ctrlupd after SRX   - 1 : send ctrlupd before SRX   If DFIUPD0.dis_auto_ctrlupd_srx=1, this register has no impact, because no dfi_ctrlupd_req will be issued when SRX.  Programming Mode: Static Mask */
#define UDDRC_DFIUPD0_CTRLUPD_PRE_SRX(value)  (UDDRC_DFIUPD0_CTRLUPD_PRE_SRX_Msk & ((value) << UDDRC_DFIUPD0_CTRLUPD_PRE_SRX_Pos))
#define UDDRC_DFIUPD0_DIS_AUTO_CTRLUPD_SRX_Pos _U_(30)                                              /**< (UDDRC_DFIUPD0) When '1', disable the automatic dfi_ctrlupd_req generation by the uMCTL2 at self-refresh exit. When '0', uMCTL2 issues a dfi_ctrlupd_req before or after exiting self-refresh,  depending on DFIUPD0.ctrlupd_pre_srx. Programming Mode: Static Position */
#define UDDRC_DFIUPD0_DIS_AUTO_CTRLUPD_SRX_Msk (_U_(0x1) << UDDRC_DFIUPD0_DIS_AUTO_CTRLUPD_SRX_Pos) /**< (UDDRC_DFIUPD0) When '1', disable the automatic dfi_ctrlupd_req generation by the uMCTL2 at self-refresh exit. When '0', uMCTL2 issues a dfi_ctrlupd_req before or after exiting self-refresh,  depending on DFIUPD0.ctrlupd_pre_srx. Programming Mode: Static Mask */
#define UDDRC_DFIUPD0_DIS_AUTO_CTRLUPD_SRX(value) (UDDRC_DFIUPD0_DIS_AUTO_CTRLUPD_SRX_Msk & ((value) << UDDRC_DFIUPD0_DIS_AUTO_CTRLUPD_SRX_Pos))
#define UDDRC_DFIUPD0_DIS_AUTO_CTRLUPD_Pos    _U_(31)                                              /**< (UDDRC_DFIUPD0) When '1', disable the automatic dfi_ctrlupd_req generation by the uMCTL2. The core must issue the dfi_ctrlupd_req signal using register DBGCMD.ctrlupd. When '0', uMCTL2 issues dfi_ctrlupd_req periodically. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_DFIUPD0_DIS_AUTO_CTRLUPD_Msk    (_U_(0x1) << UDDRC_DFIUPD0_DIS_AUTO_CTRLUPD_Pos)     /**< (UDDRC_DFIUPD0) When '1', disable the automatic dfi_ctrlupd_req generation by the uMCTL2. The core must issue the dfi_ctrlupd_req signal using register DBGCMD.ctrlupd. When '0', uMCTL2 issues dfi_ctrlupd_req periodically. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_DFIUPD0_DIS_AUTO_CTRLUPD(value) (UDDRC_DFIUPD0_DIS_AUTO_CTRLUPD_Msk & ((value) << UDDRC_DFIUPD0_DIS_AUTO_CTRLUPD_Pos))
#define UDDRC_DFIUPD0_Msk                     _U_(0xE3FF03FF)                                      /**< (UDDRC_DFIUPD0) Register Mask  */


/* -------- UDDRC_DFIUPD1 : (UDDRC Offset: 0x1A4) (R/W 32) DFI Update Register 1 -------- */
#define UDDRC_DFIUPD1_RESETVALUE              _U_(0x10001)                                         /**<  (UDDRC_DFIUPD1) DFI Update Register 1  Reset Value */

#define UDDRC_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MAX_X1024_Pos _U_(0)                                               /**< (UDDRC_DFIUPD1) This is the maximum amount of time between uMCTL2 initiated DFI update requests. This timer resets with each update request; when the timer expires dfi_ctrlupd_req is sent and traffic is blocked until the dfi_ctrlupd_ackx is received. PHY can use this idle time to recalibrate the delay lines to the DLLs. The DFI controller update is also used to reset PHY FIFO pointers in case of data capture errors. Updates are required to maintain calibration over PVT, but frequent updates may impact performance. Minimum allowed value for this field is 1. Note: Value programmed for DFIUPD1.dfi_t_ctrlupd_interval_max_x1024 must be greater than DFIUPD1.dfi_t_ctrlupd_interval_min_x1024. Unit: Multiples of 1024 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Position */
#define UDDRC_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MAX_X1024_Msk (_U_(0xFF) << UDDRC_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MAX_X1024_Pos) /**< (UDDRC_DFIUPD1) This is the maximum amount of time between uMCTL2 initiated DFI update requests. This timer resets with each update request; when the timer expires dfi_ctrlupd_req is sent and traffic is blocked until the dfi_ctrlupd_ackx is received. PHY can use this idle time to recalibrate the delay lines to the DLLs. The DFI controller update is also used to reset PHY FIFO pointers in case of data capture errors. Updates are required to maintain calibration over PVT, but frequent updates may impact performance. Minimum allowed value for this field is 1. Note: Value programmed for DFIUPD1.dfi_t_ctrlupd_interval_max_x1024 must be greater than DFIUPD1.dfi_t_ctrlupd_interval_min_x1024. Unit: Multiples of 1024 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Mask */
#define UDDRC_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MAX_X1024(value) (UDDRC_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MAX_X1024_Msk & ((value) << UDDRC_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MAX_X1024_Pos))
#define UDDRC_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MIN_X1024_Pos _U_(16)                                              /**< (UDDRC_DFIUPD1) This is the minimum amount of time between uMCTL2 initiated DFI update requests (which is executed whenever the uMCTL2 is idle). Set this number higher to reduce the frequency of update requests, which can have a small impact on the latency of the first read request when the uMCTL2 is idle. Minimum allowed value for this field is 1. Unit: Multiples of 1024 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Position */
#define UDDRC_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MIN_X1024_Msk (_U_(0xFF) << UDDRC_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MIN_X1024_Pos) /**< (UDDRC_DFIUPD1) This is the minimum amount of time between uMCTL2 initiated DFI update requests (which is executed whenever the uMCTL2 is idle). Set this number higher to reduce the frequency of update requests, which can have a small impact on the latency of the first read request when the uMCTL2 is idle. Minimum allowed value for this field is 1. Unit: Multiples of 1024 DFI clock cycles. Please refer to "Note 1" from  "Notes on Timing Registers" at the start of "Register Descriptions" chapter for details on how to program this register field. Programming Mode: Static Mask */
#define UDDRC_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MIN_X1024(value) (UDDRC_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MIN_X1024_Msk & ((value) << UDDRC_DFIUPD1_DFI_T_CTRLUPD_INTERVAL_MIN_X1024_Pos))
#define UDDRC_DFIUPD1_Msk                     _U_(0x00FF00FF)                                      /**< (UDDRC_DFIUPD1) Register Mask  */


/* -------- UDDRC_DFIUPD2 : (UDDRC Offset: 0x1A8) (R/W 32) DFI Update Register 2 -------- */
#define UDDRC_DFIUPD2_RESETVALUE              _U_(0x80000000)                                      /**<  (UDDRC_DFIUPD2) DFI Update Register 2  Reset Value */

#define UDDRC_DFIUPD2_DFI_PHYUPD_EN_Pos       _U_(31)                                              /**< (UDDRC_DFIUPD2) Enables the support for acknowledging PHY-initiated updates:     - 0 - Disabled     - 1 - Enabled Programming Mode: Static Position */
#define UDDRC_DFIUPD2_DFI_PHYUPD_EN_Msk       (_U_(0x1) << UDDRC_DFIUPD2_DFI_PHYUPD_EN_Pos)        /**< (UDDRC_DFIUPD2) Enables the support for acknowledging PHY-initiated updates:     - 0 - Disabled     - 1 - Enabled Programming Mode: Static Mask */
#define UDDRC_DFIUPD2_DFI_PHYUPD_EN(value)    (UDDRC_DFIUPD2_DFI_PHYUPD_EN_Msk & ((value) << UDDRC_DFIUPD2_DFI_PHYUPD_EN_Pos))
#define UDDRC_DFIUPD2_Msk                     _U_(0x80000000)                                      /**< (UDDRC_DFIUPD2) Register Mask  */


/* -------- UDDRC_DFIMISC : (UDDRC Offset: 0x1B0) (R/W 32) DFI Miscellaneous Control Register -------- */
#define UDDRC_DFIMISC_RESETVALUE              _U_(0x01)                                            /**<  (UDDRC_DFIMISC) DFI Miscellaneous Control Register  Reset Value */

#define UDDRC_DFIMISC_DFI_INIT_COMPLETE_EN_Pos _U_(0)                                               /**< (UDDRC_DFIMISC) PHY initialization complete enable signal. When asserted the dfi_init_complete signal can be used to trigger SDRAM initialisation Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_DFIMISC_DFI_INIT_COMPLETE_EN_Msk (_U_(0x1) << UDDRC_DFIMISC_DFI_INIT_COMPLETE_EN_Pos) /**< (UDDRC_DFIMISC) PHY initialization complete enable signal. When asserted the dfi_init_complete signal can be used to trigger SDRAM initialisation Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_DFIMISC_DFI_INIT_COMPLETE_EN(value) (UDDRC_DFIMISC_DFI_INIT_COMPLETE_EN_Msk & ((value) << UDDRC_DFIMISC_DFI_INIT_COMPLETE_EN_Pos))
#define UDDRC_DFIMISC_CTL_IDLE_EN_Pos         _U_(4)                                               /**< (UDDRC_DFIMISC) Enables support of ctl_idle signal, which is non-DFI related pin specific to certain Synopsys PHYs. See signal description of ctl_idle signal for further details of ctl_idle functionality.   Programming Mode: Static Position */
#define UDDRC_DFIMISC_CTL_IDLE_EN_Msk         (_U_(0x1) << UDDRC_DFIMISC_CTL_IDLE_EN_Pos)          /**< (UDDRC_DFIMISC) Enables support of ctl_idle signal, which is non-DFI related pin specific to certain Synopsys PHYs. See signal description of ctl_idle signal for further details of ctl_idle functionality.   Programming Mode: Static Mask */
#define UDDRC_DFIMISC_CTL_IDLE_EN(value)      (UDDRC_DFIMISC_CTL_IDLE_EN_Msk & ((value) << UDDRC_DFIMISC_CTL_IDLE_EN_Pos))
#define UDDRC_DFIMISC_DFI_INIT_START_Pos      _U_(5)                                               /**< (UDDRC_DFIMISC) PHY init start request signal.When asserted it triggers the PHY init start request Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_DFIMISC_DFI_INIT_START_Msk      (_U_(0x1) << UDDRC_DFIMISC_DFI_INIT_START_Pos)       /**< (UDDRC_DFIMISC) PHY init start request signal.When asserted it triggers the PHY init start request Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_DFIMISC_DFI_INIT_START(value)   (UDDRC_DFIMISC_DFI_INIT_START_Msk & ((value) << UDDRC_DFIMISC_DFI_INIT_START_Pos))
#define UDDRC_DFIMISC_DFI_FREQUENCY_Pos       _U_(8)                                               /**< (UDDRC_DFIMISC) Indicates the operating frequency of the system. The number of supported frequencies and the mapping of signal values to clock frequencies are defined by the PHY. Programming Mode: Quasi-dynamic Group 1 Position */
#define UDDRC_DFIMISC_DFI_FREQUENCY_Msk       (_U_(0x1F) << UDDRC_DFIMISC_DFI_FREQUENCY_Pos)       /**< (UDDRC_DFIMISC) Indicates the operating frequency of the system. The number of supported frequencies and the mapping of signal values to clock frequencies are defined by the PHY. Programming Mode: Quasi-dynamic Group 1 Mask */
#define UDDRC_DFIMISC_DFI_FREQUENCY(value)    (UDDRC_DFIMISC_DFI_FREQUENCY_Msk & ((value) << UDDRC_DFIMISC_DFI_FREQUENCY_Pos))
#define UDDRC_DFIMISC_Msk                     _U_(0x00001F31)                                      /**< (UDDRC_DFIMISC) Register Mask  */


/* -------- UDDRC_DFISTAT : (UDDRC Offset: 0x1BC) ( R/ 32) DFI Status Register -------- */
#define UDDRC_DFISTAT_RESETVALUE              _U_(0x00)                                            /**<  (UDDRC_DFISTAT) DFI Status Register  Reset Value */

#define UDDRC_DFISTAT_DFI_INIT_COMPLETE_Pos   _U_(0)                                               /**< (UDDRC_DFISTAT) The status flag register which announces when the DFI initialization has been completed. The DFI INIT triggered by dfi_init_start signal and then the dfi_init_complete flag is polled to know when the initialization is done. Programming Mode: Dynamic Position */
#define UDDRC_DFISTAT_DFI_INIT_COMPLETE_Msk   (_U_(0x1) << UDDRC_DFISTAT_DFI_INIT_COMPLETE_Pos)    /**< (UDDRC_DFISTAT) The status flag register which announces when the DFI initialization has been completed. The DFI INIT triggered by dfi_init_start signal and then the dfi_init_complete flag is polled to know when the initialization is done. Programming Mode: Dynamic Mask */
#define UDDRC_DFISTAT_DFI_INIT_COMPLETE(value) (UDDRC_DFISTAT_DFI_INIT_COMPLETE_Msk & ((value) << UDDRC_DFISTAT_DFI_INIT_COMPLETE_Pos))
#define UDDRC_DFISTAT_DFI_LP_ACK_Pos          _U_(1)                                               /**< (UDDRC_DFISTAT) Stores the value of the dfi_lp_ack input to the controller. Programming Mode: Dynamic Position */
#define UDDRC_DFISTAT_DFI_LP_ACK_Msk          (_U_(0x1) << UDDRC_DFISTAT_DFI_LP_ACK_Pos)           /**< (UDDRC_DFISTAT) Stores the value of the dfi_lp_ack input to the controller. Programming Mode: Dynamic Mask */
#define UDDRC_DFISTAT_DFI_LP_ACK(value)       (UDDRC_DFISTAT_DFI_LP_ACK_Msk & ((value) << UDDRC_DFISTAT_DFI_LP_ACK_Pos))
#define UDDRC_DFISTAT_Msk                     _U_(0x00000003)                                      /**< (UDDRC_DFISTAT) Register Mask  */


/* -------- UDDRC_DFIPHYMSTR : (UDDRC Offset: 0x1C4) (R/W 32) DFI PHY Master -------- */
#define UDDRC_DFIPHYMSTR_RESETVALUE           _U_(0x01)                                            /**<  (UDDRC_DFIPHYMSTR) DFI PHY Master  Reset Value */

#define UDDRC_DFIPHYMSTR_DFI_PHYMSTR_EN_Pos   _U_(0)                                               /**< (UDDRC_DFIPHYMSTR) Enables the PHY Master Interface:     - 0 - Disabled     - 1 - Enabled Programming Mode: Static Position */
#define UDDRC_DFIPHYMSTR_DFI_PHYMSTR_EN_Msk   (_U_(0x1) << UDDRC_DFIPHYMSTR_DFI_PHYMSTR_EN_Pos)    /**< (UDDRC_DFIPHYMSTR) Enables the PHY Master Interface:     - 0 - Disabled     - 1 - Enabled Programming Mode: Static Mask */
#define UDDRC_DFIPHYMSTR_DFI_PHYMSTR_EN(value) (UDDRC_DFIPHYMSTR_DFI_PHYMSTR_EN_Msk & ((value) << UDDRC_DFIPHYMSTR_DFI_PHYMSTR_EN_Pos))
#define UDDRC_DFIPHYMSTR_Msk                  _U_(0x00000001)                                      /**< (UDDRC_DFIPHYMSTR) Register Mask  */


/* -------- UDDRC_ADDRMAP1 : (UDDRC Offset: 0x204) (R/W 32) Address Map Register 1 -------- */
#define UDDRC_ADDRMAP1_RESETVALUE             _U_(0x00)                                            /**<  (UDDRC_ADDRMAP1) Address Map Register 1  Reset Value */

#define UDDRC_ADDRMAP1_ADDRMAP_BANK_B0_Pos    _U_(0)                                               /**< (UDDRC_ADDRMAP1) Selects the HIF address bits used as bank address bit 0. Valid Range: 0 to 32, and 63 Internal Base: 2 The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field.    If unused, set to 63 and then bank address bit 0 is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP1_ADDRMAP_BANK_B0_Msk    (_U_(0x3F) << UDDRC_ADDRMAP1_ADDRMAP_BANK_B0_Pos)    /**< (UDDRC_ADDRMAP1) Selects the HIF address bits used as bank address bit 0. Valid Range: 0 to 32, and 63 Internal Base: 2 The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field.    If unused, set to 63 and then bank address bit 0 is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP1_ADDRMAP_BANK_B0(value) (UDDRC_ADDRMAP1_ADDRMAP_BANK_B0_Msk & ((value) << UDDRC_ADDRMAP1_ADDRMAP_BANK_B0_Pos))
#define UDDRC_ADDRMAP1_ADDRMAP_BANK_B1_Pos    _U_(8)                                               /**< (UDDRC_ADDRMAP1) Selects the HIF address bits used as bank address bit 1. Valid Range: 0 to 32, and 63 Internal Base: 3 The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field.    If unused, set to 63 and then bank address bit 1 is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP1_ADDRMAP_BANK_B1_Msk    (_U_(0x3F) << UDDRC_ADDRMAP1_ADDRMAP_BANK_B1_Pos)    /**< (UDDRC_ADDRMAP1) Selects the HIF address bits used as bank address bit 1. Valid Range: 0 to 32, and 63 Internal Base: 3 The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field.    If unused, set to 63 and then bank address bit 1 is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP1_ADDRMAP_BANK_B1(value) (UDDRC_ADDRMAP1_ADDRMAP_BANK_B1_Msk & ((value) << UDDRC_ADDRMAP1_ADDRMAP_BANK_B1_Pos))
#define UDDRC_ADDRMAP1_ADDRMAP_BANK_B2_Pos    _U_(16)                                              /**< (UDDRC_ADDRMAP1) Selects the HIF address bit used as bank address bit 2. Valid Range: 0 to 31, and 63 Internal Base: 4 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 63 and then bank address bit 2 is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP1_ADDRMAP_BANK_B2_Msk    (_U_(0x3F) << UDDRC_ADDRMAP1_ADDRMAP_BANK_B2_Pos)    /**< (UDDRC_ADDRMAP1) Selects the HIF address bit used as bank address bit 2. Valid Range: 0 to 31, and 63 Internal Base: 4 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 63 and then bank address bit 2 is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP1_ADDRMAP_BANK_B2(value) (UDDRC_ADDRMAP1_ADDRMAP_BANK_B2_Msk & ((value) << UDDRC_ADDRMAP1_ADDRMAP_BANK_B2_Pos))
#define UDDRC_ADDRMAP1_Msk                    _U_(0x003F3F3F)                                      /**< (UDDRC_ADDRMAP1) Register Mask  */


/* -------- UDDRC_ADDRMAP2 : (UDDRC Offset: 0x208) (R/W 32) Address Map Register 2 -------- */
#define UDDRC_ADDRMAP2_RESETVALUE             _U_(0x00)                                            /**<  (UDDRC_ADDRMAP2) Address Map Register 2  Reset Value */

#define UDDRC_ADDRMAP2_ADDRMAP_COL_B2_Pos     _U_(0)                                               /**< (UDDRC_ADDRMAP2) - Full bus width mode: Selects the HIF address bit used as column address bit 2.   - Half bus width mode: Selects the HIF address bit used as column address bit 3.   - Quarter bus width mode: Selects the HIF address bit used as column address bit 4. Valid Range: 0 to 7 Internal Base: 2 The selected HIF address bit is determined by adding the internal base to the value of this field.   Note, if UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=8, it is required to program this to 0 unless:   - in Half or Quarter bus width (MSTR.data_bus_width!=00) and   - PCCFG.bl_exp_mode==1 and either   - In DDR4   and ADDRMAP8.addrmap_bg_b0==0 or   - In LPDDR4 and ADDRMAP1.addrmap_bank_b0==0 If UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=16, it is required to program this to 0 unless:   - in Half or Quarter bus width (MSTR.data_bus_width!=00) and    - PCCFG.bl_exp_mode==1 and   - In DDR4 and ADDRMAP8.addrmap_bg_b0==0 Otherwise, if MEMC_BURST_LENGTH=8 and Full Bus Width (MSTR.data_bus_width==00), it is recommended to program this to 0 so that HIF[2] maps to column address bit 2.  If MEMC_BURST_LENGTH=16 and Full Bus Width (MSTR.data_bus_width==00), it is recommended to program this to 0 so that HIF[2] maps to column address bit 2.  If MEMC_BURST_LENGTH=16 and Half Bus Width (MSTR.data_bus_width==01), it is recommended to program this to 0 so that HIF[2] maps to column address bit 3.   Programming Mode: Static Position */
#define UDDRC_ADDRMAP2_ADDRMAP_COL_B2_Msk     (_U_(0xF) << UDDRC_ADDRMAP2_ADDRMAP_COL_B2_Pos)      /**< (UDDRC_ADDRMAP2) - Full bus width mode: Selects the HIF address bit used as column address bit 2.   - Half bus width mode: Selects the HIF address bit used as column address bit 3.   - Quarter bus width mode: Selects the HIF address bit used as column address bit 4. Valid Range: 0 to 7 Internal Base: 2 The selected HIF address bit is determined by adding the internal base to the value of this field.   Note, if UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=8, it is required to program this to 0 unless:   - in Half or Quarter bus width (MSTR.data_bus_width!=00) and   - PCCFG.bl_exp_mode==1 and either   - In DDR4   and ADDRMAP8.addrmap_bg_b0==0 or   - In LPDDR4 and ADDRMAP1.addrmap_bank_b0==0 If UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=16, it is required to program this to 0 unless:   - in Half or Quarter bus width (MSTR.data_bus_width!=00) and    - PCCFG.bl_exp_mode==1 and   - In DDR4 and ADDRMAP8.addrmap_bg_b0==0 Otherwise, if MEMC_BURST_LENGTH=8 and Full Bus Width (MSTR.data_bus_width==00), it is recommended to program this to 0 so that HIF[2] maps to column address bit 2.  If MEMC_BURST_LENGTH=16 and Full Bus Width (MSTR.data_bus_width==00), it is recommended to program this to 0 so that HIF[2] maps to column address bit 2.  If MEMC_BURST_LENGTH=16 and Half Bus Width (MSTR.data_bus_width==01), it is recommended to program this to 0 so that HIF[2] maps to column address bit 3.   Programming Mode: Static Mask */
#define UDDRC_ADDRMAP2_ADDRMAP_COL_B2(value)  (UDDRC_ADDRMAP2_ADDRMAP_COL_B2_Msk & ((value) << UDDRC_ADDRMAP2_ADDRMAP_COL_B2_Pos))
#define UDDRC_ADDRMAP2_ADDRMAP_COL_B3_Pos     _U_(8)                                               /**< (UDDRC_ADDRMAP2) - Full bus width mode: Selects the HIF address bit used as column address bit 3.    - Half bus width mode: Selects the HIF address bit used as column address bit 4.   - Quarter bus width mode: Selects the HIF address bit used as column address bit 5. Valid Range: 0 to 7, x. x indicate a valid value in inline ECC configuration.  Internal Base: 3 The selected HIF address bit is determined by adding the internal base to the value of this field.   Note, if UMCTL2_INCL_ARB=1, MEMC_BURST_LENGTH=16, Full bus width (MSTR.data_bus_width=00) and BL16 (MSTR.burst_rdwr=1000), it is recommended to program this to 0.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode>0), if MEMC_BURST_LENGTH is 16, number of column address is 10 and work on half bus width mode, column bit 8, column bit 7 and column bit 3 must map to the highest 3 valid HIF address bits. This register need be set to x. (x = the highest valid HIF address bit - internal base - 2)   Programming Mode: Static Position */
#define UDDRC_ADDRMAP2_ADDRMAP_COL_B3_Msk     (_U_(0x1F) << UDDRC_ADDRMAP2_ADDRMAP_COL_B3_Pos)     /**< (UDDRC_ADDRMAP2) - Full bus width mode: Selects the HIF address bit used as column address bit 3.    - Half bus width mode: Selects the HIF address bit used as column address bit 4.   - Quarter bus width mode: Selects the HIF address bit used as column address bit 5. Valid Range: 0 to 7, x. x indicate a valid value in inline ECC configuration.  Internal Base: 3 The selected HIF address bit is determined by adding the internal base to the value of this field.   Note, if UMCTL2_INCL_ARB=1, MEMC_BURST_LENGTH=16, Full bus width (MSTR.data_bus_width=00) and BL16 (MSTR.burst_rdwr=1000), it is recommended to program this to 0.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode>0), if MEMC_BURST_LENGTH is 16, number of column address is 10 and work on half bus width mode, column bit 8, column bit 7 and column bit 3 must map to the highest 3 valid HIF address bits. This register need be set to x. (x = the highest valid HIF address bit - internal base - 2)   Programming Mode: Static Mask */
#define UDDRC_ADDRMAP2_ADDRMAP_COL_B3(value)  (UDDRC_ADDRMAP2_ADDRMAP_COL_B3_Msk & ((value) << UDDRC_ADDRMAP2_ADDRMAP_COL_B3_Pos))
#define UDDRC_ADDRMAP2_ADDRMAP_COL_B4_Pos     _U_(16)                                              /**< (UDDRC_ADDRMAP2) - Full bus width mode: Selects the HIF address bit used as column address bit 4.   - Half bus width mode: Selects the HIF address bit used as column address bit 5.   - Quarter bus width mode: Selects the HIF address bit used as column address bit 6. Valid Range: 0 to 7, and 15 Internal Base: 4 The selected HIF address bit is determined by adding the internal base to the value of this field.     If unused, set to 15 and then this column address bit is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP2_ADDRMAP_COL_B4_Msk     (_U_(0xF) << UDDRC_ADDRMAP2_ADDRMAP_COL_B4_Pos)      /**< (UDDRC_ADDRMAP2) - Full bus width mode: Selects the HIF address bit used as column address bit 4.   - Half bus width mode: Selects the HIF address bit used as column address bit 5.   - Quarter bus width mode: Selects the HIF address bit used as column address bit 6. Valid Range: 0 to 7, and 15 Internal Base: 4 The selected HIF address bit is determined by adding the internal base to the value of this field.     If unused, set to 15 and then this column address bit is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP2_ADDRMAP_COL_B4(value)  (UDDRC_ADDRMAP2_ADDRMAP_COL_B4_Msk & ((value) << UDDRC_ADDRMAP2_ADDRMAP_COL_B4_Pos))
#define UDDRC_ADDRMAP2_ADDRMAP_COL_B5_Pos     _U_(24)                                              /**< (UDDRC_ADDRMAP2) - Full bus width mode: Selects the HIF address bit used as column address bit 5.   - Half bus width mode: Selects the HIF address bit used as column address bit 6.   - Quarter bus width mode: Selects the HIF address bit used as column address bit 7 . Valid Range: 0 to 7, and 15 Internal Base: 5 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 15 and then this column address bit is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP2_ADDRMAP_COL_B5_Msk     (_U_(0xF) << UDDRC_ADDRMAP2_ADDRMAP_COL_B5_Pos)      /**< (UDDRC_ADDRMAP2) - Full bus width mode: Selects the HIF address bit used as column address bit 5.   - Half bus width mode: Selects the HIF address bit used as column address bit 6.   - Quarter bus width mode: Selects the HIF address bit used as column address bit 7 . Valid Range: 0 to 7, and 15 Internal Base: 5 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 15 and then this column address bit is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP2_ADDRMAP_COL_B5(value)  (UDDRC_ADDRMAP2_ADDRMAP_COL_B5_Msk & ((value) << UDDRC_ADDRMAP2_ADDRMAP_COL_B5_Pos))
#define UDDRC_ADDRMAP2_Msk                    _U_(0x0F0F1F0F)                                      /**< (UDDRC_ADDRMAP2) Register Mask  */


/* -------- UDDRC_ADDRMAP3 : (UDDRC Offset: 0x20C) (R/W 32) Address Map Register 3 -------- */
#define UDDRC_ADDRMAP3_RESETVALUE             _U_(0x00)                                            /**<  (UDDRC_ADDRMAP3) Address Map Register 3  Reset Value */

#define UDDRC_ADDRMAP3_ADDRMAP_COL_B6_Pos     _U_(0)                                               /**< (UDDRC_ADDRMAP3) - Full bus width mode: Selects the HIF address bit used as column address bit 6.   - Half bus width mode: Selects the HIF address bit used as column address bit 7.   - Quarter bus width mode: Selects the HIF address bit used as column address bit 8. Valid Range: 0 to 7, x and 31. x indicate a valid value in inline ECC configuration. Internal Base: 6 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 31 and then this column address bit is set to 0.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode>0), if MEMC_BURST_LENGTH is 8, number of column address is 10 and work on half bus width mode, column bit 8, column bit 7 and column bit 6 must map to the highest 3 valid HIF address bits. This register need be set to x. (x = the highest valid HIF address bit - internal base - 2)   Programming Mode: Static Position */
#define UDDRC_ADDRMAP3_ADDRMAP_COL_B6_Msk     (_U_(0x1F) << UDDRC_ADDRMAP3_ADDRMAP_COL_B6_Pos)     /**< (UDDRC_ADDRMAP3) - Full bus width mode: Selects the HIF address bit used as column address bit 6.   - Half bus width mode: Selects the HIF address bit used as column address bit 7.   - Quarter bus width mode: Selects the HIF address bit used as column address bit 8. Valid Range: 0 to 7, x and 31. x indicate a valid value in inline ECC configuration. Internal Base: 6 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 31 and then this column address bit is set to 0.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode>0), if MEMC_BURST_LENGTH is 8, number of column address is 10 and work on half bus width mode, column bit 8, column bit 7 and column bit 6 must map to the highest 3 valid HIF address bits. This register need be set to x. (x = the highest valid HIF address bit - internal base - 2)   Programming Mode: Static Mask */
#define UDDRC_ADDRMAP3_ADDRMAP_COL_B6(value)  (UDDRC_ADDRMAP3_ADDRMAP_COL_B6_Msk & ((value) << UDDRC_ADDRMAP3_ADDRMAP_COL_B6_Pos))
#define UDDRC_ADDRMAP3_ADDRMAP_COL_B7_Pos     _U_(8)                                               /**< (UDDRC_ADDRMAP3) - Full bus width mode: Selects the HIF address bit used as column address bit 7.   - Half bus width mode: Selects the HIF address bit used as column address bit 8.   - Quarter bus width mode: Selects the HIF address bit used as column address bit 9. Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 7  The selected HIF address bit is determined by adding the internal base to the value of this field.     In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 7 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP3_ADDRMAP_COL_B7_Msk     (_U_(0x1F) << UDDRC_ADDRMAP3_ADDRMAP_COL_B7_Pos)     /**< (UDDRC_ADDRMAP3) - Full bus width mode: Selects the HIF address bit used as column address bit 7.   - Half bus width mode: Selects the HIF address bit used as column address bit 8.   - Quarter bus width mode: Selects the HIF address bit used as column address bit 9. Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 7  The selected HIF address bit is determined by adding the internal base to the value of this field.     In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 7 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP3_ADDRMAP_COL_B7(value)  (UDDRC_ADDRMAP3_ADDRMAP_COL_B7_Msk & ((value) << UDDRC_ADDRMAP3_ADDRMAP_COL_B7_Pos))
#define UDDRC_ADDRMAP3_ADDRMAP_COL_B8_Pos     _U_(16)                                              /**< (UDDRC_ADDRMAP3) - Full bus width mode: Selects the HIF address bit used as column address bit 8.   - Half bus width mode: Selects the HIF address bit used as column address bit 9.   - Quarter bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode). Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 8 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 8 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)    If column bit 8 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP3_ADDRMAP_COL_B8_Msk     (_U_(0x1F) << UDDRC_ADDRMAP3_ADDRMAP_COL_B8_Pos)     /**< (UDDRC_ADDRMAP3) - Full bus width mode: Selects the HIF address bit used as column address bit 8.   - Half bus width mode: Selects the HIF address bit used as column address bit 9.   - Quarter bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode). Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 8 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 8 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)    If column bit 8 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP3_ADDRMAP_COL_B8(value)  (UDDRC_ADDRMAP3_ADDRMAP_COL_B8_Msk & ((value) << UDDRC_ADDRMAP3_ADDRMAP_COL_B8_Pos))
#define UDDRC_ADDRMAP3_ADDRMAP_COL_B9_Pos     _U_(24)                                              /**< (UDDRC_ADDRMAP3) - Full bus width mode: Selects the HIF address bit used as column address bit 9.   - Half bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode).   - Quarter bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode). Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 9 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 9 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base)    If column bit 9 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)    If column bit 9 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP3_ADDRMAP_COL_B9_Msk     (_U_(0x1F) << UDDRC_ADDRMAP3_ADDRMAP_COL_B9_Pos)     /**< (UDDRC_ADDRMAP3) - Full bus width mode: Selects the HIF address bit used as column address bit 9.   - Half bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode).   - Quarter bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode). Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 9 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 9 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base)    If column bit 9 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)    If column bit 9 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP3_ADDRMAP_COL_B9(value)  (UDDRC_ADDRMAP3_ADDRMAP_COL_B9_Msk & ((value) << UDDRC_ADDRMAP3_ADDRMAP_COL_B9_Pos))
#define UDDRC_ADDRMAP3_Msk                    _U_(0x1F1F1F1F)                                      /**< (UDDRC_ADDRMAP3) Register Mask  */


/* -------- UDDRC_ADDRMAP4 : (UDDRC Offset: 0x210) (R/W 32) Address Map Register 4 -------- */
#define UDDRC_ADDRMAP4_RESETVALUE             _U_(0x00)                                            /**<  (UDDRC_ADDRMAP4) Address Map Register 4  Reset Value */

#define UDDRC_ADDRMAP4_ADDRMAP_COL_B10_Pos    _U_(0)                                               /**< (UDDRC_ADDRMAP4) - Full bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode).   - Half bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode).   - Quarter bus width mode: UNUSED. See later in this description for value you need to set to make it unused. Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 10 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 10 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base)    If column bit 10 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)    If column bit 10 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP4_ADDRMAP_COL_B10_Msk    (_U_(0x1F) << UDDRC_ADDRMAP4_ADDRMAP_COL_B10_Pos)    /**< (UDDRC_ADDRMAP4) - Full bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode).   - Half bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode).   - Quarter bus width mode: UNUSED. See later in this description for value you need to set to make it unused. Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 10 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 10 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base)    If column bit 10 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)    If column bit 10 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP4_ADDRMAP_COL_B10(value) (UDDRC_ADDRMAP4_ADDRMAP_COL_B10_Msk & ((value) << UDDRC_ADDRMAP4_ADDRMAP_COL_B10_Pos))
#define UDDRC_ADDRMAP4_ADDRMAP_COL_B11_Pos    _U_(8)                                               /**< (UDDRC_ADDRMAP4) - Full bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode).   - Half bus width mode: UNUSED. See later in this description for value you need to set to make it unused.   - Quarter bus width mode: UNUSED. See later in this description for value you need to set to make it unused. Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 11 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 11 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base)    If column bit 11 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)    If column bit 11 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP4_ADDRMAP_COL_B11_Msk    (_U_(0x1F) << UDDRC_ADDRMAP4_ADDRMAP_COL_B11_Pos)    /**< (UDDRC_ADDRMAP4) - Full bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode).   - Half bus width mode: UNUSED. See later in this description for value you need to set to make it unused.   - Quarter bus width mode: UNUSED. See later in this description for value you need to set to make it unused. Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 11 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 11 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base)    If column bit 11 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)    If column bit 11 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP4_ADDRMAP_COL_B11(value) (UDDRC_ADDRMAP4_ADDRMAP_COL_B11_Msk & ((value) << UDDRC_ADDRMAP4_ADDRMAP_COL_B11_Pos))
#define UDDRC_ADDRMAP4_Msk                    _U_(0x00001F1F)                                      /**< (UDDRC_ADDRMAP4) Register Mask  */


/* -------- UDDRC_ADDRMAP5 : (UDDRC Offset: 0x214) (R/W 32) Address Map Register 5 -------- */
#define UDDRC_ADDRMAP5_RESETVALUE             _U_(0x00)                                            /**<  (UDDRC_ADDRMAP5) Address Map Register 5  Reset Value */

#define UDDRC_ADDRMAP5_ADDRMAP_ROW_B0_Pos     _U_(0)                                               /**< (UDDRC_ADDRMAP5) Selects the HIF address bits used as row address bit 0. Valid Range: 0 to 11 Internal Base: 6 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. Programming Mode: Static Position */
#define UDDRC_ADDRMAP5_ADDRMAP_ROW_B0_Msk     (_U_(0xF) << UDDRC_ADDRMAP5_ADDRMAP_ROW_B0_Pos)      /**< (UDDRC_ADDRMAP5) Selects the HIF address bits used as row address bit 0. Valid Range: 0 to 11 Internal Base: 6 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP5_ADDRMAP_ROW_B0(value)  (UDDRC_ADDRMAP5_ADDRMAP_ROW_B0_Msk & ((value) << UDDRC_ADDRMAP5_ADDRMAP_ROW_B0_Pos))
#define UDDRC_ADDRMAP5_ADDRMAP_ROW_B1_Pos     _U_(8)                                               /**< (UDDRC_ADDRMAP5) Selects the HIF address bits used as row address bit 1. Valid Range: 0 to 11 Internal Base: 7 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. Programming Mode: Static Position */
#define UDDRC_ADDRMAP5_ADDRMAP_ROW_B1_Msk     (_U_(0xF) << UDDRC_ADDRMAP5_ADDRMAP_ROW_B1_Pos)      /**< (UDDRC_ADDRMAP5) Selects the HIF address bits used as row address bit 1. Valid Range: 0 to 11 Internal Base: 7 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP5_ADDRMAP_ROW_B1(value)  (UDDRC_ADDRMAP5_ADDRMAP_ROW_B1_Msk & ((value) << UDDRC_ADDRMAP5_ADDRMAP_ROW_B1_Pos))
#define UDDRC_ADDRMAP5_ADDRMAP_ROW_B2_10_Pos  _U_(16)                                              /**< (UDDRC_ADDRMAP5) Selects the HIF address bits used as row address bits 2 to 10. Valid Range: 0 to 11, and 15 Internal Base: 8 (for row address bit 2), 9 (for row address bit 3), 10 (for row address bit 4) etc increasing to 16 (for row address bit 10) The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. When set to 15, the values of row address bits 2 to 10 are defined by registers ADDRMAP9, ADDRMAP10, ADDRMAP11. Programming Mode: Static Position */
#define UDDRC_ADDRMAP5_ADDRMAP_ROW_B2_10_Msk  (_U_(0xF) << UDDRC_ADDRMAP5_ADDRMAP_ROW_B2_10_Pos)   /**< (UDDRC_ADDRMAP5) Selects the HIF address bits used as row address bits 2 to 10. Valid Range: 0 to 11, and 15 Internal Base: 8 (for row address bit 2), 9 (for row address bit 3), 10 (for row address bit 4) etc increasing to 16 (for row address bit 10) The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. When set to 15, the values of row address bits 2 to 10 are defined by registers ADDRMAP9, ADDRMAP10, ADDRMAP11. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP5_ADDRMAP_ROW_B2_10(value) (UDDRC_ADDRMAP5_ADDRMAP_ROW_B2_10_Msk & ((value) << UDDRC_ADDRMAP5_ADDRMAP_ROW_B2_10_Pos))
#define UDDRC_ADDRMAP5_ADDRMAP_ROW_B11_Pos    _U_(24)                                              /**< (UDDRC_ADDRMAP5) Selects the HIF address bit used as row address bit 11. Valid Range: 0 to 11, and 15 Internal Base: 17 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 15 and then row address bit 11 is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP5_ADDRMAP_ROW_B11_Msk    (_U_(0xF) << UDDRC_ADDRMAP5_ADDRMAP_ROW_B11_Pos)     /**< (UDDRC_ADDRMAP5) Selects the HIF address bit used as row address bit 11. Valid Range: 0 to 11, and 15 Internal Base: 17 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 15 and then row address bit 11 is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP5_ADDRMAP_ROW_B11(value) (UDDRC_ADDRMAP5_ADDRMAP_ROW_B11_Msk & ((value) << UDDRC_ADDRMAP5_ADDRMAP_ROW_B11_Pos))
#define UDDRC_ADDRMAP5_Msk                    _U_(0x0F0F0F0F)                                      /**< (UDDRC_ADDRMAP5) Register Mask  */


/* -------- UDDRC_ADDRMAP6 : (UDDRC Offset: 0x218) (R/W 32) Address Map Register 6 -------- */
#define UDDRC_ADDRMAP6_RESETVALUE             _U_(0x00)                                            /**<  (UDDRC_ADDRMAP6) Address Map Register 6  Reset Value */

#define UDDRC_ADDRMAP6_ADDRMAP_ROW_B12_Pos    _U_(0)                                               /**< (UDDRC_ADDRMAP6) Selects the HIF address bit used as row address bit 12. Valid Range: 0 to 11, and 15 Internal Base: 18 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 15 and then row address bit 12 is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP6_ADDRMAP_ROW_B12_Msk    (_U_(0xF) << UDDRC_ADDRMAP6_ADDRMAP_ROW_B12_Pos)     /**< (UDDRC_ADDRMAP6) Selects the HIF address bit used as row address bit 12. Valid Range: 0 to 11, and 15 Internal Base: 18 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 15 and then row address bit 12 is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP6_ADDRMAP_ROW_B12(value) (UDDRC_ADDRMAP6_ADDRMAP_ROW_B12_Msk & ((value) << UDDRC_ADDRMAP6_ADDRMAP_ROW_B12_Pos))
#define UDDRC_ADDRMAP6_ADDRMAP_ROW_B13_Pos    _U_(8)                                               /**< (UDDRC_ADDRMAP6) Selects the HIF address bit used as row address bit 13. Valid Range: 0 to 11, and 15 Internal Base: 19 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 15 and then row address bit 13 is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP6_ADDRMAP_ROW_B13_Msk    (_U_(0xF) << UDDRC_ADDRMAP6_ADDRMAP_ROW_B13_Pos)     /**< (UDDRC_ADDRMAP6) Selects the HIF address bit used as row address bit 13. Valid Range: 0 to 11, and 15 Internal Base: 19 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 15 and then row address bit 13 is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP6_ADDRMAP_ROW_B13(value) (UDDRC_ADDRMAP6_ADDRMAP_ROW_B13_Msk & ((value) << UDDRC_ADDRMAP6_ADDRMAP_ROW_B13_Pos))
#define UDDRC_ADDRMAP6_ADDRMAP_ROW_B14_Pos    _U_(16)                                              /**< (UDDRC_ADDRMAP6) Selects the HIF address bit used as row address bit 14. Valid Range: 0 to 11, and 15 Internal Base: 20 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 15 and then row address bit 14 is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP6_ADDRMAP_ROW_B14_Msk    (_U_(0xF) << UDDRC_ADDRMAP6_ADDRMAP_ROW_B14_Pos)     /**< (UDDRC_ADDRMAP6) Selects the HIF address bit used as row address bit 14. Valid Range: 0 to 11, and 15 Internal Base: 20 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 15 and then row address bit 14 is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP6_ADDRMAP_ROW_B14(value) (UDDRC_ADDRMAP6_ADDRMAP_ROW_B14_Msk & ((value) << UDDRC_ADDRMAP6_ADDRMAP_ROW_B14_Pos))
#define UDDRC_ADDRMAP6_ADDRMAP_ROW_B15_Pos    _U_(24)                                              /**< (UDDRC_ADDRMAP6) Selects the HIF address bit used as row address bit 15. Valid Range: 0 to 11, and 15 Internal Base: 21 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 15 and then row address bit 15 is set to 0. Programming Mode: Static Position */
#define UDDRC_ADDRMAP6_ADDRMAP_ROW_B15_Msk    (_U_(0xF) << UDDRC_ADDRMAP6_ADDRMAP_ROW_B15_Pos)     /**< (UDDRC_ADDRMAP6) Selects the HIF address bit used as row address bit 15. Valid Range: 0 to 11, and 15 Internal Base: 21 The selected HIF address bit is determined by adding the internal base to the value of this field.    If unused, set to 15 and then row address bit 15 is set to 0. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP6_ADDRMAP_ROW_B15(value) (UDDRC_ADDRMAP6_ADDRMAP_ROW_B15_Msk & ((value) << UDDRC_ADDRMAP6_ADDRMAP_ROW_B15_Pos))
#define UDDRC_ADDRMAP6_LPDDR3_6GB_12GB_Pos    _U_(31)                                              /**< (UDDRC_ADDRMAP6) Set this to 1 if there is an LPDDR3 SDRAM 6Gb or 12Gb device in use.  - 1 - LPDDR3 SDRAM 6Gb/12Gb device in use. Every address having row[14:13]==2'b11 is considered as invalid  - 0 - non-LPDDR3 6Gb/12Gb device in use. All addresses are valid Present only in designs configured to support LPDDR3. Programming Mode: Static Position */
#define UDDRC_ADDRMAP6_LPDDR3_6GB_12GB_Msk    (_U_(0x1) << UDDRC_ADDRMAP6_LPDDR3_6GB_12GB_Pos)     /**< (UDDRC_ADDRMAP6) Set this to 1 if there is an LPDDR3 SDRAM 6Gb or 12Gb device in use.  - 1 - LPDDR3 SDRAM 6Gb/12Gb device in use. Every address having row[14:13]==2'b11 is considered as invalid  - 0 - non-LPDDR3 6Gb/12Gb device in use. All addresses are valid Present only in designs configured to support LPDDR3. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP6_LPDDR3_6GB_12GB(value) (UDDRC_ADDRMAP6_LPDDR3_6GB_12GB_Msk & ((value) << UDDRC_ADDRMAP6_LPDDR3_6GB_12GB_Pos))
#define UDDRC_ADDRMAP6_Msk                    _U_(0x8F0F0F0F)                                      /**< (UDDRC_ADDRMAP6) Register Mask  */


/* -------- UDDRC_ADDRMAP9 : (UDDRC Offset: 0x224) (R/W 32) Address Map Register 9 -------- */
#define UDDRC_ADDRMAP9_RESETVALUE             _U_(0x00)                                            /**<  (UDDRC_ADDRMAP9) Address Map Register 9  Reset Value */

#define UDDRC_ADDRMAP9_ADDRMAP_ROW_B2_Pos     _U_(0)                                               /**< (UDDRC_ADDRMAP9) Selects the HIF address bits used as row address bit 2. Valid Range: 0 to 11 Internal Base: 8 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Position */
#define UDDRC_ADDRMAP9_ADDRMAP_ROW_B2_Msk     (_U_(0xF) << UDDRC_ADDRMAP9_ADDRMAP_ROW_B2_Pos)      /**< (UDDRC_ADDRMAP9) Selects the HIF address bits used as row address bit 2. Valid Range: 0 to 11 Internal Base: 8 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP9_ADDRMAP_ROW_B2(value)  (UDDRC_ADDRMAP9_ADDRMAP_ROW_B2_Msk & ((value) << UDDRC_ADDRMAP9_ADDRMAP_ROW_B2_Pos))
#define UDDRC_ADDRMAP9_ADDRMAP_ROW_B3_Pos     _U_(8)                                               /**< (UDDRC_ADDRMAP9) Selects the HIF address bits used as row address bit 3. Valid Range: 0 to 11 Internal Base: 9 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Position */
#define UDDRC_ADDRMAP9_ADDRMAP_ROW_B3_Msk     (_U_(0xF) << UDDRC_ADDRMAP9_ADDRMAP_ROW_B3_Pos)      /**< (UDDRC_ADDRMAP9) Selects the HIF address bits used as row address bit 3. Valid Range: 0 to 11 Internal Base: 9 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP9_ADDRMAP_ROW_B3(value)  (UDDRC_ADDRMAP9_ADDRMAP_ROW_B3_Msk & ((value) << UDDRC_ADDRMAP9_ADDRMAP_ROW_B3_Pos))
#define UDDRC_ADDRMAP9_ADDRMAP_ROW_B4_Pos     _U_(16)                                              /**< (UDDRC_ADDRMAP9) Selects the HIF address bits used as row address bit 4. Valid Range: 0 to 11 Internal Base: 10 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Position */
#define UDDRC_ADDRMAP9_ADDRMAP_ROW_B4_Msk     (_U_(0xF) << UDDRC_ADDRMAP9_ADDRMAP_ROW_B4_Pos)      /**< (UDDRC_ADDRMAP9) Selects the HIF address bits used as row address bit 4. Valid Range: 0 to 11 Internal Base: 10 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP9_ADDRMAP_ROW_B4(value)  (UDDRC_ADDRMAP9_ADDRMAP_ROW_B4_Msk & ((value) << UDDRC_ADDRMAP9_ADDRMAP_ROW_B4_Pos))
#define UDDRC_ADDRMAP9_ADDRMAP_ROW_B5_Pos     _U_(24)                                              /**< (UDDRC_ADDRMAP9) Selects the HIF address bits used as row address bit 5. Valid Range: 0 to 11 Internal Base: 11 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Position */
#define UDDRC_ADDRMAP9_ADDRMAP_ROW_B5_Msk     (_U_(0xF) << UDDRC_ADDRMAP9_ADDRMAP_ROW_B5_Pos)      /**< (UDDRC_ADDRMAP9) Selects the HIF address bits used as row address bit 5. Valid Range: 0 to 11 Internal Base: 11 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP9_ADDRMAP_ROW_B5(value)  (UDDRC_ADDRMAP9_ADDRMAP_ROW_B5_Msk & ((value) << UDDRC_ADDRMAP9_ADDRMAP_ROW_B5_Pos))
#define UDDRC_ADDRMAP9_Msk                    _U_(0x0F0F0F0F)                                      /**< (UDDRC_ADDRMAP9) Register Mask  */


/* -------- UDDRC_ADDRMAP10 : (UDDRC Offset: 0x228) (R/W 32) Address Map Register 10 -------- */
#define UDDRC_ADDRMAP10_RESETVALUE            _U_(0x00)                                            /**<  (UDDRC_ADDRMAP10) Address Map Register 10  Reset Value */

#define UDDRC_ADDRMAP10_ADDRMAP_ROW_B6_Pos    _U_(0)                                               /**< (UDDRC_ADDRMAP10) Selects the HIF address bits used as row address bit 6. Valid Range: 0 to 11 Internal Base: 12 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Position */
#define UDDRC_ADDRMAP10_ADDRMAP_ROW_B6_Msk    (_U_(0xF) << UDDRC_ADDRMAP10_ADDRMAP_ROW_B6_Pos)     /**< (UDDRC_ADDRMAP10) Selects the HIF address bits used as row address bit 6. Valid Range: 0 to 11 Internal Base: 12 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP10_ADDRMAP_ROW_B6(value) (UDDRC_ADDRMAP10_ADDRMAP_ROW_B6_Msk & ((value) << UDDRC_ADDRMAP10_ADDRMAP_ROW_B6_Pos))
#define UDDRC_ADDRMAP10_ADDRMAP_ROW_B7_Pos    _U_(8)                                               /**< (UDDRC_ADDRMAP10) Selects the HIF address bits used as row address bit 7. Valid Range: 0 to 11 Internal Base: 13 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Position */
#define UDDRC_ADDRMAP10_ADDRMAP_ROW_B7_Msk    (_U_(0xF) << UDDRC_ADDRMAP10_ADDRMAP_ROW_B7_Pos)     /**< (UDDRC_ADDRMAP10) Selects the HIF address bits used as row address bit 7. Valid Range: 0 to 11 Internal Base: 13 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP10_ADDRMAP_ROW_B7(value) (UDDRC_ADDRMAP10_ADDRMAP_ROW_B7_Msk & ((value) << UDDRC_ADDRMAP10_ADDRMAP_ROW_B7_Pos))
#define UDDRC_ADDRMAP10_ADDRMAP_ROW_B8_Pos    _U_(16)                                              /**< (UDDRC_ADDRMAP10) Selects the HIF address bits used as row address bit 8. Valid Range: 0 to 11 Internal Base: 14 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Position */
#define UDDRC_ADDRMAP10_ADDRMAP_ROW_B8_Msk    (_U_(0xF) << UDDRC_ADDRMAP10_ADDRMAP_ROW_B8_Pos)     /**< (UDDRC_ADDRMAP10) Selects the HIF address bits used as row address bit 8. Valid Range: 0 to 11 Internal Base: 14 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP10_ADDRMAP_ROW_B8(value) (UDDRC_ADDRMAP10_ADDRMAP_ROW_B8_Msk & ((value) << UDDRC_ADDRMAP10_ADDRMAP_ROW_B8_Pos))
#define UDDRC_ADDRMAP10_ADDRMAP_ROW_B9_Pos    _U_(24)                                              /**< (UDDRC_ADDRMAP10) Selects the HIF address bits used as row address bit 9. Valid Range: 0 to 11 Internal Base: 15 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Position */
#define UDDRC_ADDRMAP10_ADDRMAP_ROW_B9_Msk    (_U_(0xF) << UDDRC_ADDRMAP10_ADDRMAP_ROW_B9_Pos)     /**< (UDDRC_ADDRMAP10) Selects the HIF address bits used as row address bit 9. Valid Range: 0 to 11 Internal Base: 15 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP10_ADDRMAP_ROW_B9(value) (UDDRC_ADDRMAP10_ADDRMAP_ROW_B9_Msk & ((value) << UDDRC_ADDRMAP10_ADDRMAP_ROW_B9_Pos))
#define UDDRC_ADDRMAP10_Msk                   _U_(0x0F0F0F0F)                                      /**< (UDDRC_ADDRMAP10) Register Mask  */


/* -------- UDDRC_ADDRMAP11 : (UDDRC Offset: 0x22C) (R/W 32) Address Map Register 11 -------- */
#define UDDRC_ADDRMAP11_RESETVALUE            _U_(0x00)                                            /**<  (UDDRC_ADDRMAP11) Address Map Register 11  Reset Value */

#define UDDRC_ADDRMAP11_ADDRMAP_ROW_B10_Pos   _U_(0)                                               /**< (UDDRC_ADDRMAP11) Selects the HIF address bits used as row address bit 10. Valid Range: 0 to 11 Internal Base: 16 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Position */
#define UDDRC_ADDRMAP11_ADDRMAP_ROW_B10_Msk   (_U_(0xF) << UDDRC_ADDRMAP11_ADDRMAP_ROW_B10_Pos)    /**< (UDDRC_ADDRMAP11) Selects the HIF address bits used as row address bit 10. Valid Range: 0 to 11 Internal Base: 16 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15. Programming Mode: Static Mask */
#define UDDRC_ADDRMAP11_ADDRMAP_ROW_B10(value) (UDDRC_ADDRMAP11_ADDRMAP_ROW_B10_Msk & ((value) << UDDRC_ADDRMAP11_ADDRMAP_ROW_B10_Pos))
#define UDDRC_ADDRMAP11_Msk                   _U_(0x0000000F)                                      /**< (UDDRC_ADDRMAP11) Register Mask  */


/* -------- UDDRC_ODTCFG : (UDDRC Offset: 0x240) (R/W 32) ODT Configuration Register -------- */
#define UDDRC_ODTCFG_RESETVALUE               _U_(0x4000400)                                       /**<  (UDDRC_ODTCFG) ODT Configuration Register  Reset Value */

#define UDDRC_ODTCFG_RD_ODT_DELAY_Pos         _U_(2)                                               /**< (UDDRC_ODTCFG) The delay, in DFI PHY clock cycles, from issuing a read command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2.  Recommended values:   DDR2:  - CL + AL - 4 (not DDR2-1066),  CL + AL - 5 (DDR2-1066)    If (CL + AL - 4 < 0),  uMCTL2 does not support ODT for read operation.  DDR3:  - CL - CWL  DDR4:  - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)     RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)     If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) < 0,  uMCTL2 does not support ODT for read operation.  LPDDR3:  - RL + RD(tDQSCK(min)/tCK) - 1 - RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4 Position */
#define UDDRC_ODTCFG_RD_ODT_DELAY_Msk         (_U_(0x1F) << UDDRC_ODTCFG_RD_ODT_DELAY_Pos)         /**< (UDDRC_ODTCFG) The delay, in DFI PHY clock cycles, from issuing a read command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2.  Recommended values:   DDR2:  - CL + AL - 4 (not DDR2-1066),  CL + AL - 5 (DDR2-1066)    If (CL + AL - 4 < 0),  uMCTL2 does not support ODT for read operation.  DDR3:  - CL - CWL  DDR4:  - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)     RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)     If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) < 0,  uMCTL2 does not support ODT for read operation.  LPDDR3:  - RL + RD(tDQSCK(min)/tCK) - 1 - RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4 Mask */
#define UDDRC_ODTCFG_RD_ODT_DELAY(value)      (UDDRC_ODTCFG_RD_ODT_DELAY_Msk & ((value) << UDDRC_ODTCFG_RD_ODT_DELAY_Pos))
#define UDDRC_ODTCFG_RD_ODT_HOLD_Pos          _U_(8)                                               /**< (UDDRC_ODTCFG) DFI PHY clock cycles to hold ODT for a read command. The minimum supported value is 2.  Recommended values:   DDR2:  - BL8: 0x6 (not DDR2-1066),  0x7 (DDR2-1066)  - BL4: 0x4 (not DDR2-1066),  0x5 (DDR2-1066)  DDR3:  - BL8 - 0x6  DDR4:  - BL8: 5 + RD_PREAMBLE    RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)  LPDDR3:  - BL8:  5 + RU(tDQSCK(max)/tCK) - RD(tDQSCK(min)/tCK) + RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4 Position */
#define UDDRC_ODTCFG_RD_ODT_HOLD_Msk          (_U_(0xF) << UDDRC_ODTCFG_RD_ODT_HOLD_Pos)           /**< (UDDRC_ODTCFG) DFI PHY clock cycles to hold ODT for a read command. The minimum supported value is 2.  Recommended values:   DDR2:  - BL8: 0x6 (not DDR2-1066),  0x7 (DDR2-1066)  - BL4: 0x4 (not DDR2-1066),  0x5 (DDR2-1066)  DDR3:  - BL8 - 0x6  DDR4:  - BL8: 5 + RD_PREAMBLE    RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)  LPDDR3:  - BL8:  5 + RU(tDQSCK(max)/tCK) - RD(tDQSCK(min)/tCK) + RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4 Mask */
#define UDDRC_ODTCFG_RD_ODT_HOLD(value)       (UDDRC_ODTCFG_RD_ODT_HOLD_Msk & ((value) << UDDRC_ODTCFG_RD_ODT_HOLD_Pos))
#define UDDRC_ODTCFG_WR_ODT_DELAY_Pos         _U_(16)                                              /**< (UDDRC_ODTCFG) The delay, in DFI PHY clock cycles, from issuing a write command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2.  Recommended values:   DDR2:  - CWL + AL - 3 (DDR2-400/533/667),  CWL + AL - 4 (DDR2-800),  CWL + AL - 5 (DDR2-1066)    If (CWL + AL - 3  < 0),  uMCTL2 does not support ODT for write operation.  DDR3:  - 0x0  DDR4:  - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)   LPDDR3:  - WL - 1 - RU(tODTon(max)/tCK)) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4 Position */
#define UDDRC_ODTCFG_WR_ODT_DELAY_Msk         (_U_(0x1F) << UDDRC_ODTCFG_WR_ODT_DELAY_Pos)         /**< (UDDRC_ODTCFG) The delay, in DFI PHY clock cycles, from issuing a write command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2.  Recommended values:   DDR2:  - CWL + AL - 3 (DDR2-400/533/667),  CWL + AL - 4 (DDR2-800),  CWL + AL - 5 (DDR2-1066)    If (CWL + AL - 3  < 0),  uMCTL2 does not support ODT for write operation.  DDR3:  - 0x0  DDR4:  - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)   LPDDR3:  - WL - 1 - RU(tODTon(max)/tCK)) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4 Mask */
#define UDDRC_ODTCFG_WR_ODT_DELAY(value)      (UDDRC_ODTCFG_WR_ODT_DELAY_Msk & ((value) << UDDRC_ODTCFG_WR_ODT_DELAY_Pos))
#define UDDRC_ODTCFG_WR_ODT_HOLD_Pos          _U_(24)                                              /**< (UDDRC_ODTCFG) DFI PHY clock cycles to hold ODT for a write command. The minimum supported value is 2.  Recommended values:   DDR2:  - BL8:  0x5 (DDR2-400/533/667),  0x6 (DDR2-800),  0x7 (DDR2-1066)  - BL4:  0x3 (DDR2-400/533/667),  0x4 (DDR2-800),  0x5 (DDR2-1066)  DDR3:  - BL8: 0x6  DDR4:   - BL8: 5 + WR_PREAMBLE + CRC_MODE    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)    CRC_MODE = 0 (not CRC mode),  1 (CRC mode)  LPDDR3:  - BL8: 7 + RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4 Position */
#define UDDRC_ODTCFG_WR_ODT_HOLD_Msk          (_U_(0xF) << UDDRC_ODTCFG_WR_ODT_HOLD_Pos)           /**< (UDDRC_ODTCFG) DFI PHY clock cycles to hold ODT for a write command. The minimum supported value is 2.  Recommended values:   DDR2:  - BL8:  0x5 (DDR2-400/533/667),  0x6 (DDR2-800),  0x7 (DDR2-1066)  - BL4:  0x3 (DDR2-400/533/667),  0x4 (DDR2-800),  0x5 (DDR2-1066)  DDR3:  - BL8: 0x6  DDR4:   - BL8: 5 + WR_PREAMBLE + CRC_MODE    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)    CRC_MODE = 0 (not CRC mode),  1 (CRC mode)  LPDDR3:  - BL8: 7 + RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4 Mask */
#define UDDRC_ODTCFG_WR_ODT_HOLD(value)       (UDDRC_ODTCFG_WR_ODT_HOLD_Msk & ((value) << UDDRC_ODTCFG_WR_ODT_HOLD_Pos))
#define UDDRC_ODTCFG_Msk                      _U_(0x0F1F0F7C)                                      /**< (UDDRC_ODTCFG) Register Mask  */


/* -------- UDDRC_ODTMAP : (UDDRC Offset: 0x244) (R/W 32) ODT/Rank Map Register -------- */
#define UDDRC_ODTMAP_RESETVALUE               _U_(0x11)                                            /**<  (UDDRC_ODTMAP) ODT/Rank Map Register  Reset Value */

#define UDDRC_ODTMAP_RANK0_WR_ODT_Pos         _U_(0)                                               /**< (UDDRC_ODTMAP) Indicates which remote ODTs must be turned on during a write to rank 0. Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the appropriate bit here. Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc. For each rank, set its bit to 1 to enable its ODT. Programming Mode: Static Position */
#define UDDRC_ODTMAP_RANK0_WR_ODT_Msk         (_U_(0x1) << UDDRC_ODTMAP_RANK0_WR_ODT_Pos)          /**< (UDDRC_ODTMAP) Indicates which remote ODTs must be turned on during a write to rank 0. Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the appropriate bit here. Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc. For each rank, set its bit to 1 to enable its ODT. Programming Mode: Static Mask */
#define UDDRC_ODTMAP_RANK0_WR_ODT(value)      (UDDRC_ODTMAP_RANK0_WR_ODT_Msk & ((value) << UDDRC_ODTMAP_RANK0_WR_ODT_Pos))
#define UDDRC_ODTMAP_RANK0_RD_ODT_Pos         _U_(4)                                               /**< (UDDRC_ODTMAP) Indicates which remote ODTs must be turned on during a read from rank 0. Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the appropriate bit here. Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc. For each rank, set its bit to 1 to enable its ODT. Programming Mode: Static Position */
#define UDDRC_ODTMAP_RANK0_RD_ODT_Msk         (_U_(0x1) << UDDRC_ODTMAP_RANK0_RD_ODT_Pos)          /**< (UDDRC_ODTMAP) Indicates which remote ODTs must be turned on during a read from rank 0. Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the appropriate bit here. Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc. For each rank, set its bit to 1 to enable its ODT. Programming Mode: Static Mask */
#define UDDRC_ODTMAP_RANK0_RD_ODT(value)      (UDDRC_ODTMAP_RANK0_RD_ODT_Msk & ((value) << UDDRC_ODTMAP_RANK0_RD_ODT_Pos))
#define UDDRC_ODTMAP_Msk                      _U_(0x00000011)                                      /**< (UDDRC_ODTMAP) Register Mask  */


/* -------- UDDRC_SCHED : (UDDRC Offset: 0x250) (R/W 32) Scheduler Control Register -------- */
#define UDDRC_SCHED_RESETVALUE                _U_(0x1005)                                          /**<  (UDDRC_SCHED) Scheduler Control Register  Reset Value */

#define UDDRC_SCHED_FORCE_LOW_PRI_N_Pos       _U_(0)                                               /**< (UDDRC_SCHED) Active low signal. When asserted ('0'), all incoming transactions are forced to low priority. This implies that all High Priority Read (HPR) and Variable Priority Read commands (VPR) will be treated as Low Priority Read (LPR) commands. On the write side, all Variable Priority Write (VPW) commands will be treated as Normal Priority Write (NPW) commands. Forcing the incoming transactions to low priority implicitly turns off Bypass path for read commands. FOR PERFORMANCE ONLY. Programming Mode: Static Position */
#define UDDRC_SCHED_FORCE_LOW_PRI_N_Msk       (_U_(0x1) << UDDRC_SCHED_FORCE_LOW_PRI_N_Pos)        /**< (UDDRC_SCHED) Active low signal. When asserted ('0'), all incoming transactions are forced to low priority. This implies that all High Priority Read (HPR) and Variable Priority Read commands (VPR) will be treated as Low Priority Read (LPR) commands. On the write side, all Variable Priority Write (VPW) commands will be treated as Normal Priority Write (NPW) commands. Forcing the incoming transactions to low priority implicitly turns off Bypass path for read commands. FOR PERFORMANCE ONLY. Programming Mode: Static Mask */
#define UDDRC_SCHED_FORCE_LOW_PRI_N(value)    (UDDRC_SCHED_FORCE_LOW_PRI_N_Msk & ((value) << UDDRC_SCHED_FORCE_LOW_PRI_N_Pos))
#define UDDRC_SCHED_PREFER_WRITE_Pos          _U_(1)                                               /**< (UDDRC_SCHED) If set then the bank selector prefers writes over reads. FOR DEBUG ONLY. Programming Mode: Static Position */
#define UDDRC_SCHED_PREFER_WRITE_Msk          (_U_(0x1) << UDDRC_SCHED_PREFER_WRITE_Pos)           /**< (UDDRC_SCHED) If set then the bank selector prefers writes over reads. FOR DEBUG ONLY. Programming Mode: Static Mask */
#define UDDRC_SCHED_PREFER_WRITE(value)       (UDDRC_SCHED_PREFER_WRITE_Msk & ((value) << UDDRC_SCHED_PREFER_WRITE_Pos))
#define UDDRC_SCHED_PAGECLOSE_Pos             _U_(2)                                               /**< (UDDRC_SCHED) If true, bank is kept open only while there are page hit transactions available in the CAM to that bank. The last read or write command in the CAM with a bank and page hit will be executed with auto-precharge if SCHED1.pageclose_timer=0. Even if this register set to 1 and SCHED1.pageclose_timer is set to 0, explicit precharge (and not auto-precharge) may be issued in some cases where there is a mode switch between Write and Read or between LPR and HPR. The Read and Write commands that are executed as part of the ECC scrub requests are also executed without auto-precharge.  If false, the bank remains open until there is a need to close it (to open a different page, or for page timeout or refresh timeout) - also known as open page policy. The open page policy can be overridden by setting the per-command-autopre bit on the HIF interface (hif_cmd_autopre). The pageclose feature provids a midway between Open and Close page policies. FOR PERFORMANCE ONLY. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_SCHED_PAGECLOSE_Msk             (_U_(0x1) << UDDRC_SCHED_PAGECLOSE_Pos)              /**< (UDDRC_SCHED) If true, bank is kept open only while there are page hit transactions available in the CAM to that bank. The last read or write command in the CAM with a bank and page hit will be executed with auto-precharge if SCHED1.pageclose_timer=0. Even if this register set to 1 and SCHED1.pageclose_timer is set to 0, explicit precharge (and not auto-precharge) may be issued in some cases where there is a mode switch between Write and Read or between LPR and HPR. The Read and Write commands that are executed as part of the ECC scrub requests are also executed without auto-precharge.  If false, the bank remains open until there is a need to close it (to open a different page, or for page timeout or refresh timeout) - also known as open page policy. The open page policy can be overridden by setting the per-command-autopre bit on the HIF interface (hif_cmd_autopre). The pageclose feature provids a midway between Open and Close page policies. FOR PERFORMANCE ONLY. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_SCHED_PAGECLOSE(value)          (UDDRC_SCHED_PAGECLOSE_Msk & ((value) << UDDRC_SCHED_PAGECLOSE_Pos))
#define UDDRC_SCHED_LPR_NUM_ENTRIES_Pos       _U_(8)                                               /**< (UDDRC_SCHED) Number of entries in the low priority transaction store is this value + 1. (MEMC_NO_OF_ENTRY - (SCHED.lpr_num_entries + 1)) is the number of entries available for the high priority transaction store. Setting this to maximum value allocates all entries to low priority transaction store. Setting this to 0 allocates 1 entry to low priority transaction store and the rest to high priority transaction store. Note: In ECC configurations, the numbers of write and low priority read credits issued is one less than in the non-ECC case.  One entry each is reserved in the write and low-priority read CAMs for storing the RMW requests arising out of single bit error correction RMW operation. Programming Mode: Static Position */
#define UDDRC_SCHED_LPR_NUM_ENTRIES_Msk       (_U_(0x1F) << UDDRC_SCHED_LPR_NUM_ENTRIES_Pos)       /**< (UDDRC_SCHED) Number of entries in the low priority transaction store is this value + 1. (MEMC_NO_OF_ENTRY - (SCHED.lpr_num_entries + 1)) is the number of entries available for the high priority transaction store. Setting this to maximum value allocates all entries to low priority transaction store. Setting this to 0 allocates 1 entry to low priority transaction store and the rest to high priority transaction store. Note: In ECC configurations, the numbers of write and low priority read credits issued is one less than in the non-ECC case.  One entry each is reserved in the write and low-priority read CAMs for storing the RMW requests arising out of single bit error correction RMW operation. Programming Mode: Static Mask */
#define UDDRC_SCHED_LPR_NUM_ENTRIES(value)    (UDDRC_SCHED_LPR_NUM_ENTRIES_Msk & ((value) << UDDRC_SCHED_LPR_NUM_ENTRIES_Pos))
#define UDDRC_SCHED_GO2CRITICAL_HYSTERESIS_Pos _U_(16)                                              /**< (UDDRC_SCHED) UNUSED Programming Mode: Static Position */
#define UDDRC_SCHED_GO2CRITICAL_HYSTERESIS_Msk (_U_(0xFF) << UDDRC_SCHED_GO2CRITICAL_HYSTERESIS_Pos) /**< (UDDRC_SCHED) UNUSED Programming Mode: Static Mask */
#define UDDRC_SCHED_GO2CRITICAL_HYSTERESIS(value) (UDDRC_SCHED_GO2CRITICAL_HYSTERESIS_Msk & ((value) << UDDRC_SCHED_GO2CRITICAL_HYSTERESIS_Pos))
#define UDDRC_SCHED_RDWR_IDLE_GAP_Pos         _U_(24)                                              /**< (UDDRC_SCHED) When the preferred transaction store is empty for these many clock cycles, switch to the alternate transaction store if it is non-empty. The read transaction store (both high and low priority) is the default preferred transaction store and the write transaction store is the alternative store. When prefer write over read is set this is reversed. 0x0 is a legal value for this register. When set to 0x0, the transaction store switching will happen immediately when the switching conditions become true. FOR PERFORMANCE ONLY. Unit: DFI clock cycles. Programming Mode: Static Position */
#define UDDRC_SCHED_RDWR_IDLE_GAP_Msk         (_U_(0x7F) << UDDRC_SCHED_RDWR_IDLE_GAP_Pos)         /**< (UDDRC_SCHED) When the preferred transaction store is empty for these many clock cycles, switch to the alternate transaction store if it is non-empty. The read transaction store (both high and low priority) is the default preferred transaction store and the write transaction store is the alternative store. When prefer write over read is set this is reversed. 0x0 is a legal value for this register. When set to 0x0, the transaction store switching will happen immediately when the switching conditions become true. FOR PERFORMANCE ONLY. Unit: DFI clock cycles. Programming Mode: Static Mask */
#define UDDRC_SCHED_RDWR_IDLE_GAP(value)      (UDDRC_SCHED_RDWR_IDLE_GAP_Msk & ((value) << UDDRC_SCHED_RDWR_IDLE_GAP_Pos))
#define UDDRC_SCHED_Msk                       _U_(0x7FFF1F07)                                      /**< (UDDRC_SCHED) Register Mask  */


/* -------- UDDRC_SCHED1 : (UDDRC Offset: 0x254) (R/W 32) Scheduler Control Register 1 -------- */
#define UDDRC_SCHED1_RESETVALUE               _U_(0x00)                                            /**<  (UDDRC_SCHED1) Scheduler Control Register 1  Reset Value */

#define UDDRC_SCHED1_PAGECLOSE_TIMER_Pos      _U_(0)                                               /**< (UDDRC_SCHED1) This field works in conjunction with SCHED.pageclose. It only has meaning if SCHED.pageclose==1.  If SCHED.pageclose==1 and pageclose_timer==0, then an auto-precharge may be scheduled for last read  or write command in the CAM with a bank and page hit.  Note, sometimes an explicit precharge is scheduled instead of the auto-precharge. See SCHED.pageclose for details of when this may happen.  If SCHED.pageclose==1 and pageclose_timer>0, then an auto-precharge is not scheduled for last read or write command in the CAM with a bank and page hit. Instead, a timer is started, with pageclose_timer as the initial value. There is a timer on a per bank basis. The timer decrements unless the next read or write in the CAM to a bank is a page hit. It gets reset to pageclose_timer value if the next read or write in the CAM to a bank is a page hit. Once the timer has reached zero, an explcit precharge will be attempted to be scheduled.  Unit: DFI clock cycles. Programming Mode: Static Position */
#define UDDRC_SCHED1_PAGECLOSE_TIMER_Msk      (_U_(0xFF) << UDDRC_SCHED1_PAGECLOSE_TIMER_Pos)      /**< (UDDRC_SCHED1) This field works in conjunction with SCHED.pageclose. It only has meaning if SCHED.pageclose==1.  If SCHED.pageclose==1 and pageclose_timer==0, then an auto-precharge may be scheduled for last read  or write command in the CAM with a bank and page hit.  Note, sometimes an explicit precharge is scheduled instead of the auto-precharge. See SCHED.pageclose for details of when this may happen.  If SCHED.pageclose==1 and pageclose_timer>0, then an auto-precharge is not scheduled for last read or write command in the CAM with a bank and page hit. Instead, a timer is started, with pageclose_timer as the initial value. There is a timer on a per bank basis. The timer decrements unless the next read or write in the CAM to a bank is a page hit. It gets reset to pageclose_timer value if the next read or write in the CAM to a bank is a page hit. Once the timer has reached zero, an explcit precharge will be attempted to be scheduled.  Unit: DFI clock cycles. Programming Mode: Static Mask */
#define UDDRC_SCHED1_PAGECLOSE_TIMER(value)   (UDDRC_SCHED1_PAGECLOSE_TIMER_Msk & ((value) << UDDRC_SCHED1_PAGECLOSE_TIMER_Pos))
#define UDDRC_SCHED1_Msk                      _U_(0x000000FF)                                      /**< (UDDRC_SCHED1) Register Mask  */


/* -------- UDDRC_PERFHPR1 : (UDDRC Offset: 0x25C) (R/W 32) High Priority Read CAM Register 1 -------- */
#define UDDRC_PERFHPR1_RESETVALUE             _U_(0xF000001)                                       /**<  (UDDRC_PERFHPR1) High Priority Read CAM Register 1  Reset Value */

#define UDDRC_PERFHPR1_HPR_MAX_STARVE_Pos     _U_(0)                                               /**< (UDDRC_PERFHPR1) Number of DFI clocks that the HPR queue can be starved before it goes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies. FOR PERFORMANCE ONLY. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PERFHPR1_HPR_MAX_STARVE_Msk     (_U_(0xFFFF) << UDDRC_PERFHPR1_HPR_MAX_STARVE_Pos)   /**< (UDDRC_PERFHPR1) Number of DFI clocks that the HPR queue can be starved before it goes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies. FOR PERFORMANCE ONLY. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PERFHPR1_HPR_MAX_STARVE(value)  (UDDRC_PERFHPR1_HPR_MAX_STARVE_Msk & ((value) << UDDRC_PERFHPR1_HPR_MAX_STARVE_Pos))
#define UDDRC_PERFHPR1_HPR_XACT_RUN_LENGTH_Pos _U_(24)                                              /**< (UDDRC_PERFHPR1) Number of transactions that are serviced once the HPR queue goes critical is the smaller of:  - (a) This number  - (b) Number of transactions available.    Unit: Transaction. FOR PERFORMANCE ONLY. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PERFHPR1_HPR_XACT_RUN_LENGTH_Msk (_U_(0xFF) << UDDRC_PERFHPR1_HPR_XACT_RUN_LENGTH_Pos) /**< (UDDRC_PERFHPR1) Number of transactions that are serviced once the HPR queue goes critical is the smaller of:  - (a) This number  - (b) Number of transactions available.    Unit: Transaction. FOR PERFORMANCE ONLY. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PERFHPR1_HPR_XACT_RUN_LENGTH(value) (UDDRC_PERFHPR1_HPR_XACT_RUN_LENGTH_Msk & ((value) << UDDRC_PERFHPR1_HPR_XACT_RUN_LENGTH_Pos))
#define UDDRC_PERFHPR1_Msk                    _U_(0xFF00FFFF)                                      /**< (UDDRC_PERFHPR1) Register Mask  */


/* -------- UDDRC_PERFLPR1 : (UDDRC Offset: 0x264) (R/W 32) Low Priority Read CAM Register 1 -------- */
#define UDDRC_PERFLPR1_RESETVALUE             _U_(0xF00007F)                                       /**<  (UDDRC_PERFLPR1) Low Priority Read CAM Register 1  Reset Value */

#define UDDRC_PERFLPR1_LPR_MAX_STARVE_Pos     _U_(0)                                               /**< (UDDRC_PERFLPR1) Number of DFI clocks that the LPR queue can be starved before it goes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies. FOR PERFORMANCE ONLY. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PERFLPR1_LPR_MAX_STARVE_Msk     (_U_(0xFFFF) << UDDRC_PERFLPR1_LPR_MAX_STARVE_Pos)   /**< (UDDRC_PERFLPR1) Number of DFI clocks that the LPR queue can be starved before it goes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies. FOR PERFORMANCE ONLY. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PERFLPR1_LPR_MAX_STARVE(value)  (UDDRC_PERFLPR1_LPR_MAX_STARVE_Msk & ((value) << UDDRC_PERFLPR1_LPR_MAX_STARVE_Pos))
#define UDDRC_PERFLPR1_LPR_XACT_RUN_LENGTH_Pos _U_(24)                                              /**< (UDDRC_PERFLPR1) Number of transactions that are serviced once the LPR queue goes critical is the smaller of:  - (a) This number  - (b) Number of transactions available. Unit: Transaction. FOR PERFORMANCE ONLY. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PERFLPR1_LPR_XACT_RUN_LENGTH_Msk (_U_(0xFF) << UDDRC_PERFLPR1_LPR_XACT_RUN_LENGTH_Pos) /**< (UDDRC_PERFLPR1) Number of transactions that are serviced once the LPR queue goes critical is the smaller of:  - (a) This number  - (b) Number of transactions available. Unit: Transaction. FOR PERFORMANCE ONLY. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PERFLPR1_LPR_XACT_RUN_LENGTH(value) (UDDRC_PERFLPR1_LPR_XACT_RUN_LENGTH_Msk & ((value) << UDDRC_PERFLPR1_LPR_XACT_RUN_LENGTH_Pos))
#define UDDRC_PERFLPR1_Msk                    _U_(0xFF00FFFF)                                      /**< (UDDRC_PERFLPR1) Register Mask  */


/* -------- UDDRC_PERFWR1 : (UDDRC Offset: 0x26C) (R/W 32) Write CAM Register 1 -------- */
#define UDDRC_PERFWR1_RESETVALUE              _U_(0xF00007F)                                       /**<  (UDDRC_PERFWR1) Write CAM Register 1  Reset Value */

#define UDDRC_PERFWR1_W_MAX_STARVE_Pos        _U_(0)                                               /**< (UDDRC_PERFWR1) Number of DFI clocks that the WR queue can be starved before it goes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies. FOR PERFORMANCE ONLY. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PERFWR1_W_MAX_STARVE_Msk        (_U_(0xFFFF) << UDDRC_PERFWR1_W_MAX_STARVE_Pos)      /**< (UDDRC_PERFWR1) Number of DFI clocks that the WR queue can be starved before it goes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies. FOR PERFORMANCE ONLY. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PERFWR1_W_MAX_STARVE(value)     (UDDRC_PERFWR1_W_MAX_STARVE_Msk & ((value) << UDDRC_PERFWR1_W_MAX_STARVE_Pos))
#define UDDRC_PERFWR1_W_XACT_RUN_LENGTH_Pos   _U_(24)                                              /**< (UDDRC_PERFWR1) Number of transactions that are serviced once the WR queue goes critical is the smaller of:  - (a) This number   - (b) Number of transactions available. Unit: Transaction. FOR PERFORMANCE ONLY. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PERFWR1_W_XACT_RUN_LENGTH_Msk   (_U_(0xFF) << UDDRC_PERFWR1_W_XACT_RUN_LENGTH_Pos)   /**< (UDDRC_PERFWR1) Number of transactions that are serviced once the WR queue goes critical is the smaller of:  - (a) This number   - (b) Number of transactions available. Unit: Transaction. FOR PERFORMANCE ONLY. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PERFWR1_W_XACT_RUN_LENGTH(value) (UDDRC_PERFWR1_W_XACT_RUN_LENGTH_Msk & ((value) << UDDRC_PERFWR1_W_XACT_RUN_LENGTH_Pos))
#define UDDRC_PERFWR1_Msk                     _U_(0xFF00FFFF)                                      /**< (UDDRC_PERFWR1) Register Mask  */


/* -------- UDDRC_DBG0 : (UDDRC Offset: 0x300) (R/W 32) Debug Register 0 -------- */
#define UDDRC_DBG0_RESETVALUE                 _U_(0x00)                                            /**<  (UDDRC_DBG0) Debug Register 0  Reset Value */

#define UDDRC_DBG0_DIS_WC_Pos                 _U_(0)                                               /**< (UDDRC_DBG0) When 1, disable write combine. FOR DEBUG ONLY Programming Mode: Static Position */
#define UDDRC_DBG0_DIS_WC_Msk                 (_U_(0x1) << UDDRC_DBG0_DIS_WC_Pos)                  /**< (UDDRC_DBG0) When 1, disable write combine. FOR DEBUG ONLY Programming Mode: Static Mask */
#define UDDRC_DBG0_DIS_WC(value)              (UDDRC_DBG0_DIS_WC_Msk & ((value) << UDDRC_DBG0_DIS_WC_Pos))
#define UDDRC_DBG0_DIS_RD_BYPASS_Pos          _U_(1)                                               /**< (UDDRC_DBG0) Only present in designs supporting read bypass. When 1, disable bypass path for high priority read page hits FOR DEBUG ONLY. Programming Mode: Static Position */
#define UDDRC_DBG0_DIS_RD_BYPASS_Msk          (_U_(0x1) << UDDRC_DBG0_DIS_RD_BYPASS_Pos)           /**< (UDDRC_DBG0) Only present in designs supporting read bypass. When 1, disable bypass path for high priority read page hits FOR DEBUG ONLY. Programming Mode: Static Mask */
#define UDDRC_DBG0_DIS_RD_BYPASS(value)       (UDDRC_DBG0_DIS_RD_BYPASS_Msk & ((value) << UDDRC_DBG0_DIS_RD_BYPASS_Pos))
#define UDDRC_DBG0_DIS_ACT_BYPASS_Pos         _U_(2)                                               /**< (UDDRC_DBG0) Only present in designs supporting activate bypass. When 1, disable bypass path for high priority read activates FOR DEBUG ONLY. Programming Mode: Static Position */
#define UDDRC_DBG0_DIS_ACT_BYPASS_Msk         (_U_(0x1) << UDDRC_DBG0_DIS_ACT_BYPASS_Pos)          /**< (UDDRC_DBG0) Only present in designs supporting activate bypass. When 1, disable bypass path for high priority read activates FOR DEBUG ONLY. Programming Mode: Static Mask */
#define UDDRC_DBG0_DIS_ACT_BYPASS(value)      (UDDRC_DBG0_DIS_ACT_BYPASS_Msk & ((value) << UDDRC_DBG0_DIS_ACT_BYPASS_Pos))
#define UDDRC_DBG0_DIS_COLLISION_PAGE_OPT_Pos _U_(4)                                               /**< (UDDRC_DBG0) When this is set to '0', auto-precharge is disabled for the flushed command in a collision case. Collision cases are write followed by read to same address, read followed by write to same address, or write followed by write to same address with DBG0.dis_wc bit = 1 (where same address comparisons exclude the two address bits representing critical word). FOR DEBUG ONLY. Programming Mode: Static Position */
#define UDDRC_DBG0_DIS_COLLISION_PAGE_OPT_Msk (_U_(0x1) << UDDRC_DBG0_DIS_COLLISION_PAGE_OPT_Pos)  /**< (UDDRC_DBG0) When this is set to '0', auto-precharge is disabled for the flushed command in a collision case. Collision cases are write followed by read to same address, read followed by write to same address, or write followed by write to same address with DBG0.dis_wc bit = 1 (where same address comparisons exclude the two address bits representing critical word). FOR DEBUG ONLY. Programming Mode: Static Mask */
#define UDDRC_DBG0_DIS_COLLISION_PAGE_OPT(value) (UDDRC_DBG0_DIS_COLLISION_PAGE_OPT_Msk & ((value) << UDDRC_DBG0_DIS_COLLISION_PAGE_OPT_Pos))
#define UDDRC_DBG0_Msk                        _U_(0x00000017)                                      /**< (UDDRC_DBG0) Register Mask  */


/* -------- UDDRC_DBG1 : (UDDRC Offset: 0x304) (R/W 32) Debug Register 1 -------- */
#define UDDRC_DBG1_RESETVALUE                 _U_(0x00)                                            /**<  (UDDRC_DBG1) Debug Register 1  Reset Value */

#define UDDRC_DBG1_DIS_DQ_Pos                 _U_(0)                                               /**< (UDDRC_DBG1) When 1, uMCTL2 will not de-queue any transactions from the CAM. Bypass is also disabled. All transactions are queued in the CAM. No reads or writes are issued to SDRAM as long as this is asserted. This bit may be used to prevent reads or writes being issued by the uMCTL2, which makes it safe to modify certain register fields associated with reads and writes (see User Guide for details).  After setting this bit, it is strongly recommended to poll DBGCAM.wr_data_pipeline_empty and DBGCAM.rd_data_pipeline_empty, before making changes to any registers which affect reads and writes.  This will ensure that the relevant logic in the DDRC is idle. This bit is intended to be switched on-the-fly. Programming Mode: Dynamic Position */
#define UDDRC_DBG1_DIS_DQ_Msk                 (_U_(0x1) << UDDRC_DBG1_DIS_DQ_Pos)                  /**< (UDDRC_DBG1) When 1, uMCTL2 will not de-queue any transactions from the CAM. Bypass is also disabled. All transactions are queued in the CAM. No reads or writes are issued to SDRAM as long as this is asserted. This bit may be used to prevent reads or writes being issued by the uMCTL2, which makes it safe to modify certain register fields associated with reads and writes (see User Guide for details).  After setting this bit, it is strongly recommended to poll DBGCAM.wr_data_pipeline_empty and DBGCAM.rd_data_pipeline_empty, before making changes to any registers which affect reads and writes.  This will ensure that the relevant logic in the DDRC is idle. This bit is intended to be switched on-the-fly. Programming Mode: Dynamic Mask */
#define UDDRC_DBG1_DIS_DQ(value)              (UDDRC_DBG1_DIS_DQ_Msk & ((value) << UDDRC_DBG1_DIS_DQ_Pos))
#define UDDRC_DBG1_DIS_HIF_Pos                _U_(1)                                               /**< (UDDRC_DBG1) When 1, uMCTL2 asserts the HIF command signal hif_cmd_stall. uMCTL2 will ignore the hif_cmd_valid and all other associated request signals. This bit is intended to be switched on-the-fly. Programming Mode: Dynamic Position */
#define UDDRC_DBG1_DIS_HIF_Msk                (_U_(0x1) << UDDRC_DBG1_DIS_HIF_Pos)                 /**< (UDDRC_DBG1) When 1, uMCTL2 asserts the HIF command signal hif_cmd_stall. uMCTL2 will ignore the hif_cmd_valid and all other associated request signals. This bit is intended to be switched on-the-fly. Programming Mode: Dynamic Mask */
#define UDDRC_DBG1_DIS_HIF(value)             (UDDRC_DBG1_DIS_HIF_Msk & ((value) << UDDRC_DBG1_DIS_HIF_Pos))
#define UDDRC_DBG1_Msk                        _U_(0x00000003)                                      /**< (UDDRC_DBG1) Register Mask  */


/* -------- UDDRC_DBGCAM : (UDDRC Offset: 0x308) ( R/ 32) CAM Debug Register -------- */
#define UDDRC_DBGCAM_RESETVALUE               _U_(0x00)                                            /**<  (UDDRC_DBGCAM) CAM Debug Register  Reset Value */

#define UDDRC_DBGCAM_DBG_HPR_Q_DEPTH_Pos      _U_(0)                                               /**< (UDDRC_DBGCAM) High priority read queue depth FOR DEBUG ONLY Programming Mode: Dynamic Position */
#define UDDRC_DBGCAM_DBG_HPR_Q_DEPTH_Msk      (_U_(0x3F) << UDDRC_DBGCAM_DBG_HPR_Q_DEPTH_Pos)      /**< (UDDRC_DBGCAM) High priority read queue depth FOR DEBUG ONLY Programming Mode: Dynamic Mask */
#define UDDRC_DBGCAM_DBG_HPR_Q_DEPTH(value)   (UDDRC_DBGCAM_DBG_HPR_Q_DEPTH_Msk & ((value) << UDDRC_DBGCAM_DBG_HPR_Q_DEPTH_Pos))
#define UDDRC_DBGCAM_DBG_LPR_Q_DEPTH_Pos      _U_(8)                                               /**< (UDDRC_DBGCAM) Low priority read queue depth The last entry of Lpr queue is reserved for ECC SCRUB operation. This entry is not included in the calculation of the queue depth. FOR DEBUG ONLY Programming Mode: Dynamic Position */
#define UDDRC_DBGCAM_DBG_LPR_Q_DEPTH_Msk      (_U_(0x3F) << UDDRC_DBGCAM_DBG_LPR_Q_DEPTH_Pos)      /**< (UDDRC_DBGCAM) Low priority read queue depth The last entry of Lpr queue is reserved for ECC SCRUB operation. This entry is not included in the calculation of the queue depth. FOR DEBUG ONLY Programming Mode: Dynamic Mask */
#define UDDRC_DBGCAM_DBG_LPR_Q_DEPTH(value)   (UDDRC_DBGCAM_DBG_LPR_Q_DEPTH_Msk & ((value) << UDDRC_DBGCAM_DBG_LPR_Q_DEPTH_Pos))
#define UDDRC_DBGCAM_DBG_W_Q_DEPTH_Pos        _U_(16)                                              /**< (UDDRC_DBGCAM) Write queue depth The last entry of WR queue is reserved for ECC SCRUB operation. This entry is not included in the calculation of the queue depth. FOR DEBUG ONLY Programming Mode: Dynamic Position */
#define UDDRC_DBGCAM_DBG_W_Q_DEPTH_Msk        (_U_(0x3F) << UDDRC_DBGCAM_DBG_W_Q_DEPTH_Pos)        /**< (UDDRC_DBGCAM) Write queue depth The last entry of WR queue is reserved for ECC SCRUB operation. This entry is not included in the calculation of the queue depth. FOR DEBUG ONLY Programming Mode: Dynamic Mask */
#define UDDRC_DBGCAM_DBG_W_Q_DEPTH(value)     (UDDRC_DBGCAM_DBG_W_Q_DEPTH_Msk & ((value) << UDDRC_DBGCAM_DBG_W_Q_DEPTH_Pos))
#define UDDRC_DBGCAM_DBG_STALL_Pos            _U_(24)                                              /**< (UDDRC_DBGCAM) Stall FOR DEBUG ONLY Programming Mode: Dynamic Position */
#define UDDRC_DBGCAM_DBG_STALL_Msk            (_U_(0x1) << UDDRC_DBGCAM_DBG_STALL_Pos)             /**< (UDDRC_DBGCAM) Stall FOR DEBUG ONLY Programming Mode: Dynamic Mask */
#define UDDRC_DBGCAM_DBG_STALL(value)         (UDDRC_DBGCAM_DBG_STALL_Msk & ((value) << UDDRC_DBGCAM_DBG_STALL_Pos))
#define UDDRC_DBGCAM_DBG_RD_Q_EMPTY_Pos       _U_(25)                                              /**< (UDDRC_DBGCAM) When 1, all the Read command queues and Read data buffers inside DDRC are empty. This register is to be used for debug purpose.  An example use-case scenario: When Controller enters Self-Refresh using the Low-Power entry sequence, Controller is expected to have executed all the commands in its queues and the write and read data drained. Hence this register should be 1 at that time. FOR DEBUG ONLY Programming Mode: Dynamic Position */
#define UDDRC_DBGCAM_DBG_RD_Q_EMPTY_Msk       (_U_(0x1) << UDDRC_DBGCAM_DBG_RD_Q_EMPTY_Pos)        /**< (UDDRC_DBGCAM) When 1, all the Read command queues and Read data buffers inside DDRC are empty. This register is to be used for debug purpose.  An example use-case scenario: When Controller enters Self-Refresh using the Low-Power entry sequence, Controller is expected to have executed all the commands in its queues and the write and read data drained. Hence this register should be 1 at that time. FOR DEBUG ONLY Programming Mode: Dynamic Mask */
#define UDDRC_DBGCAM_DBG_RD_Q_EMPTY(value)    (UDDRC_DBGCAM_DBG_RD_Q_EMPTY_Msk & ((value) << UDDRC_DBGCAM_DBG_RD_Q_EMPTY_Pos))
#define UDDRC_DBGCAM_DBG_WR_Q_EMPTY_Pos       _U_(26)                                              /**< (UDDRC_DBGCAM) When 1, all the Write command queues and Write data buffers inside DDRC are empty. This register is to be used for debug purpose.  An example use-case scenario: When Controller enters Self-Refresh using the Low-Power entry sequence, Controller is expected to have executed all the commands in its queues and the write and read data drained. Hence this register should be 1 at that time. FOR DEBUG ONLY Programming Mode: Dynamic Position */
#define UDDRC_DBGCAM_DBG_WR_Q_EMPTY_Msk       (_U_(0x1) << UDDRC_DBGCAM_DBG_WR_Q_EMPTY_Pos)        /**< (UDDRC_DBGCAM) When 1, all the Write command queues and Write data buffers inside DDRC are empty. This register is to be used for debug purpose.  An example use-case scenario: When Controller enters Self-Refresh using the Low-Power entry sequence, Controller is expected to have executed all the commands in its queues and the write and read data drained. Hence this register should be 1 at that time. FOR DEBUG ONLY Programming Mode: Dynamic Mask */
#define UDDRC_DBGCAM_DBG_WR_Q_EMPTY(value)    (UDDRC_DBGCAM_DBG_WR_Q_EMPTY_Msk & ((value) << UDDRC_DBGCAM_DBG_WR_Q_EMPTY_Pos))
#define UDDRC_DBGCAM_RD_DATA_PIPELINE_EMPTY_Pos _U_(28)                                              /**< (UDDRC_DBGCAM) This bit indicates that the read data pipeline on the DFI interface is empty.  This register is intended to be polled at least twice after setting DBG1.dis_dq, to ensure that all remaining commands/data have completed. Programming Mode: Dynamic Position */
#define UDDRC_DBGCAM_RD_DATA_PIPELINE_EMPTY_Msk (_U_(0x1) << UDDRC_DBGCAM_RD_DATA_PIPELINE_EMPTY_Pos) /**< (UDDRC_DBGCAM) This bit indicates that the read data pipeline on the DFI interface is empty.  This register is intended to be polled at least twice after setting DBG1.dis_dq, to ensure that all remaining commands/data have completed. Programming Mode: Dynamic Mask */
#define UDDRC_DBGCAM_RD_DATA_PIPELINE_EMPTY(value) (UDDRC_DBGCAM_RD_DATA_PIPELINE_EMPTY_Msk & ((value) << UDDRC_DBGCAM_RD_DATA_PIPELINE_EMPTY_Pos))
#define UDDRC_DBGCAM_WR_DATA_PIPELINE_EMPTY_Pos _U_(29)                                              /**< (UDDRC_DBGCAM) This bit indicates that the write data pipeline on the DFI interface is empty.  This register is intended to be polled at least twice after setting DBG1.dis_dq, to ensure that all remaining commands/data have completed. Programming Mode: Dynamic Position */
#define UDDRC_DBGCAM_WR_DATA_PIPELINE_EMPTY_Msk (_U_(0x1) << UDDRC_DBGCAM_WR_DATA_PIPELINE_EMPTY_Pos) /**< (UDDRC_DBGCAM) This bit indicates that the write data pipeline on the DFI interface is empty.  This register is intended to be polled at least twice after setting DBG1.dis_dq, to ensure that all remaining commands/data have completed. Programming Mode: Dynamic Mask */
#define UDDRC_DBGCAM_WR_DATA_PIPELINE_EMPTY(value) (UDDRC_DBGCAM_WR_DATA_PIPELINE_EMPTY_Msk & ((value) << UDDRC_DBGCAM_WR_DATA_PIPELINE_EMPTY_Pos))
#define UDDRC_DBGCAM_Msk                      _U_(0x373F3F3F)                                      /**< (UDDRC_DBGCAM) Register Mask  */


/* -------- UDDRC_DBGCMD : (UDDRC Offset: 0x30C) (R/W 32) Command Debug Register -------- */
#define UDDRC_DBGCMD_RESETVALUE               _U_(0x00)                                            /**<  (UDDRC_DBGCMD) Command Debug Register  Reset Value */

#define UDDRC_DBGCMD_RANK0_REFRESH_Pos        _U_(0)                                               /**< (UDDRC_DBGCMD) Setting this register bit to 1 indicates to the uMCTL2 to issue a refresh to rank 0. Writing to this bit causes DBGSTAT.rank0_refresh_busy to be set. When DBGSTAT.rank0_refresh_busy is cleared, the command has been stored in uMCTL2.   For 3DS configuration, refresh is sent to rank index 0.   This operation can be performed only when RFSHCTL3.dis_auto_refresh=1. It is recommended NOT to set this register bit if in Init or Deep power-down operating modes or Maximum Power Saving Mode. Programming Mode: Dynamic Position */
#define UDDRC_DBGCMD_RANK0_REFRESH_Msk        (_U_(0x1) << UDDRC_DBGCMD_RANK0_REFRESH_Pos)         /**< (UDDRC_DBGCMD) Setting this register bit to 1 indicates to the uMCTL2 to issue a refresh to rank 0. Writing to this bit causes DBGSTAT.rank0_refresh_busy to be set. When DBGSTAT.rank0_refresh_busy is cleared, the command has been stored in uMCTL2.   For 3DS configuration, refresh is sent to rank index 0.   This operation can be performed only when RFSHCTL3.dis_auto_refresh=1. It is recommended NOT to set this register bit if in Init or Deep power-down operating modes or Maximum Power Saving Mode. Programming Mode: Dynamic Mask */
#define UDDRC_DBGCMD_RANK0_REFRESH(value)     (UDDRC_DBGCMD_RANK0_REFRESH_Msk & ((value) << UDDRC_DBGCMD_RANK0_REFRESH_Pos))
#define UDDRC_DBGCMD_ZQ_CALIB_SHORT_Pos       _U_(4)                                               /**< (UDDRC_DBGCMD) Setting this register bit to 1 indicates to the uMCTL2 to issue a ZQCS (ZQ calibration short)/MPC(ZQ calibration) command to the SDRAM.  When this request is stored in the uMCTL2, the bit is automatically cleared. This operation can be performed only when ZQCTL0.dis_auto_zq=1. It is recommended NOT to set this register bit if in Init, in Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) or Deep power-down operating modes or Maximum Power Saving Mode.  For Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) it will be scheduled after SR(except LPDDR4) or SPRD(LPDDR4) has been exited. For Deep power down and Maximum Power Saving Mode, it will not be scheduled, although DBGSTAT.zq_calib_short_busy will be de-asserted. Programming Mode: Dynamic Position */
#define UDDRC_DBGCMD_ZQ_CALIB_SHORT_Msk       (_U_(0x1) << UDDRC_DBGCMD_ZQ_CALIB_SHORT_Pos)        /**< (UDDRC_DBGCMD) Setting this register bit to 1 indicates to the uMCTL2 to issue a ZQCS (ZQ calibration short)/MPC(ZQ calibration) command to the SDRAM.  When this request is stored in the uMCTL2, the bit is automatically cleared. This operation can be performed only when ZQCTL0.dis_auto_zq=1. It is recommended NOT to set this register bit if in Init, in Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) or Deep power-down operating modes or Maximum Power Saving Mode.  For Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) it will be scheduled after SR(except LPDDR4) or SPRD(LPDDR4) has been exited. For Deep power down and Maximum Power Saving Mode, it will not be scheduled, although DBGSTAT.zq_calib_short_busy will be de-asserted. Programming Mode: Dynamic Mask */
#define UDDRC_DBGCMD_ZQ_CALIB_SHORT(value)    (UDDRC_DBGCMD_ZQ_CALIB_SHORT_Msk & ((value) << UDDRC_DBGCMD_ZQ_CALIB_SHORT_Pos))
#define UDDRC_DBGCMD_CTRLUPD_Pos              _U_(5)                                               /**< (UDDRC_DBGCMD) Setting this register bit to 1 indicates to the uMCTL2 to issue a dfi_ctrlupd_req to the PHY.  When this request is stored in the uMCTL2, the bit is automatically cleared. This operation must only be performed when DFIUPD0.dis_auto_ctrlupd=1. Programming Mode: Dynamic Position */
#define UDDRC_DBGCMD_CTRLUPD_Msk              (_U_(0x1) << UDDRC_DBGCMD_CTRLUPD_Pos)               /**< (UDDRC_DBGCMD) Setting this register bit to 1 indicates to the uMCTL2 to issue a dfi_ctrlupd_req to the PHY.  When this request is stored in the uMCTL2, the bit is automatically cleared. This operation must only be performed when DFIUPD0.dis_auto_ctrlupd=1. Programming Mode: Dynamic Mask */
#define UDDRC_DBGCMD_CTRLUPD(value)           (UDDRC_DBGCMD_CTRLUPD_Msk & ((value) << UDDRC_DBGCMD_CTRLUPD_Pos))
#define UDDRC_DBGCMD_Msk                      _U_(0x00000031)                                      /**< (UDDRC_DBGCMD) Register Mask  */


/* -------- UDDRC_DBGSTAT : (UDDRC Offset: 0x310) ( R/ 32) Status Debug Register -------- */
#define UDDRC_DBGSTAT_RESETVALUE              _U_(0x00)                                            /**<  (UDDRC_DBGSTAT) Status Debug Register  Reset Value */

#define UDDRC_DBGSTAT_RANK0_REFRESH_BUSY_Pos  _U_(0)                                               /**< (UDDRC_DBGSTAT) SoC core may initiate a rank0_refresh operation (refresh operation to rank 0) only if this signal is low.  This signal goes high in the clock after DBGCMD.rank0_refresh is set to one. It goes low when the rank0_refresh operation is stored in the uMCTL2.  It is recommended not to perform rank0_refresh operations when this signal is high.  - 0 - Indicates that the SoC core can initiate a rank0_refresh operation  - 1 - Indicates that rank0_refresh operation has not been stored yet in the uMCTL2 Programming Mode: Dynamic Position */
#define UDDRC_DBGSTAT_RANK0_REFRESH_BUSY_Msk  (_U_(0x1) << UDDRC_DBGSTAT_RANK0_REFRESH_BUSY_Pos)   /**< (UDDRC_DBGSTAT) SoC core may initiate a rank0_refresh operation (refresh operation to rank 0) only if this signal is low.  This signal goes high in the clock after DBGCMD.rank0_refresh is set to one. It goes low when the rank0_refresh operation is stored in the uMCTL2.  It is recommended not to perform rank0_refresh operations when this signal is high.  - 0 - Indicates that the SoC core can initiate a rank0_refresh operation  - 1 - Indicates that rank0_refresh operation has not been stored yet in the uMCTL2 Programming Mode: Dynamic Mask */
#define UDDRC_DBGSTAT_RANK0_REFRESH_BUSY(value) (UDDRC_DBGSTAT_RANK0_REFRESH_BUSY_Msk & ((value) << UDDRC_DBGSTAT_RANK0_REFRESH_BUSY_Pos))
#define UDDRC_DBGSTAT_ZQ_CALIB_SHORT_BUSY_Pos _U_(4)                                               /**< (UDDRC_DBGSTAT) SoC core may initiate a ZQCS (ZQ calibration short) operation only if this signal is low. This signal goes high in the clock after the uMCTL2 accepts the ZQCS request. It goes low when the ZQCS operation is initiated in the uMCTL2. It is recommended not to perform ZQCS operations when this signal is high.  - 0 - Indicates that the SoC core can initiate a ZQCS operation  - 1 - Indicates that ZQCS operation has not been initiated yet in the uMCTL2 Programming Mode: Dynamic Position */
#define UDDRC_DBGSTAT_ZQ_CALIB_SHORT_BUSY_Msk (_U_(0x1) << UDDRC_DBGSTAT_ZQ_CALIB_SHORT_BUSY_Pos)  /**< (UDDRC_DBGSTAT) SoC core may initiate a ZQCS (ZQ calibration short) operation only if this signal is low. This signal goes high in the clock after the uMCTL2 accepts the ZQCS request. It goes low when the ZQCS operation is initiated in the uMCTL2. It is recommended not to perform ZQCS operations when this signal is high.  - 0 - Indicates that the SoC core can initiate a ZQCS operation  - 1 - Indicates that ZQCS operation has not been initiated yet in the uMCTL2 Programming Mode: Dynamic Mask */
#define UDDRC_DBGSTAT_ZQ_CALIB_SHORT_BUSY(value) (UDDRC_DBGSTAT_ZQ_CALIB_SHORT_BUSY_Msk & ((value) << UDDRC_DBGSTAT_ZQ_CALIB_SHORT_BUSY_Pos))
#define UDDRC_DBGSTAT_CTRLUPD_BUSY_Pos        _U_(5)                                               /**< (UDDRC_DBGSTAT) SoC core may initiate a ctrlupd operation only if this signal is low.  This signal goes high in the clock after the uMCTL2 accepts the ctrlupd request. It goes low when the ctrlupd operation is initiated in the uMCTL2.  It is recommended not to perform ctrlupd operations when this signal is high.  - 0 - Indicates that the SoC core can initiate a ctrlupd operation  - 1 - Indicates that ctrlupd operation has not been initiated yet in the uMCTL2 Programming Mode: Dynamic Position */
#define UDDRC_DBGSTAT_CTRLUPD_BUSY_Msk        (_U_(0x1) << UDDRC_DBGSTAT_CTRLUPD_BUSY_Pos)         /**< (UDDRC_DBGSTAT) SoC core may initiate a ctrlupd operation only if this signal is low.  This signal goes high in the clock after the uMCTL2 accepts the ctrlupd request. It goes low when the ctrlupd operation is initiated in the uMCTL2.  It is recommended not to perform ctrlupd operations when this signal is high.  - 0 - Indicates that the SoC core can initiate a ctrlupd operation  - 1 - Indicates that ctrlupd operation has not been initiated yet in the uMCTL2 Programming Mode: Dynamic Mask */
#define UDDRC_DBGSTAT_CTRLUPD_BUSY(value)     (UDDRC_DBGSTAT_CTRLUPD_BUSY_Msk & ((value) << UDDRC_DBGSTAT_CTRLUPD_BUSY_Pos))
#define UDDRC_DBGSTAT_Msk                     _U_(0x00000031)                                      /**< (UDDRC_DBGSTAT) Register Mask  */


/* -------- UDDRC_SWCTL : (UDDRC Offset: 0x320) (R/W 32) Software Register Programming Control Enable -------- */
#define UDDRC_SWCTL_RESETVALUE                _U_(0x01)                                            /**<  (UDDRC_SWCTL) Software Register Programming Control Enable  Reset Value */

#define UDDRC_SWCTL_SW_DONE_Pos               _U_(0)                                               /**< (UDDRC_SWCTL) Enable quasi-dynamic register programming outside reset. Program register to 0 to enable quasi-dynamic programming. Set back register to 1 once programming is done. Programming Mode: Dynamic Position */
#define UDDRC_SWCTL_SW_DONE_Msk               (_U_(0x1) << UDDRC_SWCTL_SW_DONE_Pos)                /**< (UDDRC_SWCTL) Enable quasi-dynamic register programming outside reset. Program register to 0 to enable quasi-dynamic programming. Set back register to 1 once programming is done. Programming Mode: Dynamic Mask */
#define UDDRC_SWCTL_SW_DONE(value)            (UDDRC_SWCTL_SW_DONE_Msk & ((value) << UDDRC_SWCTL_SW_DONE_Pos))
#define UDDRC_SWCTL_Msk                       _U_(0x00000001)                                      /**< (UDDRC_SWCTL) Register Mask  */


/* -------- UDDRC_SWSTAT : (UDDRC Offset: 0x324) ( R/ 32) Software Register Programming Control Status -------- */
#define UDDRC_SWSTAT_RESETVALUE               _U_(0x01)                                            /**<  (UDDRC_SWSTAT) Software Register Programming Control Status  Reset Value */

#define UDDRC_SWSTAT_SW_DONE_ACK_Pos          _U_(0)                                               /**< (UDDRC_SWSTAT) Register programming done. This register is the echo of SWCTL.sw_done. Wait for sw_done value 1 to propagate to sw_done_ack at the end of the programming sequence to ensure that the correct registers values are propagated to the destination clock domains. Programming Mode: Static Position */
#define UDDRC_SWSTAT_SW_DONE_ACK_Msk          (_U_(0x1) << UDDRC_SWSTAT_SW_DONE_ACK_Pos)           /**< (UDDRC_SWSTAT) Register programming done. This register is the echo of SWCTL.sw_done. Wait for sw_done value 1 to propagate to sw_done_ack at the end of the programming sequence to ensure that the correct registers values are propagated to the destination clock domains. Programming Mode: Static Mask */
#define UDDRC_SWSTAT_SW_DONE_ACK(value)       (UDDRC_SWSTAT_SW_DONE_ACK_Msk & ((value) << UDDRC_SWSTAT_SW_DONE_ACK_Pos))
#define UDDRC_SWSTAT_Msk                      _U_(0x00000001)                                      /**< (UDDRC_SWSTAT) Register Mask  */


/* -------- UDDRC_POISONCFG : (UDDRC Offset: 0x36C) (R/W 32) AXI Poison Configuration Register. Common for all AXI ports -------- */
#define UDDRC_POISONCFG_RESETVALUE            _U_(0x110011)                                        /**<  (UDDRC_POISONCFG) AXI Poison Configuration Register. Common for all AXI ports  Reset Value */

#define UDDRC_POISONCFG_WR_POISON_SLVERR_EN_Pos _U_(0)                                               /**< (UDDRC_POISONCFG) If set to 1, enables SLVERR response for write transaction poisoning Programming Mode: Dynamic Position */
#define UDDRC_POISONCFG_WR_POISON_SLVERR_EN_Msk (_U_(0x1) << UDDRC_POISONCFG_WR_POISON_SLVERR_EN_Pos) /**< (UDDRC_POISONCFG) If set to 1, enables SLVERR response for write transaction poisoning Programming Mode: Dynamic Mask */
#define UDDRC_POISONCFG_WR_POISON_SLVERR_EN(value) (UDDRC_POISONCFG_WR_POISON_SLVERR_EN_Msk & ((value) << UDDRC_POISONCFG_WR_POISON_SLVERR_EN_Pos))
#define UDDRC_POISONCFG_WR_POISON_INTR_EN_Pos _U_(4)                                               /**< (UDDRC_POISONCFG) If set to 1, enables interrupts for write transaction poisoning Programming Mode: Dynamic Position */
#define UDDRC_POISONCFG_WR_POISON_INTR_EN_Msk (_U_(0x1) << UDDRC_POISONCFG_WR_POISON_INTR_EN_Pos)  /**< (UDDRC_POISONCFG) If set to 1, enables interrupts for write transaction poisoning Programming Mode: Dynamic Mask */
#define UDDRC_POISONCFG_WR_POISON_INTR_EN(value) (UDDRC_POISONCFG_WR_POISON_INTR_EN_Msk & ((value) << UDDRC_POISONCFG_WR_POISON_INTR_EN_Pos))
#define UDDRC_POISONCFG_WR_POISON_INTR_CLR_Pos _U_(8)                                               /**< (UDDRC_POISONCFG) Interrupt clear for write transaction poisoning. Allow 2/3 clock cycles for correct value to propagate to core logic and clear the interrupts. uMCTL2 automatically clears this bit. Programming Mode: Dynamic Position */
#define UDDRC_POISONCFG_WR_POISON_INTR_CLR_Msk (_U_(0x1) << UDDRC_POISONCFG_WR_POISON_INTR_CLR_Pos) /**< (UDDRC_POISONCFG) Interrupt clear for write transaction poisoning. Allow 2/3 clock cycles for correct value to propagate to core logic and clear the interrupts. uMCTL2 automatically clears this bit. Programming Mode: Dynamic Mask */
#define UDDRC_POISONCFG_WR_POISON_INTR_CLR(value) (UDDRC_POISONCFG_WR_POISON_INTR_CLR_Msk & ((value) << UDDRC_POISONCFG_WR_POISON_INTR_CLR_Pos))
#define UDDRC_POISONCFG_RD_POISON_SLVERR_EN_Pos _U_(16)                                              /**< (UDDRC_POISONCFG) If set to 1, enables SLVERR response for read transaction poisoning Programming Mode: Dynamic Position */
#define UDDRC_POISONCFG_RD_POISON_SLVERR_EN_Msk (_U_(0x1) << UDDRC_POISONCFG_RD_POISON_SLVERR_EN_Pos) /**< (UDDRC_POISONCFG) If set to 1, enables SLVERR response for read transaction poisoning Programming Mode: Dynamic Mask */
#define UDDRC_POISONCFG_RD_POISON_SLVERR_EN(value) (UDDRC_POISONCFG_RD_POISON_SLVERR_EN_Msk & ((value) << UDDRC_POISONCFG_RD_POISON_SLVERR_EN_Pos))
#define UDDRC_POISONCFG_RD_POISON_INTR_EN_Pos _U_(20)                                              /**< (UDDRC_POISONCFG) If set to 1, enables interrupts for read transaction poisoning Programming Mode: Dynamic Position */
#define UDDRC_POISONCFG_RD_POISON_INTR_EN_Msk (_U_(0x1) << UDDRC_POISONCFG_RD_POISON_INTR_EN_Pos)  /**< (UDDRC_POISONCFG) If set to 1, enables interrupts for read transaction poisoning Programming Mode: Dynamic Mask */
#define UDDRC_POISONCFG_RD_POISON_INTR_EN(value) (UDDRC_POISONCFG_RD_POISON_INTR_EN_Msk & ((value) << UDDRC_POISONCFG_RD_POISON_INTR_EN_Pos))
#define UDDRC_POISONCFG_RD_POISON_INTR_CLR_Pos _U_(24)                                              /**< (UDDRC_POISONCFG) Interrupt clear for read transaction poisoning.  Allow 2/3 clock cycles for correct value to propagate to core logic and clear the interrupts. uMCTL2 automatically clears this bit. Programming Mode: Dynamic Position */
#define UDDRC_POISONCFG_RD_POISON_INTR_CLR_Msk (_U_(0x1) << UDDRC_POISONCFG_RD_POISON_INTR_CLR_Pos) /**< (UDDRC_POISONCFG) Interrupt clear for read transaction poisoning.  Allow 2/3 clock cycles for correct value to propagate to core logic and clear the interrupts. uMCTL2 automatically clears this bit. Programming Mode: Dynamic Mask */
#define UDDRC_POISONCFG_RD_POISON_INTR_CLR(value) (UDDRC_POISONCFG_RD_POISON_INTR_CLR_Msk & ((value) << UDDRC_POISONCFG_RD_POISON_INTR_CLR_Pos))
#define UDDRC_POISONCFG_Msk                   _U_(0x01110111)                                      /**< (UDDRC_POISONCFG) Register Mask  */


/* -------- UDDRC_POISONSTAT : (UDDRC Offset: 0x370) ( R/ 32) AXI Poison Status Register -------- */
#define UDDRC_POISONSTAT_RESETVALUE           _U_(0x00)                                            /**<  (UDDRC_POISONSTAT) AXI Poison Status Register  Reset Value */

#define UDDRC_POISONSTAT_WR_POISON_INTR_0_Pos _U_(0)                                               /**< (UDDRC_POISONSTAT) Write transaction poisoning error interrupt for port 0. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Position */
#define UDDRC_POISONSTAT_WR_POISON_INTR_0_Msk (_U_(0x1) << UDDRC_POISONSTAT_WR_POISON_INTR_0_Pos)  /**< (UDDRC_POISONSTAT) Write transaction poisoning error interrupt for port 0. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Mask */
#define UDDRC_POISONSTAT_WR_POISON_INTR_0(value) (UDDRC_POISONSTAT_WR_POISON_INTR_0_Msk & ((value) << UDDRC_POISONSTAT_WR_POISON_INTR_0_Pos))
#define UDDRC_POISONSTAT_WR_POISON_INTR_1_Pos _U_(1)                                               /**< (UDDRC_POISONSTAT) Write transaction poisoning error interrupt for port 1. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Position */
#define UDDRC_POISONSTAT_WR_POISON_INTR_1_Msk (_U_(0x1) << UDDRC_POISONSTAT_WR_POISON_INTR_1_Pos)  /**< (UDDRC_POISONSTAT) Write transaction poisoning error interrupt for port 1. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Mask */
#define UDDRC_POISONSTAT_WR_POISON_INTR_1(value) (UDDRC_POISONSTAT_WR_POISON_INTR_1_Msk & ((value) << UDDRC_POISONSTAT_WR_POISON_INTR_1_Pos))
#define UDDRC_POISONSTAT_WR_POISON_INTR_2_Pos _U_(2)                                               /**< (UDDRC_POISONSTAT) Write transaction poisoning error interrupt for port 2. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Position */
#define UDDRC_POISONSTAT_WR_POISON_INTR_2_Msk (_U_(0x1) << UDDRC_POISONSTAT_WR_POISON_INTR_2_Pos)  /**< (UDDRC_POISONSTAT) Write transaction poisoning error interrupt for port 2. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Mask */
#define UDDRC_POISONSTAT_WR_POISON_INTR_2(value) (UDDRC_POISONSTAT_WR_POISON_INTR_2_Msk & ((value) << UDDRC_POISONSTAT_WR_POISON_INTR_2_Pos))
#define UDDRC_POISONSTAT_WR_POISON_INTR_3_Pos _U_(3)                                               /**< (UDDRC_POISONSTAT) Write transaction poisoning error interrupt for port 3. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Position */
#define UDDRC_POISONSTAT_WR_POISON_INTR_3_Msk (_U_(0x1) << UDDRC_POISONSTAT_WR_POISON_INTR_3_Pos)  /**< (UDDRC_POISONSTAT) Write transaction poisoning error interrupt for port 3. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Mask */
#define UDDRC_POISONSTAT_WR_POISON_INTR_3(value) (UDDRC_POISONSTAT_WR_POISON_INTR_3_Msk & ((value) << UDDRC_POISONSTAT_WR_POISON_INTR_3_Pos))
#define UDDRC_POISONSTAT_WR_POISON_INTR_4_Pos _U_(4)                                               /**< (UDDRC_POISONSTAT) Write transaction poisoning error interrupt for port 4. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Position */
#define UDDRC_POISONSTAT_WR_POISON_INTR_4_Msk (_U_(0x1) << UDDRC_POISONSTAT_WR_POISON_INTR_4_Pos)  /**< (UDDRC_POISONSTAT) Write transaction poisoning error interrupt for port 4. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Mask */
#define UDDRC_POISONSTAT_WR_POISON_INTR_4(value) (UDDRC_POISONSTAT_WR_POISON_INTR_4_Msk & ((value) << UDDRC_POISONSTAT_WR_POISON_INTR_4_Pos))
#define UDDRC_POISONSTAT_RD_POISON_INTR_0_Pos _U_(16)                                              /**< (UDDRC_POISONSTAT) Read transaction poisoning error interrupt for port 0. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Position */
#define UDDRC_POISONSTAT_RD_POISON_INTR_0_Msk (_U_(0x1) << UDDRC_POISONSTAT_RD_POISON_INTR_0_Pos)  /**< (UDDRC_POISONSTAT) Read transaction poisoning error interrupt for port 0. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Mask */
#define UDDRC_POISONSTAT_RD_POISON_INTR_0(value) (UDDRC_POISONSTAT_RD_POISON_INTR_0_Msk & ((value) << UDDRC_POISONSTAT_RD_POISON_INTR_0_Pos))
#define UDDRC_POISONSTAT_RD_POISON_INTR_1_Pos _U_(17)                                              /**< (UDDRC_POISONSTAT) Read transaction poisoning error interrupt for port 1. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Position */
#define UDDRC_POISONSTAT_RD_POISON_INTR_1_Msk (_U_(0x1) << UDDRC_POISONSTAT_RD_POISON_INTR_1_Pos)  /**< (UDDRC_POISONSTAT) Read transaction poisoning error interrupt for port 1. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Mask */
#define UDDRC_POISONSTAT_RD_POISON_INTR_1(value) (UDDRC_POISONSTAT_RD_POISON_INTR_1_Msk & ((value) << UDDRC_POISONSTAT_RD_POISON_INTR_1_Pos))
#define UDDRC_POISONSTAT_RD_POISON_INTR_2_Pos _U_(18)                                              /**< (UDDRC_POISONSTAT) Read transaction poisoning error interrupt for port 2. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Position */
#define UDDRC_POISONSTAT_RD_POISON_INTR_2_Msk (_U_(0x1) << UDDRC_POISONSTAT_RD_POISON_INTR_2_Pos)  /**< (UDDRC_POISONSTAT) Read transaction poisoning error interrupt for port 2. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Mask */
#define UDDRC_POISONSTAT_RD_POISON_INTR_2(value) (UDDRC_POISONSTAT_RD_POISON_INTR_2_Msk & ((value) << UDDRC_POISONSTAT_RD_POISON_INTR_2_Pos))
#define UDDRC_POISONSTAT_RD_POISON_INTR_3_Pos _U_(19)                                              /**< (UDDRC_POISONSTAT) Read transaction poisoning error interrupt for port 3. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Position */
#define UDDRC_POISONSTAT_RD_POISON_INTR_3_Msk (_U_(0x1) << UDDRC_POISONSTAT_RD_POISON_INTR_3_Pos)  /**< (UDDRC_POISONSTAT) Read transaction poisoning error interrupt for port 3. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Mask */
#define UDDRC_POISONSTAT_RD_POISON_INTR_3(value) (UDDRC_POISONSTAT_RD_POISON_INTR_3_Msk & ((value) << UDDRC_POISONSTAT_RD_POISON_INTR_3_Pos))
#define UDDRC_POISONSTAT_RD_POISON_INTR_4_Pos _U_(20)                                              /**< (UDDRC_POISONSTAT) Read transaction poisoning error interrupt for port 4. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Position */
#define UDDRC_POISONSTAT_RD_POISON_INTR_4_Msk (_U_(0x1) << UDDRC_POISONSTAT_RD_POISON_INTR_4_Pos)  /**< (UDDRC_POISONSTAT) Read transaction poisoning error interrupt for port 4. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic Mask */
#define UDDRC_POISONSTAT_RD_POISON_INTR_4(value) (UDDRC_POISONSTAT_RD_POISON_INTR_4_Msk & ((value) << UDDRC_POISONSTAT_RD_POISON_INTR_4_Pos))
#define UDDRC_POISONSTAT_Msk                  _U_(0x001F001F)                                      /**< (UDDRC_POISONSTAT) Register Mask  */

#define UDDRC_POISONSTAT_WR_POISON_INTR__Pos  _U_(0)                                               /**< (UDDRC_POISONSTAT Position) Write transaction poisoning error interrupt for port x. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit x corresponds to Port x, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic */
#define UDDRC_POISONSTAT_WR_POISON_INTR__Msk  (_U_(0x1F) << UDDRC_POISONSTAT_WR_POISON_INTR__Pos)  /**< (UDDRC_POISONSTAT Mask) WR_POISON_INTR_ */
#define UDDRC_POISONSTAT_WR_POISON_INTR_(value) (UDDRC_POISONSTAT_WR_POISON_INTR__Msk & ((value) << UDDRC_POISONSTAT_WR_POISON_INTR__Pos)) 
#define UDDRC_POISONSTAT_RD_POISON_INTR__Pos  _U_(16)                                              /**< (UDDRC_POISONSTAT Position) Read transaction poisoning error interrupt for port 4. This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit x corresponds to Port x, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock. Programming Mode: Dynamic */
#define UDDRC_POISONSTAT_RD_POISON_INTR__Msk  (_U_(0x1F) << UDDRC_POISONSTAT_RD_POISON_INTR__Pos)  /**< (UDDRC_POISONSTAT Mask) RD_POISON_INTR_ */
#define UDDRC_POISONSTAT_RD_POISON_INTR_(value) (UDDRC_POISONSTAT_RD_POISON_INTR__Msk & ((value) << UDDRC_POISONSTAT_RD_POISON_INTR__Pos)) 

/* -------- UDDRC_DERATESTAT : (UDDRC Offset: 0x3F0) ( R/ 32) Temperature Derate Status Register -------- */
#define UDDRC_DERATESTAT_RESETVALUE           _U_(0x00)                                            /**<  (UDDRC_DERATESTAT) Temperature Derate Status Register  Reset Value */

#define UDDRC_DERATESTAT_DERATE_TEMP_LIMIT_INTR_Pos _U_(0)                                               /**< (UDDRC_DERATESTAT) Derate temperature interrupt indicating LPDDR2/3/4 SDRAM temperature operating limit is exceeded.    This register field is set to 1 when the value read from MR4[2:0] is 3'b000 or 3'b111. Cleared by register DERATECTL.derate_temp_limit_intr_clr. Programming Mode: Static Position */
#define UDDRC_DERATESTAT_DERATE_TEMP_LIMIT_INTR_Msk (_U_(0x1) << UDDRC_DERATESTAT_DERATE_TEMP_LIMIT_INTR_Pos) /**< (UDDRC_DERATESTAT) Derate temperature interrupt indicating LPDDR2/3/4 SDRAM temperature operating limit is exceeded.    This register field is set to 1 when the value read from MR4[2:0] is 3'b000 or 3'b111. Cleared by register DERATECTL.derate_temp_limit_intr_clr. Programming Mode: Static Mask */
#define UDDRC_DERATESTAT_DERATE_TEMP_LIMIT_INTR(value) (UDDRC_DERATESTAT_DERATE_TEMP_LIMIT_INTR_Msk & ((value) << UDDRC_DERATESTAT_DERATE_TEMP_LIMIT_INTR_Pos))
#define UDDRC_DERATESTAT_Msk                  _U_(0x00000001)                                      /**< (UDDRC_DERATESTAT) Register Mask  */


/* -------- UDDRC_PSTAT : (UDDRC Offset: 0x3FC) ( R/ 32) Port Status Register -------- */
#define UDDRC_PSTAT_RESETVALUE                _U_(0x00)                                            /**<  (UDDRC_PSTAT) Port Status Register  Reset Value */

#define UDDRC_PSTAT_RD_PORT_BUSY_0_Pos        _U_(0)                                               /**< (UDDRC_PSTAT) Indicates if there are outstanding reads for AXI port 0. Programming Mode: Dynamic Position */
#define UDDRC_PSTAT_RD_PORT_BUSY_0_Msk        (_U_(0x1) << UDDRC_PSTAT_RD_PORT_BUSY_0_Pos)         /**< (UDDRC_PSTAT) Indicates if there are outstanding reads for AXI port 0. Programming Mode: Dynamic Mask */
#define UDDRC_PSTAT_RD_PORT_BUSY_0(value)     (UDDRC_PSTAT_RD_PORT_BUSY_0_Msk & ((value) << UDDRC_PSTAT_RD_PORT_BUSY_0_Pos))
#define UDDRC_PSTAT_RD_PORT_BUSY_1_Pos        _U_(1)                                               /**< (UDDRC_PSTAT) Indicates if there are outstanding reads for AXI port 1. Programming Mode: Dynamic Position */
#define UDDRC_PSTAT_RD_PORT_BUSY_1_Msk        (_U_(0x1) << UDDRC_PSTAT_RD_PORT_BUSY_1_Pos)         /**< (UDDRC_PSTAT) Indicates if there are outstanding reads for AXI port 1. Programming Mode: Dynamic Mask */
#define UDDRC_PSTAT_RD_PORT_BUSY_1(value)     (UDDRC_PSTAT_RD_PORT_BUSY_1_Msk & ((value) << UDDRC_PSTAT_RD_PORT_BUSY_1_Pos))
#define UDDRC_PSTAT_RD_PORT_BUSY_2_Pos        _U_(2)                                               /**< (UDDRC_PSTAT) Indicates if there are outstanding reads for AXI port 2. Programming Mode: Dynamic Position */
#define UDDRC_PSTAT_RD_PORT_BUSY_2_Msk        (_U_(0x1) << UDDRC_PSTAT_RD_PORT_BUSY_2_Pos)         /**< (UDDRC_PSTAT) Indicates if there are outstanding reads for AXI port 2. Programming Mode: Dynamic Mask */
#define UDDRC_PSTAT_RD_PORT_BUSY_2(value)     (UDDRC_PSTAT_RD_PORT_BUSY_2_Msk & ((value) << UDDRC_PSTAT_RD_PORT_BUSY_2_Pos))
#define UDDRC_PSTAT_RD_PORT_BUSY_3_Pos        _U_(3)                                               /**< (UDDRC_PSTAT) Indicates if there are outstanding reads for AXI port 3. Programming Mode: Dynamic Position */
#define UDDRC_PSTAT_RD_PORT_BUSY_3_Msk        (_U_(0x1) << UDDRC_PSTAT_RD_PORT_BUSY_3_Pos)         /**< (UDDRC_PSTAT) Indicates if there are outstanding reads for AXI port 3. Programming Mode: Dynamic Mask */
#define UDDRC_PSTAT_RD_PORT_BUSY_3(value)     (UDDRC_PSTAT_RD_PORT_BUSY_3_Msk & ((value) << UDDRC_PSTAT_RD_PORT_BUSY_3_Pos))
#define UDDRC_PSTAT_RD_PORT_BUSY_4_Pos        _U_(4)                                               /**< (UDDRC_PSTAT) Indicates if there are outstanding reads for AXI port 4. Programming Mode: Dynamic Position */
#define UDDRC_PSTAT_RD_PORT_BUSY_4_Msk        (_U_(0x1) << UDDRC_PSTAT_RD_PORT_BUSY_4_Pos)         /**< (UDDRC_PSTAT) Indicates if there are outstanding reads for AXI port 4. Programming Mode: Dynamic Mask */
#define UDDRC_PSTAT_RD_PORT_BUSY_4(value)     (UDDRC_PSTAT_RD_PORT_BUSY_4_Msk & ((value) << UDDRC_PSTAT_RD_PORT_BUSY_4_Pos))
#define UDDRC_PSTAT_WR_PORT_BUSY_0_Pos        _U_(16)                                              /**< (UDDRC_PSTAT) Indicates if there are outstanding writes for AXI port 0. Programming Mode: Dynamic Position */
#define UDDRC_PSTAT_WR_PORT_BUSY_0_Msk        (_U_(0x1) << UDDRC_PSTAT_WR_PORT_BUSY_0_Pos)         /**< (UDDRC_PSTAT) Indicates if there are outstanding writes for AXI port 0. Programming Mode: Dynamic Mask */
#define UDDRC_PSTAT_WR_PORT_BUSY_0(value)     (UDDRC_PSTAT_WR_PORT_BUSY_0_Msk & ((value) << UDDRC_PSTAT_WR_PORT_BUSY_0_Pos))
#define UDDRC_PSTAT_WR_PORT_BUSY_1_Pos        _U_(17)                                              /**< (UDDRC_PSTAT) Indicates if there are outstanding writes for AXI port 1. Programming Mode: Dynamic Position */
#define UDDRC_PSTAT_WR_PORT_BUSY_1_Msk        (_U_(0x1) << UDDRC_PSTAT_WR_PORT_BUSY_1_Pos)         /**< (UDDRC_PSTAT) Indicates if there are outstanding writes for AXI port 1. Programming Mode: Dynamic Mask */
#define UDDRC_PSTAT_WR_PORT_BUSY_1(value)     (UDDRC_PSTAT_WR_PORT_BUSY_1_Msk & ((value) << UDDRC_PSTAT_WR_PORT_BUSY_1_Pos))
#define UDDRC_PSTAT_WR_PORT_BUSY_2_Pos        _U_(18)                                              /**< (UDDRC_PSTAT) Indicates if there are outstanding writes for AXI port 2. Programming Mode: Dynamic Position */
#define UDDRC_PSTAT_WR_PORT_BUSY_2_Msk        (_U_(0x1) << UDDRC_PSTAT_WR_PORT_BUSY_2_Pos)         /**< (UDDRC_PSTAT) Indicates if there are outstanding writes for AXI port 2. Programming Mode: Dynamic Mask */
#define UDDRC_PSTAT_WR_PORT_BUSY_2(value)     (UDDRC_PSTAT_WR_PORT_BUSY_2_Msk & ((value) << UDDRC_PSTAT_WR_PORT_BUSY_2_Pos))
#define UDDRC_PSTAT_WR_PORT_BUSY_3_Pos        _U_(19)                                              /**< (UDDRC_PSTAT) Indicates if there are outstanding writes for AXI port 3. Programming Mode: Dynamic Position */
#define UDDRC_PSTAT_WR_PORT_BUSY_3_Msk        (_U_(0x1) << UDDRC_PSTAT_WR_PORT_BUSY_3_Pos)         /**< (UDDRC_PSTAT) Indicates if there are outstanding writes for AXI port 3. Programming Mode: Dynamic Mask */
#define UDDRC_PSTAT_WR_PORT_BUSY_3(value)     (UDDRC_PSTAT_WR_PORT_BUSY_3_Msk & ((value) << UDDRC_PSTAT_WR_PORT_BUSY_3_Pos))
#define UDDRC_PSTAT_WR_PORT_BUSY_4_Pos        _U_(20)                                              /**< (UDDRC_PSTAT) Indicates if there are outstanding writes for AXI port 4. Programming Mode: Dynamic Position */
#define UDDRC_PSTAT_WR_PORT_BUSY_4_Msk        (_U_(0x1) << UDDRC_PSTAT_WR_PORT_BUSY_4_Pos)         /**< (UDDRC_PSTAT) Indicates if there are outstanding writes for AXI port 4. Programming Mode: Dynamic Mask */
#define UDDRC_PSTAT_WR_PORT_BUSY_4(value)     (UDDRC_PSTAT_WR_PORT_BUSY_4_Msk & ((value) << UDDRC_PSTAT_WR_PORT_BUSY_4_Pos))
#define UDDRC_PSTAT_Msk                       _U_(0x001F001F)                                      /**< (UDDRC_PSTAT) Register Mask  */

#define UDDRC_PSTAT_RD_PORT_BUSY__Pos         _U_(0)                                               /**< (UDDRC_PSTAT Position) Indicates if there are outstanding reads for AXI port x. Programming Mode: Dynamic */
#define UDDRC_PSTAT_RD_PORT_BUSY__Msk         (_U_(0x1F) << UDDRC_PSTAT_RD_PORT_BUSY__Pos)         /**< (UDDRC_PSTAT Mask) RD_PORT_BUSY_ */
#define UDDRC_PSTAT_RD_PORT_BUSY_(value)      (UDDRC_PSTAT_RD_PORT_BUSY__Msk & ((value) << UDDRC_PSTAT_RD_PORT_BUSY__Pos)) 
#define UDDRC_PSTAT_WR_PORT_BUSY__Pos         _U_(16)                                              /**< (UDDRC_PSTAT Position) Indicates if there are outstanding writes for AXI port 4. Programming Mode: Dynamic */
#define UDDRC_PSTAT_WR_PORT_BUSY__Msk         (_U_(0x1F) << UDDRC_PSTAT_WR_PORT_BUSY__Pos)         /**< (UDDRC_PSTAT Mask) WR_PORT_BUSY_ */
#define UDDRC_PSTAT_WR_PORT_BUSY_(value)      (UDDRC_PSTAT_WR_PORT_BUSY__Msk & ((value) << UDDRC_PSTAT_WR_PORT_BUSY__Pos)) 

/* -------- UDDRC_PCCFG : (UDDRC Offset: 0x400) (R/W 32) Port Common Configuration Register -------- */
#define UDDRC_PCCFG_RESETVALUE                _U_(0x00)                                            /**<  (UDDRC_PCCFG) Port Common Configuration Register  Reset Value */

#define UDDRC_PCCFG_GO2CRITICAL_EN_Pos        _U_(0)                                               /**< (UDDRC_PCCFG) If set to 1 (enabled), sets co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals going to DDRC based on urgent input (awurgent, arurgent) coming from AXI master. If set to 0 (disabled), co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals at DDRC are driven to 1b'0.  For uPCTL2, this register field must be set to 0 Programming Mode: Static Position */
#define UDDRC_PCCFG_GO2CRITICAL_EN_Msk        (_U_(0x1) << UDDRC_PCCFG_GO2CRITICAL_EN_Pos)         /**< (UDDRC_PCCFG) If set to 1 (enabled), sets co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals going to DDRC based on urgent input (awurgent, arurgent) coming from AXI master. If set to 0 (disabled), co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals at DDRC are driven to 1b'0.  For uPCTL2, this register field must be set to 0 Programming Mode: Static Mask */
#define UDDRC_PCCFG_GO2CRITICAL_EN(value)     (UDDRC_PCCFG_GO2CRITICAL_EN_Msk & ((value) << UDDRC_PCCFG_GO2CRITICAL_EN_Pos))
#define UDDRC_PCCFG_PAGEMATCH_LIMIT_Pos       _U_(4)                                               /**< (UDDRC_PCCFG) Page match four limit. If set to 1, limits the number of consecutive same page DDRC transactions that can be granted by the Port Arbiter to four when Page Match feature is enabled.       If set to 0, there is no limit imposed on number of consecutive same page DDRC transactions. Programming Mode: Static Position */
#define UDDRC_PCCFG_PAGEMATCH_LIMIT_Msk       (_U_(0x1) << UDDRC_PCCFG_PAGEMATCH_LIMIT_Pos)        /**< (UDDRC_PCCFG) Page match four limit. If set to 1, limits the number of consecutive same page DDRC transactions that can be granted by the Port Arbiter to four when Page Match feature is enabled.       If set to 0, there is no limit imposed on number of consecutive same page DDRC transactions. Programming Mode: Static Mask */
#define UDDRC_PCCFG_PAGEMATCH_LIMIT(value)    (UDDRC_PCCFG_PAGEMATCH_LIMIT_Msk & ((value) << UDDRC_PCCFG_PAGEMATCH_LIMIT_Pos))
#define UDDRC_PCCFG_BL_EXP_MODE_Pos           _U_(8)                                               /**< (UDDRC_PCCFG) Burst length expansion mode. By default (i.e. bl_exp_mode==0) XPI expands every AXI burst into multiple HIF commands, using the memory burst length as a unit. If set to 1, then XPI will use half of the memory burst length as a unit.      This applies to both reads and writes. When MSTR.data_bus_width==00, setting bl_exp_mode to 1 has no effect.      This can be used in cases where Partial Writes is enabled (UMCTL2_PARTIAL_WR=1), in order to avoid or minimize t_ccd_l penalty in DDR4 and t_ccd_mw penalty in LPDDR4. Hence, bl_exp_mode=1 is only recommended if DDR4 or LPDDR4.      Note that if DBICTL.dm_en=0, functionality is not supported in the following cases:     - UMCTL2_PARTIAL_WR=0     - UMCTL2_PARTIAL_WR=1, MSTR.data_bus_width=01, MEMC_BURST_LENGTH=8 and MSTR.burst_rdwr=1000 (LPDDR4 only)     - UMCTL2_PARTIAL_WR=1, MSTR.data_bus_width=01, MEMC_BURST_LENGTH=4 and MSTR.burst_rdwr=0100 (DDR4 only), with either MSTR.burstchop=0 or CRCPARCTL1.crc_enable=1      Functionality is also not supported if Data Channel Interleave is enabled Programming Mode: Static Position */
#define UDDRC_PCCFG_BL_EXP_MODE_Msk           (_U_(0x1) << UDDRC_PCCFG_BL_EXP_MODE_Pos)            /**< (UDDRC_PCCFG) Burst length expansion mode. By default (i.e. bl_exp_mode==0) XPI expands every AXI burst into multiple HIF commands, using the memory burst length as a unit. If set to 1, then XPI will use half of the memory burst length as a unit.      This applies to both reads and writes. When MSTR.data_bus_width==00, setting bl_exp_mode to 1 has no effect.      This can be used in cases where Partial Writes is enabled (UMCTL2_PARTIAL_WR=1), in order to avoid or minimize t_ccd_l penalty in DDR4 and t_ccd_mw penalty in LPDDR4. Hence, bl_exp_mode=1 is only recommended if DDR4 or LPDDR4.      Note that if DBICTL.dm_en=0, functionality is not supported in the following cases:     - UMCTL2_PARTIAL_WR=0     - UMCTL2_PARTIAL_WR=1, MSTR.data_bus_width=01, MEMC_BURST_LENGTH=8 and MSTR.burst_rdwr=1000 (LPDDR4 only)     - UMCTL2_PARTIAL_WR=1, MSTR.data_bus_width=01, MEMC_BURST_LENGTH=4 and MSTR.burst_rdwr=0100 (DDR4 only), with either MSTR.burstchop=0 or CRCPARCTL1.crc_enable=1      Functionality is also not supported if Data Channel Interleave is enabled Programming Mode: Static Mask */
#define UDDRC_PCCFG_BL_EXP_MODE(value)        (UDDRC_PCCFG_BL_EXP_MODE_Msk & ((value) << UDDRC_PCCFG_BL_EXP_MODE_Pos))
#define UDDRC_PCCFG_Msk                       _U_(0x00000111)                                      /**< (UDDRC_PCCFG) Register Mask  */


/* -------- UDDRC_PCFGR_0 : (UDDRC Offset: 0x404) (R/W 32) Port n Configuration Read Register -------- */
#define UDDRC_PCFGR_0_RESETVALUE              _U_(0x4000)                                          /**<  (UDDRC_PCFGR_0) Port n Configuration Read Register  Reset Value */

#define UDDRC_PCFGR_0_RD_PORT_PRIORITY_Pos    _U_(0)                                               /**< (UDDRC_PCFGR_0) Determines the initial load value of read aging counters.   These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not    granted. The higher significant 5-bits of the read aging counter sets the priority of the           read channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease.   When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0).  For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (arqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.  In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority    (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Position */
#define UDDRC_PCFGR_0_RD_PORT_PRIORITY_Msk    (_U_(0x3FF) << UDDRC_PCFGR_0_RD_PORT_PRIORITY_Pos)   /**< (UDDRC_PCFGR_0) Determines the initial load value of read aging counters.   These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not    granted. The higher significant 5-bits of the read aging counter sets the priority of the           read channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease.   When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0).  For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (arqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.  In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority    (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Mask */
#define UDDRC_PCFGR_0_RD_PORT_PRIORITY(value) (UDDRC_PCFGR_0_RD_PORT_PRIORITY_Msk & ((value) << UDDRC_PCFGR_0_RD_PORT_PRIORITY_Pos))
#define UDDRC_PCFGR_0_READ_REORDER_BYPASS_EN_Pos _U_(11)                                              /**< (UDDRC_PCFGR_0) All transactions can be reordered even if ID not found in any RBB channel Position */
#define UDDRC_PCFGR_0_READ_REORDER_BYPASS_EN_Msk (_U_(0x1) << UDDRC_PCFGR_0_READ_REORDER_BYPASS_EN_Pos) /**< (UDDRC_PCFGR_0) All transactions can be reordered even if ID not found in any RBB channel Mask */
#define UDDRC_PCFGR_0_READ_REORDER_BYPASS_EN(value) (UDDRC_PCFGR_0_READ_REORDER_BYPASS_EN_Msk & ((value) << UDDRC_PCFGR_0_READ_REORDER_BYPASS_EN_Pos))
#define UDDRC_PCFGR_0_RD_PORT_AGING_EN_Pos    _U_(12)                                              /**< (UDDRC_PCFGR_0) If set to 1, enables aging function for the read channel of the port. Programming Mode: Static Position */
#define UDDRC_PCFGR_0_RD_PORT_AGING_EN_Msk    (_U_(0x1) << UDDRC_PCFGR_0_RD_PORT_AGING_EN_Pos)     /**< (UDDRC_PCFGR_0) If set to 1, enables aging function for the read channel of the port. Programming Mode: Static Mask */
#define UDDRC_PCFGR_0_RD_PORT_AGING_EN(value) (UDDRC_PCFGR_0_RD_PORT_AGING_EN_Msk & ((value) << UDDRC_PCFGR_0_RD_PORT_AGING_EN_Pos))
#define UDDRC_PCFGR_0_RD_PORT_URGENT_EN_Pos   _U_(13)                                              /**< (UDDRC_PCFGR_0) If set to 1, enables the AXI urgent sideband signal (arurgent). When enabled and arurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Position */
#define UDDRC_PCFGR_0_RD_PORT_URGENT_EN_Msk   (_U_(0x1) << UDDRC_PCFGR_0_RD_PORT_URGENT_EN_Pos)    /**< (UDDRC_PCFGR_0) If set to 1, enables the AXI urgent sideband signal (arurgent). When enabled and arurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Mask */
#define UDDRC_PCFGR_0_RD_PORT_URGENT_EN(value) (UDDRC_PCFGR_0_RD_PORT_URGENT_EN_Msk & ((value) << UDDRC_PCFGR_0_RD_PORT_URGENT_EN_Pos))
#define UDDRC_PCFGR_0_RD_PORT_PAGEMATCH_EN_Pos _U_(14)                                              /**< (UDDRC_PCFGR_0) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Position */
#define UDDRC_PCFGR_0_RD_PORT_PAGEMATCH_EN_Msk (_U_(0x1) << UDDRC_PCFGR_0_RD_PORT_PAGEMATCH_EN_Pos) /**< (UDDRC_PCFGR_0) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Mask */
#define UDDRC_PCFGR_0_RD_PORT_PAGEMATCH_EN(value) (UDDRC_PCFGR_0_RD_PORT_PAGEMATCH_EN_Msk & ((value) << UDDRC_PCFGR_0_RD_PORT_PAGEMATCH_EN_Pos))
#define UDDRC_PCFGR_0_RDWR_ORDERED_EN_Pos     _U_(16)                                              /**< (UDDRC_PCFGR_0) Read/Write AXI transactions acceptance ordering to the same address on a giben port will not be respected when transported to  the DFI Position */
#define UDDRC_PCFGR_0_RDWR_ORDERED_EN_Msk     (_U_(0x1) << UDDRC_PCFGR_0_RDWR_ORDERED_EN_Pos)      /**< (UDDRC_PCFGR_0) Read/Write AXI transactions acceptance ordering to the same address on a giben port will not be respected when transported to  the DFI Mask */
#define UDDRC_PCFGR_0_RDWR_ORDERED_EN(value)  (UDDRC_PCFGR_0_RDWR_ORDERED_EN_Msk & ((value) << UDDRC_PCFGR_0_RDWR_ORDERED_EN_Pos))
#define UDDRC_PCFGR_0_Msk                     _U_(0x00017BFF)                                      /**< (UDDRC_PCFGR_0) Register Mask  */


/* -------- UDDRC_PCFGW_0 : (UDDRC Offset: 0x408) (R/W 32) Port n Configuration Write Register -------- */
#define UDDRC_PCFGW_0_RESETVALUE              _U_(0x4000)                                          /**<  (UDDRC_PCFGW_0) Port n Configuration Write Register  Reset Value */

#define UDDRC_PCFGW_0_WR_PORT_PRIORITY_Pos    _U_(0)                                               /**< (UDDRC_PCFGW_0) Determines the initial load value of write aging counters.  These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not   granted. The higher significant 5-bits of the write aging counter sets the initial priority of the           write channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level.   For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (awqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Position */
#define UDDRC_PCFGW_0_WR_PORT_PRIORITY_Msk    (_U_(0x3FF) << UDDRC_PCFGW_0_WR_PORT_PRIORITY_Pos)   /**< (UDDRC_PCFGW_0) Determines the initial load value of write aging counters.  These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not   granted. The higher significant 5-bits of the write aging counter sets the initial priority of the           write channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level.   For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (awqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Mask */
#define UDDRC_PCFGW_0_WR_PORT_PRIORITY(value) (UDDRC_PCFGW_0_WR_PORT_PRIORITY_Msk & ((value) << UDDRC_PCFGW_0_WR_PORT_PRIORITY_Pos))
#define UDDRC_PCFGW_0_WR_PORT_AGING_EN_Pos    _U_(12)                                              /**< (UDDRC_PCFGW_0) If set to 1, enables aging function for the write channel of the port. Programming Mode: Static Position */
#define UDDRC_PCFGW_0_WR_PORT_AGING_EN_Msk    (_U_(0x1) << UDDRC_PCFGW_0_WR_PORT_AGING_EN_Pos)     /**< (UDDRC_PCFGW_0) If set to 1, enables aging function for the write channel of the port. Programming Mode: Static Mask */
#define UDDRC_PCFGW_0_WR_PORT_AGING_EN(value) (UDDRC_PCFGW_0_WR_PORT_AGING_EN_Msk & ((value) << UDDRC_PCFGW_0_WR_PORT_AGING_EN_Pos))
#define UDDRC_PCFGW_0_WR_PORT_URGENT_EN_Pos   _U_(13)                                              /**< (UDDRC_PCFGW_0) If set to 1, enables the AXI urgent sideband signal (awurgent). When enabled and awurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register.  Note that awurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Position */
#define UDDRC_PCFGW_0_WR_PORT_URGENT_EN_Msk   (_U_(0x1) << UDDRC_PCFGW_0_WR_PORT_URGENT_EN_Pos)    /**< (UDDRC_PCFGW_0) If set to 1, enables the AXI urgent sideband signal (awurgent). When enabled and awurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register.  Note that awurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Mask */
#define UDDRC_PCFGW_0_WR_PORT_URGENT_EN(value) (UDDRC_PCFGW_0_WR_PORT_URGENT_EN_Msk & ((value) << UDDRC_PCFGW_0_WR_PORT_URGENT_EN_Pos))
#define UDDRC_PCFGW_0_WR_PORT_PAGEMATCH_EN_Pos _U_(14)                                              /**< (UDDRC_PCFGW_0) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Position */
#define UDDRC_PCFGW_0_WR_PORT_PAGEMATCH_EN_Msk (_U_(0x1) << UDDRC_PCFGW_0_WR_PORT_PAGEMATCH_EN_Pos) /**< (UDDRC_PCFGW_0) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Mask */
#define UDDRC_PCFGW_0_WR_PORT_PAGEMATCH_EN(value) (UDDRC_PCFGW_0_WR_PORT_PAGEMATCH_EN_Msk & ((value) << UDDRC_PCFGW_0_WR_PORT_PAGEMATCH_EN_Pos))
#define UDDRC_PCFGW_0_Msk                     _U_(0x000073FF)                                      /**< (UDDRC_PCFGW_0) Register Mask  */


/* -------- UDDRC_PCTRL_0 : (UDDRC Offset: 0x490) (R/W 32) Port n Control Register -------- */
#define UDDRC_PCTRL_0_RESETVALUE              _U_(0x00)                                            /**<  (UDDRC_PCTRL_0) Port n Control Register  Reset Value */

#define UDDRC_PCTRL_0_PORT_EN_Pos             _U_(0)                                               /**< (UDDRC_PCTRL_0) Enables AXI port n. Programming Mode: Dynamic Position */
#define UDDRC_PCTRL_0_PORT_EN_Msk             (_U_(0x1) << UDDRC_PCTRL_0_PORT_EN_Pos)              /**< (UDDRC_PCTRL_0) Enables AXI port n. Programming Mode: Dynamic Mask */
#define UDDRC_PCTRL_0_PORT_EN(value)          (UDDRC_PCTRL_0_PORT_EN_Msk & ((value) << UDDRC_PCTRL_0_PORT_EN_Pos))
#define UDDRC_PCTRL_0_Msk                     _U_(0x00000001)                                      /**< (UDDRC_PCTRL_0) Register Mask  */


/* -------- UDDRC_PCFGQOS0_0 : (UDDRC Offset: 0x494) (R/W 32) Port n Read QoS Configuration Register 0 -------- */
#define UDDRC_PCFGQOS0_0_RESETVALUE           _U_(0x00)                                            /**<  (UDDRC_PCFGQOS0_0) Port n Read QoS Configuration Register 0  Reset Value */

#define UDDRC_PCFGQOS0_0_RQOS_MAP_LEVEL1_Pos  _U_(0)                                               /**< (UDDRC_PCFGQOS0_0) Separation level1 indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos.           Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_0_RQOS_MAP_LEVEL1_Msk  (_U_(0xF) << UDDRC_PCFGQOS0_0_RQOS_MAP_LEVEL1_Pos)   /**< (UDDRC_PCFGQOS0_0) Separation level1 indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos.           Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_0_RQOS_MAP_LEVEL1(value) (UDDRC_PCFGQOS0_0_RQOS_MAP_LEVEL1_Msk & ((value) << UDDRC_PCFGQOS0_0_RQOS_MAP_LEVEL1_Pos))
#define UDDRC_PCFGQOS0_0_RQOS_MAP_REGION0_Pos _U_(16)                                              /**< (UDDRC_PCFGQOS0_0) This bitfield indicates the traffic class of region 0.  Valid values are:  - 0: LPR  - 1: VPR  - 2: HPR For dual address queue configurations, region 0 maps to the blue address queue.  In this case, valid values are:  0: LPR and 1: VPR only.  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_0_RQOS_MAP_REGION0_Msk (_U_(0x3) << UDDRC_PCFGQOS0_0_RQOS_MAP_REGION0_Pos)  /**< (UDDRC_PCFGQOS0_0) This bitfield indicates the traffic class of region 0.  Valid values are:  - 0: LPR  - 1: VPR  - 2: HPR For dual address queue configurations, region 0 maps to the blue address queue.  In this case, valid values are:  0: LPR and 1: VPR only.  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_0_RQOS_MAP_REGION0(value) (UDDRC_PCFGQOS0_0_RQOS_MAP_REGION0_Msk & ((value) << UDDRC_PCFGQOS0_0_RQOS_MAP_REGION0_Pos))
#define UDDRC_PCFGQOS0_0_RQOS_MAP_REGION1_Pos _U_(20)                                              /**< (UDDRC_PCFGQOS0_0) This bitfield indicates the traffic class of region 1.  Valid values are:  - 0 : LPR  - 1: VPR  - 2: HPR  For dual address queue configurations, region1 maps to the blue address queue.  In this case, valid values are   - 0: LPR  - 1: VPR only  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_0_RQOS_MAP_REGION1_Msk (_U_(0x3) << UDDRC_PCFGQOS0_0_RQOS_MAP_REGION1_Pos)  /**< (UDDRC_PCFGQOS0_0) This bitfield indicates the traffic class of region 1.  Valid values are:  - 0 : LPR  - 1: VPR  - 2: HPR  For dual address queue configurations, region1 maps to the blue address queue.  In this case, valid values are   - 0: LPR  - 1: VPR only  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_0_RQOS_MAP_REGION1(value) (UDDRC_PCFGQOS0_0_RQOS_MAP_REGION1_Msk & ((value) << UDDRC_PCFGQOS0_0_RQOS_MAP_REGION1_Pos))
#define UDDRC_PCFGQOS0_0_Msk                  _U_(0x0033000F)                                      /**< (UDDRC_PCFGQOS0_0) Register Mask  */


/* -------- UDDRC_PCFGQOS1_0 : (UDDRC Offset: 0x498) (R/W 32) Port n Read QoS Configuration Register 1 -------- */
#define UDDRC_PCFGQOS1_0_RESETVALUE           _U_(0x00)                                            /**<  (UDDRC_PCFGQOS1_0) Port n Read QoS Configuration Register 1  Reset Value */

#define UDDRC_PCFGQOS1_0_RQOS_MAP_TIMEOUTB_Pos _U_(0)                                               /**< (UDDRC_PCFGQOS1_0) Specifies the timeout value for transactions mapped to the blue address queue. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS1_0_RQOS_MAP_TIMEOUTB_Msk (_U_(0x7FF) << UDDRC_PCFGQOS1_0_RQOS_MAP_TIMEOUTB_Pos) /**< (UDDRC_PCFGQOS1_0) Specifies the timeout value for transactions mapped to the blue address queue. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS1_0_RQOS_MAP_TIMEOUTB(value) (UDDRC_PCFGQOS1_0_RQOS_MAP_TIMEOUTB_Msk & ((value) << UDDRC_PCFGQOS1_0_RQOS_MAP_TIMEOUTB_Pos))
#define UDDRC_PCFGQOS1_0_RQOS_MAP_TIMEOUTR_Pos _U_(16)                                              /**< (UDDRC_PCFGQOS1_0) Specifies the timeout value for transactions mapped to the red address queue. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS1_0_RQOS_MAP_TIMEOUTR_Msk (_U_(0x7FF) << UDDRC_PCFGQOS1_0_RQOS_MAP_TIMEOUTR_Pos) /**< (UDDRC_PCFGQOS1_0) Specifies the timeout value for transactions mapped to the red address queue. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS1_0_RQOS_MAP_TIMEOUTR(value) (UDDRC_PCFGQOS1_0_RQOS_MAP_TIMEOUTR_Msk & ((value) << UDDRC_PCFGQOS1_0_RQOS_MAP_TIMEOUTR_Pos))
#define UDDRC_PCFGQOS1_0_Msk                  _U_(0x07FF07FF)                                      /**< (UDDRC_PCFGQOS1_0) Register Mask  */


/* -------- UDDRC_PCFGWQOS0_0 : (UDDRC Offset: 0x49C) (R/W 32) Port n Write QoS Configuration Register 0 -------- */
#define UDDRC_PCFGWQOS0_0_RESETVALUE          _U_(0xE00)                                           /**<  (UDDRC_PCFGWQOS0_0) Port n Write QoS Configuration Register 0  Reset Value */

#define UDDRC_PCFGWQOS0_0_WQOS_MAP_LEVEL1_Pos _U_(0)                                               /**< (UDDRC_PCFGWQOS0_0) Separation level indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds to awqos.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_0_WQOS_MAP_LEVEL1_Msk (_U_(0xF) << UDDRC_PCFGWQOS0_0_WQOS_MAP_LEVEL1_Pos)  /**< (UDDRC_PCFGWQOS0_0) Separation level indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds to awqos.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_0_WQOS_MAP_LEVEL1(value) (UDDRC_PCFGWQOS0_0_WQOS_MAP_LEVEL1_Msk & ((value) << UDDRC_PCFGWQOS0_0_WQOS_MAP_LEVEL1_Pos))
#define UDDRC_PCFGWQOS0_0_WQOS_MAP_LEVEL2_Pos _U_(8)                                               /**< (UDDRC_PCFGWQOS0_0) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to awqos.  Region2 starts from (level2 + 1) up to 15.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_0_WQOS_MAP_LEVEL2_Msk (_U_(0xF) << UDDRC_PCFGWQOS0_0_WQOS_MAP_LEVEL2_Pos)  /**< (UDDRC_PCFGWQOS0_0) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to awqos.  Region2 starts from (level2 + 1) up to 15.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_0_WQOS_MAP_LEVEL2(value) (UDDRC_PCFGWQOS0_0_WQOS_MAP_LEVEL2_Msk & ((value) << UDDRC_PCFGWQOS0_0_WQOS_MAP_LEVEL2_Pos))
#define UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION0_Pos _U_(16)                                              /**< (UDDRC_PCFGWQOS0_0) This bitfield indicates the traffic class of region 0.     Valid values are:      0: NPW, 1: VPW.        When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION0_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION0_Pos) /**< (UDDRC_PCFGWQOS0_0) This bitfield indicates the traffic class of region 0.     Valid values are:      0: NPW, 1: VPW.        When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION0(value) (UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION0_Msk & ((value) << UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION0_Pos))
#define UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION1_Pos _U_(20)                                              /**< (UDDRC_PCFGWQOS0_0) This bitfield indicates the traffic class of region 1.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION1_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION1_Pos) /**< (UDDRC_PCFGWQOS0_0) This bitfield indicates the traffic class of region 1.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION1(value) (UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION1_Msk & ((value) << UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION1_Pos))
#define UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION2_Pos _U_(24)                                              /**< (UDDRC_PCFGWQOS0_0) This bitfield indicates the traffic class of region 2.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION2_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION2_Pos) /**< (UDDRC_PCFGWQOS0_0) This bitfield indicates the traffic class of region 2.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION2(value) (UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION2_Msk & ((value) << UDDRC_PCFGWQOS0_0_WQOS_MAP_REGION2_Pos))
#define UDDRC_PCFGWQOS0_0_Msk                 _U_(0x03330F0F)                                      /**< (UDDRC_PCFGWQOS0_0) Register Mask  */


/* -------- UDDRC_PCFGWQOS1_0 : (UDDRC Offset: 0x4A0) (R/W 32) Port n Write QoS Configuration Register 1 -------- */
#define UDDRC_PCFGWQOS1_0_RESETVALUE          _U_(0x00)                                            /**<  (UDDRC_PCFGWQOS1_0) Port n Write QoS Configuration Register 1  Reset Value */

#define UDDRC_PCFGWQOS1_0_WQOS_MAP_TIMEOUT1_Pos _U_(0)                                               /**< (UDDRC_PCFGWQOS1_0) Specifies the timeout value for write transactions in region 0 and 1. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS1_0_WQOS_MAP_TIMEOUT1_Msk (_U_(0x7FF) << UDDRC_PCFGWQOS1_0_WQOS_MAP_TIMEOUT1_Pos) /**< (UDDRC_PCFGWQOS1_0) Specifies the timeout value for write transactions in region 0 and 1. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS1_0_WQOS_MAP_TIMEOUT1(value) (UDDRC_PCFGWQOS1_0_WQOS_MAP_TIMEOUT1_Msk & ((value) << UDDRC_PCFGWQOS1_0_WQOS_MAP_TIMEOUT1_Pos))
#define UDDRC_PCFGWQOS1_0_WQOS_MAP_TIMEOUT2_Pos _U_(16)                                              /**< (UDDRC_PCFGWQOS1_0) Specifies the timeout value for write transactions in region 2. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS1_0_WQOS_MAP_TIMEOUT2_Msk (_U_(0x7FF) << UDDRC_PCFGWQOS1_0_WQOS_MAP_TIMEOUT2_Pos) /**< (UDDRC_PCFGWQOS1_0) Specifies the timeout value for write transactions in region 2. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS1_0_WQOS_MAP_TIMEOUT2(value) (UDDRC_PCFGWQOS1_0_WQOS_MAP_TIMEOUT2_Msk & ((value) << UDDRC_PCFGWQOS1_0_WQOS_MAP_TIMEOUT2_Pos))
#define UDDRC_PCFGWQOS1_0_Msk                 _U_(0x07FF07FF)                                      /**< (UDDRC_PCFGWQOS1_0) Register Mask  */


/* -------- UDDRC_PCFGR_1 : (UDDRC Offset: 0x4B4) (R/W 32) Port n Configuration Read Register -------- */
#define UDDRC_PCFGR_1_RESETVALUE              _U_(0x4000)                                          /**<  (UDDRC_PCFGR_1) Port n Configuration Read Register  Reset Value */

#define UDDRC_PCFGR_1_RD_PORT_PRIORITY_Pos    _U_(0)                                               /**< (UDDRC_PCFGR_1) Determines the initial load value of read aging counters.   These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not    granted. The higher significant 5-bits of the read aging counter sets the priority of the           read channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease.   When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0).  For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (arqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.  In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority    (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Position */
#define UDDRC_PCFGR_1_RD_PORT_PRIORITY_Msk    (_U_(0x3FF) << UDDRC_PCFGR_1_RD_PORT_PRIORITY_Pos)   /**< (UDDRC_PCFGR_1) Determines the initial load value of read aging counters.   These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not    granted. The higher significant 5-bits of the read aging counter sets the priority of the           read channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease.   When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0).  For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (arqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.  In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority    (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Mask */
#define UDDRC_PCFGR_1_RD_PORT_PRIORITY(value) (UDDRC_PCFGR_1_RD_PORT_PRIORITY_Msk & ((value) << UDDRC_PCFGR_1_RD_PORT_PRIORITY_Pos))
#define UDDRC_PCFGR_1_READ_REORDER_BYPASS_EN_Pos _U_(11)                                              /**< (UDDRC_PCFGR_1) All transactions can be reordered even if ID not found in any RBB channel Position */
#define UDDRC_PCFGR_1_READ_REORDER_BYPASS_EN_Msk (_U_(0x1) << UDDRC_PCFGR_1_READ_REORDER_BYPASS_EN_Pos) /**< (UDDRC_PCFGR_1) All transactions can be reordered even if ID not found in any RBB channel Mask */
#define UDDRC_PCFGR_1_READ_REORDER_BYPASS_EN(value) (UDDRC_PCFGR_1_READ_REORDER_BYPASS_EN_Msk & ((value) << UDDRC_PCFGR_1_READ_REORDER_BYPASS_EN_Pos))
#define UDDRC_PCFGR_1_RD_PORT_AGING_EN_Pos    _U_(12)                                              /**< (UDDRC_PCFGR_1) If set to 1, enables aging function for the read channel of the port. Programming Mode: Static Position */
#define UDDRC_PCFGR_1_RD_PORT_AGING_EN_Msk    (_U_(0x1) << UDDRC_PCFGR_1_RD_PORT_AGING_EN_Pos)     /**< (UDDRC_PCFGR_1) If set to 1, enables aging function for the read channel of the port. Programming Mode: Static Mask */
#define UDDRC_PCFGR_1_RD_PORT_AGING_EN(value) (UDDRC_PCFGR_1_RD_PORT_AGING_EN_Msk & ((value) << UDDRC_PCFGR_1_RD_PORT_AGING_EN_Pos))
#define UDDRC_PCFGR_1_RD_PORT_URGENT_EN_Pos   _U_(13)                                              /**< (UDDRC_PCFGR_1) If set to 1, enables the AXI urgent sideband signal (arurgent). When enabled and arurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Position */
#define UDDRC_PCFGR_1_RD_PORT_URGENT_EN_Msk   (_U_(0x1) << UDDRC_PCFGR_1_RD_PORT_URGENT_EN_Pos)    /**< (UDDRC_PCFGR_1) If set to 1, enables the AXI urgent sideband signal (arurgent). When enabled and arurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Mask */
#define UDDRC_PCFGR_1_RD_PORT_URGENT_EN(value) (UDDRC_PCFGR_1_RD_PORT_URGENT_EN_Msk & ((value) << UDDRC_PCFGR_1_RD_PORT_URGENT_EN_Pos))
#define UDDRC_PCFGR_1_RD_PORT_PAGEMATCH_EN_Pos _U_(14)                                              /**< (UDDRC_PCFGR_1) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Position */
#define UDDRC_PCFGR_1_RD_PORT_PAGEMATCH_EN_Msk (_U_(0x1) << UDDRC_PCFGR_1_RD_PORT_PAGEMATCH_EN_Pos) /**< (UDDRC_PCFGR_1) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Mask */
#define UDDRC_PCFGR_1_RD_PORT_PAGEMATCH_EN(value) (UDDRC_PCFGR_1_RD_PORT_PAGEMATCH_EN_Msk & ((value) << UDDRC_PCFGR_1_RD_PORT_PAGEMATCH_EN_Pos))
#define UDDRC_PCFGR_1_RDWR_ORDERED_EN_Pos     _U_(16)                                              /**< (UDDRC_PCFGR_1) Read/Write AXI transactions acceptance ordering to the same address on a giben port will not be respected when transported to  the DFI Position */
#define UDDRC_PCFGR_1_RDWR_ORDERED_EN_Msk     (_U_(0x1) << UDDRC_PCFGR_1_RDWR_ORDERED_EN_Pos)      /**< (UDDRC_PCFGR_1) Read/Write AXI transactions acceptance ordering to the same address on a giben port will not be respected when transported to  the DFI Mask */
#define UDDRC_PCFGR_1_RDWR_ORDERED_EN(value)  (UDDRC_PCFGR_1_RDWR_ORDERED_EN_Msk & ((value) << UDDRC_PCFGR_1_RDWR_ORDERED_EN_Pos))
#define UDDRC_PCFGR_1_Msk                     _U_(0x00017BFF)                                      /**< (UDDRC_PCFGR_1) Register Mask  */


/* -------- UDDRC_PCFGW_1 : (UDDRC Offset: 0x4B8) (R/W 32) Port n Configuration Write Register -------- */
#define UDDRC_PCFGW_1_RESETVALUE              _U_(0x4000)                                          /**<  (UDDRC_PCFGW_1) Port n Configuration Write Register  Reset Value */

#define UDDRC_PCFGW_1_WR_PORT_PRIORITY_Pos    _U_(0)                                               /**< (UDDRC_PCFGW_1) Determines the initial load value of write aging counters.  These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not   granted. The higher significant 5-bits of the write aging counter sets the initial priority of the           write channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level.   For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (awqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Position */
#define UDDRC_PCFGW_1_WR_PORT_PRIORITY_Msk    (_U_(0x3FF) << UDDRC_PCFGW_1_WR_PORT_PRIORITY_Pos)   /**< (UDDRC_PCFGW_1) Determines the initial load value of write aging counters.  These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not   granted. The higher significant 5-bits of the write aging counter sets the initial priority of the           write channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level.   For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (awqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Mask */
#define UDDRC_PCFGW_1_WR_PORT_PRIORITY(value) (UDDRC_PCFGW_1_WR_PORT_PRIORITY_Msk & ((value) << UDDRC_PCFGW_1_WR_PORT_PRIORITY_Pos))
#define UDDRC_PCFGW_1_WR_PORT_AGING_EN_Pos    _U_(12)                                              /**< (UDDRC_PCFGW_1) If set to 1, enables aging function for the write channel of the port. Programming Mode: Static Position */
#define UDDRC_PCFGW_1_WR_PORT_AGING_EN_Msk    (_U_(0x1) << UDDRC_PCFGW_1_WR_PORT_AGING_EN_Pos)     /**< (UDDRC_PCFGW_1) If set to 1, enables aging function for the write channel of the port. Programming Mode: Static Mask */
#define UDDRC_PCFGW_1_WR_PORT_AGING_EN(value) (UDDRC_PCFGW_1_WR_PORT_AGING_EN_Msk & ((value) << UDDRC_PCFGW_1_WR_PORT_AGING_EN_Pos))
#define UDDRC_PCFGW_1_WR_PORT_URGENT_EN_Pos   _U_(13)                                              /**< (UDDRC_PCFGW_1) If set to 1, enables the AXI urgent sideband signal (awurgent). When enabled and awurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register.  Note that awurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Position */
#define UDDRC_PCFGW_1_WR_PORT_URGENT_EN_Msk   (_U_(0x1) << UDDRC_PCFGW_1_WR_PORT_URGENT_EN_Pos)    /**< (UDDRC_PCFGW_1) If set to 1, enables the AXI urgent sideband signal (awurgent). When enabled and awurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register.  Note that awurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Mask */
#define UDDRC_PCFGW_1_WR_PORT_URGENT_EN(value) (UDDRC_PCFGW_1_WR_PORT_URGENT_EN_Msk & ((value) << UDDRC_PCFGW_1_WR_PORT_URGENT_EN_Pos))
#define UDDRC_PCFGW_1_WR_PORT_PAGEMATCH_EN_Pos _U_(14)                                              /**< (UDDRC_PCFGW_1) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Position */
#define UDDRC_PCFGW_1_WR_PORT_PAGEMATCH_EN_Msk (_U_(0x1) << UDDRC_PCFGW_1_WR_PORT_PAGEMATCH_EN_Pos) /**< (UDDRC_PCFGW_1) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Mask */
#define UDDRC_PCFGW_1_WR_PORT_PAGEMATCH_EN(value) (UDDRC_PCFGW_1_WR_PORT_PAGEMATCH_EN_Msk & ((value) << UDDRC_PCFGW_1_WR_PORT_PAGEMATCH_EN_Pos))
#define UDDRC_PCFGW_1_Msk                     _U_(0x000073FF)                                      /**< (UDDRC_PCFGW_1) Register Mask  */


/* -------- UDDRC_PCTRL_1 : (UDDRC Offset: 0x540) (R/W 32) Port n Control Register -------- */
#define UDDRC_PCTRL_1_RESETVALUE              _U_(0x00)                                            /**<  (UDDRC_PCTRL_1) Port n Control Register  Reset Value */

#define UDDRC_PCTRL_1_PORT_EN_Pos             _U_(0)                                               /**< (UDDRC_PCTRL_1) Enables AXI port n. Programming Mode: Dynamic Position */
#define UDDRC_PCTRL_1_PORT_EN_Msk             (_U_(0x1) << UDDRC_PCTRL_1_PORT_EN_Pos)              /**< (UDDRC_PCTRL_1) Enables AXI port n. Programming Mode: Dynamic Mask */
#define UDDRC_PCTRL_1_PORT_EN(value)          (UDDRC_PCTRL_1_PORT_EN_Msk & ((value) << UDDRC_PCTRL_1_PORT_EN_Pos))
#define UDDRC_PCTRL_1_Msk                     _U_(0x00000001)                                      /**< (UDDRC_PCTRL_1) Register Mask  */


/* -------- UDDRC_PCFGQOS0_1 : (UDDRC Offset: 0x544) (R/W 32) Port n Read QoS Configuration Register 0 -------- */
#define UDDRC_PCFGQOS0_1_RESETVALUE           _U_(0x00)                                            /**<  (UDDRC_PCFGQOS0_1) Port n Read QoS Configuration Register 0  Reset Value */

#define UDDRC_PCFGQOS0_1_RQOS_MAP_LEVEL1_Pos  _U_(0)                                               /**< (UDDRC_PCFGQOS0_1) Separation level1 indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos.           Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_1_RQOS_MAP_LEVEL1_Msk  (_U_(0xF) << UDDRC_PCFGQOS0_1_RQOS_MAP_LEVEL1_Pos)   /**< (UDDRC_PCFGQOS0_1) Separation level1 indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos.           Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_1_RQOS_MAP_LEVEL1(value) (UDDRC_PCFGQOS0_1_RQOS_MAP_LEVEL1_Msk & ((value) << UDDRC_PCFGQOS0_1_RQOS_MAP_LEVEL1_Pos))
#define UDDRC_PCFGQOS0_1_RQOS_MAP_REGION0_Pos _U_(16)                                              /**< (UDDRC_PCFGQOS0_1) This bitfield indicates the traffic class of region 0.  Valid values are:  - 0: LPR  - 1: VPR  - 2: HPR For dual address queue configurations, region 0 maps to the blue address queue.  In this case, valid values are:  0: LPR and 1: VPR only.  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_1_RQOS_MAP_REGION0_Msk (_U_(0x3) << UDDRC_PCFGQOS0_1_RQOS_MAP_REGION0_Pos)  /**< (UDDRC_PCFGQOS0_1) This bitfield indicates the traffic class of region 0.  Valid values are:  - 0: LPR  - 1: VPR  - 2: HPR For dual address queue configurations, region 0 maps to the blue address queue.  In this case, valid values are:  0: LPR and 1: VPR only.  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_1_RQOS_MAP_REGION0(value) (UDDRC_PCFGQOS0_1_RQOS_MAP_REGION0_Msk & ((value) << UDDRC_PCFGQOS0_1_RQOS_MAP_REGION0_Pos))
#define UDDRC_PCFGQOS0_1_RQOS_MAP_REGION1_Pos _U_(20)                                              /**< (UDDRC_PCFGQOS0_1) This bitfield indicates the traffic class of region 1.  Valid values are:  - 0 : LPR  - 1: VPR  - 2: HPR  For dual address queue configurations, region1 maps to the blue address queue.  In this case, valid values are   - 0: LPR  - 1: VPR only  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_1_RQOS_MAP_REGION1_Msk (_U_(0x3) << UDDRC_PCFGQOS0_1_RQOS_MAP_REGION1_Pos)  /**< (UDDRC_PCFGQOS0_1) This bitfield indicates the traffic class of region 1.  Valid values are:  - 0 : LPR  - 1: VPR  - 2: HPR  For dual address queue configurations, region1 maps to the blue address queue.  In this case, valid values are   - 0: LPR  - 1: VPR only  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_1_RQOS_MAP_REGION1(value) (UDDRC_PCFGQOS0_1_RQOS_MAP_REGION1_Msk & ((value) << UDDRC_PCFGQOS0_1_RQOS_MAP_REGION1_Pos))
#define UDDRC_PCFGQOS0_1_Msk                  _U_(0x0033000F)                                      /**< (UDDRC_PCFGQOS0_1) Register Mask  */


/* -------- UDDRC_PCFGQOS1_1 : (UDDRC Offset: 0x548) (R/W 32) Port n Read QoS Configuration Register 1 -------- */
#define UDDRC_PCFGQOS1_1_RESETVALUE           _U_(0x00)                                            /**<  (UDDRC_PCFGQOS1_1) Port n Read QoS Configuration Register 1  Reset Value */

#define UDDRC_PCFGQOS1_1_RQOS_MAP_TIMEOUTB_Pos _U_(0)                                               /**< (UDDRC_PCFGQOS1_1) Specifies the timeout value for transactions mapped to the blue address queue. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS1_1_RQOS_MAP_TIMEOUTB_Msk (_U_(0x7FF) << UDDRC_PCFGQOS1_1_RQOS_MAP_TIMEOUTB_Pos) /**< (UDDRC_PCFGQOS1_1) Specifies the timeout value for transactions mapped to the blue address queue. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS1_1_RQOS_MAP_TIMEOUTB(value) (UDDRC_PCFGQOS1_1_RQOS_MAP_TIMEOUTB_Msk & ((value) << UDDRC_PCFGQOS1_1_RQOS_MAP_TIMEOUTB_Pos))
#define UDDRC_PCFGQOS1_1_RQOS_MAP_TIMEOUTR_Pos _U_(16)                                              /**< (UDDRC_PCFGQOS1_1) Specifies the timeout value for transactions mapped to the red address queue. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS1_1_RQOS_MAP_TIMEOUTR_Msk (_U_(0x7FF) << UDDRC_PCFGQOS1_1_RQOS_MAP_TIMEOUTR_Pos) /**< (UDDRC_PCFGQOS1_1) Specifies the timeout value for transactions mapped to the red address queue. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS1_1_RQOS_MAP_TIMEOUTR(value) (UDDRC_PCFGQOS1_1_RQOS_MAP_TIMEOUTR_Msk & ((value) << UDDRC_PCFGQOS1_1_RQOS_MAP_TIMEOUTR_Pos))
#define UDDRC_PCFGQOS1_1_Msk                  _U_(0x07FF07FF)                                      /**< (UDDRC_PCFGQOS1_1) Register Mask  */


/* -------- UDDRC_PCFGWQOS0_1 : (UDDRC Offset: 0x54C) (R/W 32) Port n Write QoS Configuration Register 0 -------- */
#define UDDRC_PCFGWQOS0_1_RESETVALUE          _U_(0xE00)                                           /**<  (UDDRC_PCFGWQOS0_1) Port n Write QoS Configuration Register 0  Reset Value */

#define UDDRC_PCFGWQOS0_1_WQOS_MAP_LEVEL1_Pos _U_(0)                                               /**< (UDDRC_PCFGWQOS0_1) Separation level indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds to awqos.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_1_WQOS_MAP_LEVEL1_Msk (_U_(0xF) << UDDRC_PCFGWQOS0_1_WQOS_MAP_LEVEL1_Pos)  /**< (UDDRC_PCFGWQOS0_1) Separation level indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds to awqos.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_1_WQOS_MAP_LEVEL1(value) (UDDRC_PCFGWQOS0_1_WQOS_MAP_LEVEL1_Msk & ((value) << UDDRC_PCFGWQOS0_1_WQOS_MAP_LEVEL1_Pos))
#define UDDRC_PCFGWQOS0_1_WQOS_MAP_LEVEL2_Pos _U_(8)                                               /**< (UDDRC_PCFGWQOS0_1) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to awqos.  Region2 starts from (level2 + 1) up to 15.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_1_WQOS_MAP_LEVEL2_Msk (_U_(0xF) << UDDRC_PCFGWQOS0_1_WQOS_MAP_LEVEL2_Pos)  /**< (UDDRC_PCFGWQOS0_1) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to awqos.  Region2 starts from (level2 + 1) up to 15.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_1_WQOS_MAP_LEVEL2(value) (UDDRC_PCFGWQOS0_1_WQOS_MAP_LEVEL2_Msk & ((value) << UDDRC_PCFGWQOS0_1_WQOS_MAP_LEVEL2_Pos))
#define UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION0_Pos _U_(16)                                              /**< (UDDRC_PCFGWQOS0_1) This bitfield indicates the traffic class of region 0.     Valid values are:      0: NPW, 1: VPW.        When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION0_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION0_Pos) /**< (UDDRC_PCFGWQOS0_1) This bitfield indicates the traffic class of region 0.     Valid values are:      0: NPW, 1: VPW.        When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION0(value) (UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION0_Msk & ((value) << UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION0_Pos))
#define UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION1_Pos _U_(20)                                              /**< (UDDRC_PCFGWQOS0_1) This bitfield indicates the traffic class of region 1.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION1_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION1_Pos) /**< (UDDRC_PCFGWQOS0_1) This bitfield indicates the traffic class of region 1.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION1(value) (UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION1_Msk & ((value) << UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION1_Pos))
#define UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION2_Pos _U_(24)                                              /**< (UDDRC_PCFGWQOS0_1) This bitfield indicates the traffic class of region 2.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION2_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION2_Pos) /**< (UDDRC_PCFGWQOS0_1) This bitfield indicates the traffic class of region 2.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION2(value) (UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION2_Msk & ((value) << UDDRC_PCFGWQOS0_1_WQOS_MAP_REGION2_Pos))
#define UDDRC_PCFGWQOS0_1_Msk                 _U_(0x03330F0F)                                      /**< (UDDRC_PCFGWQOS0_1) Register Mask  */


/* -------- UDDRC_PCFGWQOS1_1 : (UDDRC Offset: 0x550) (R/W 32) Port n Write QoS Configuration Register 1 -------- */
#define UDDRC_PCFGWQOS1_1_RESETVALUE          _U_(0x00)                                            /**<  (UDDRC_PCFGWQOS1_1) Port n Write QoS Configuration Register 1  Reset Value */

#define UDDRC_PCFGWQOS1_1_WQOS_MAP_TIMEOUT1_Pos _U_(0)                                               /**< (UDDRC_PCFGWQOS1_1) Specifies the timeout value for write transactions in region 0 and 1. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS1_1_WQOS_MAP_TIMEOUT1_Msk (_U_(0x7FF) << UDDRC_PCFGWQOS1_1_WQOS_MAP_TIMEOUT1_Pos) /**< (UDDRC_PCFGWQOS1_1) Specifies the timeout value for write transactions in region 0 and 1. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS1_1_WQOS_MAP_TIMEOUT1(value) (UDDRC_PCFGWQOS1_1_WQOS_MAP_TIMEOUT1_Msk & ((value) << UDDRC_PCFGWQOS1_1_WQOS_MAP_TIMEOUT1_Pos))
#define UDDRC_PCFGWQOS1_1_WQOS_MAP_TIMEOUT2_Pos _U_(16)                                              /**< (UDDRC_PCFGWQOS1_1) Specifies the timeout value for write transactions in region 2. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS1_1_WQOS_MAP_TIMEOUT2_Msk (_U_(0x7FF) << UDDRC_PCFGWQOS1_1_WQOS_MAP_TIMEOUT2_Pos) /**< (UDDRC_PCFGWQOS1_1) Specifies the timeout value for write transactions in region 2. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS1_1_WQOS_MAP_TIMEOUT2(value) (UDDRC_PCFGWQOS1_1_WQOS_MAP_TIMEOUT2_Msk & ((value) << UDDRC_PCFGWQOS1_1_WQOS_MAP_TIMEOUT2_Pos))
#define UDDRC_PCFGWQOS1_1_Msk                 _U_(0x07FF07FF)                                      /**< (UDDRC_PCFGWQOS1_1) Register Mask  */


/* -------- UDDRC_PCFGR_2 : (UDDRC Offset: 0x564) (R/W 32) Port n Configuration Read Register -------- */
#define UDDRC_PCFGR_2_RESETVALUE              _U_(0x4000)                                          /**<  (UDDRC_PCFGR_2) Port n Configuration Read Register  Reset Value */

#define UDDRC_PCFGR_2_RD_PORT_PRIORITY_Pos    _U_(0)                                               /**< (UDDRC_PCFGR_2) Determines the initial load value of read aging counters.   These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not    granted. The higher significant 5-bits of the read aging counter sets the priority of the           read channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease.   When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0).  For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (arqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.  In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority    (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Position */
#define UDDRC_PCFGR_2_RD_PORT_PRIORITY_Msk    (_U_(0x3FF) << UDDRC_PCFGR_2_RD_PORT_PRIORITY_Pos)   /**< (UDDRC_PCFGR_2) Determines the initial load value of read aging counters.   These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not    granted. The higher significant 5-bits of the read aging counter sets the priority of the           read channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease.   When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0).  For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (arqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.  In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority    (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Mask */
#define UDDRC_PCFGR_2_RD_PORT_PRIORITY(value) (UDDRC_PCFGR_2_RD_PORT_PRIORITY_Msk & ((value) << UDDRC_PCFGR_2_RD_PORT_PRIORITY_Pos))
#define UDDRC_PCFGR_2_READ_REORDER_BYPASS_EN_Pos _U_(11)                                              /**< (UDDRC_PCFGR_2) All transactions can be reordered even if ID not found in any RBB channel Position */
#define UDDRC_PCFGR_2_READ_REORDER_BYPASS_EN_Msk (_U_(0x1) << UDDRC_PCFGR_2_READ_REORDER_BYPASS_EN_Pos) /**< (UDDRC_PCFGR_2) All transactions can be reordered even if ID not found in any RBB channel Mask */
#define UDDRC_PCFGR_2_READ_REORDER_BYPASS_EN(value) (UDDRC_PCFGR_2_READ_REORDER_BYPASS_EN_Msk & ((value) << UDDRC_PCFGR_2_READ_REORDER_BYPASS_EN_Pos))
#define UDDRC_PCFGR_2_RD_PORT_AGING_EN_Pos    _U_(12)                                              /**< (UDDRC_PCFGR_2) If set to 1, enables aging function for the read channel of the port. Programming Mode: Static Position */
#define UDDRC_PCFGR_2_RD_PORT_AGING_EN_Msk    (_U_(0x1) << UDDRC_PCFGR_2_RD_PORT_AGING_EN_Pos)     /**< (UDDRC_PCFGR_2) If set to 1, enables aging function for the read channel of the port. Programming Mode: Static Mask */
#define UDDRC_PCFGR_2_RD_PORT_AGING_EN(value) (UDDRC_PCFGR_2_RD_PORT_AGING_EN_Msk & ((value) << UDDRC_PCFGR_2_RD_PORT_AGING_EN_Pos))
#define UDDRC_PCFGR_2_RD_PORT_URGENT_EN_Pos   _U_(13)                                              /**< (UDDRC_PCFGR_2) If set to 1, enables the AXI urgent sideband signal (arurgent). When enabled and arurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Position */
#define UDDRC_PCFGR_2_RD_PORT_URGENT_EN_Msk   (_U_(0x1) << UDDRC_PCFGR_2_RD_PORT_URGENT_EN_Pos)    /**< (UDDRC_PCFGR_2) If set to 1, enables the AXI urgent sideband signal (arurgent). When enabled and arurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Mask */
#define UDDRC_PCFGR_2_RD_PORT_URGENT_EN(value) (UDDRC_PCFGR_2_RD_PORT_URGENT_EN_Msk & ((value) << UDDRC_PCFGR_2_RD_PORT_URGENT_EN_Pos))
#define UDDRC_PCFGR_2_RD_PORT_PAGEMATCH_EN_Pos _U_(14)                                              /**< (UDDRC_PCFGR_2) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Position */
#define UDDRC_PCFGR_2_RD_PORT_PAGEMATCH_EN_Msk (_U_(0x1) << UDDRC_PCFGR_2_RD_PORT_PAGEMATCH_EN_Pos) /**< (UDDRC_PCFGR_2) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Mask */
#define UDDRC_PCFGR_2_RD_PORT_PAGEMATCH_EN(value) (UDDRC_PCFGR_2_RD_PORT_PAGEMATCH_EN_Msk & ((value) << UDDRC_PCFGR_2_RD_PORT_PAGEMATCH_EN_Pos))
#define UDDRC_PCFGR_2_RDWR_ORDERED_EN_Pos     _U_(16)                                              /**< (UDDRC_PCFGR_2) Read/Write AXI transactions acceptance ordering to the same address on a giben port will not be respected when transported to  the DFI Position */
#define UDDRC_PCFGR_2_RDWR_ORDERED_EN_Msk     (_U_(0x1) << UDDRC_PCFGR_2_RDWR_ORDERED_EN_Pos)      /**< (UDDRC_PCFGR_2) Read/Write AXI transactions acceptance ordering to the same address on a giben port will not be respected when transported to  the DFI Mask */
#define UDDRC_PCFGR_2_RDWR_ORDERED_EN(value)  (UDDRC_PCFGR_2_RDWR_ORDERED_EN_Msk & ((value) << UDDRC_PCFGR_2_RDWR_ORDERED_EN_Pos))
#define UDDRC_PCFGR_2_Msk                     _U_(0x00017BFF)                                      /**< (UDDRC_PCFGR_2) Register Mask  */


/* -------- UDDRC_PCFGW_2 : (UDDRC Offset: 0x568) (R/W 32) Port n Configuration Write Register -------- */
#define UDDRC_PCFGW_2_RESETVALUE              _U_(0x4000)                                          /**<  (UDDRC_PCFGW_2) Port n Configuration Write Register  Reset Value */

#define UDDRC_PCFGW_2_WR_PORT_PRIORITY_Pos    _U_(0)                                               /**< (UDDRC_PCFGW_2) Determines the initial load value of write aging counters.  These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not   granted. The higher significant 5-bits of the write aging counter sets the initial priority of the           write channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level.   For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (awqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Position */
#define UDDRC_PCFGW_2_WR_PORT_PRIORITY_Msk    (_U_(0x3FF) << UDDRC_PCFGW_2_WR_PORT_PRIORITY_Pos)   /**< (UDDRC_PCFGW_2) Determines the initial load value of write aging counters.  These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not   granted. The higher significant 5-bits of the write aging counter sets the initial priority of the           write channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level.   For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (awqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Mask */
#define UDDRC_PCFGW_2_WR_PORT_PRIORITY(value) (UDDRC_PCFGW_2_WR_PORT_PRIORITY_Msk & ((value) << UDDRC_PCFGW_2_WR_PORT_PRIORITY_Pos))
#define UDDRC_PCFGW_2_WR_PORT_AGING_EN_Pos    _U_(12)                                              /**< (UDDRC_PCFGW_2) If set to 1, enables aging function for the write channel of the port. Programming Mode: Static Position */
#define UDDRC_PCFGW_2_WR_PORT_AGING_EN_Msk    (_U_(0x1) << UDDRC_PCFGW_2_WR_PORT_AGING_EN_Pos)     /**< (UDDRC_PCFGW_2) If set to 1, enables aging function for the write channel of the port. Programming Mode: Static Mask */
#define UDDRC_PCFGW_2_WR_PORT_AGING_EN(value) (UDDRC_PCFGW_2_WR_PORT_AGING_EN_Msk & ((value) << UDDRC_PCFGW_2_WR_PORT_AGING_EN_Pos))
#define UDDRC_PCFGW_2_WR_PORT_URGENT_EN_Pos   _U_(13)                                              /**< (UDDRC_PCFGW_2) If set to 1, enables the AXI urgent sideband signal (awurgent). When enabled and awurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register.  Note that awurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Position */
#define UDDRC_PCFGW_2_WR_PORT_URGENT_EN_Msk   (_U_(0x1) << UDDRC_PCFGW_2_WR_PORT_URGENT_EN_Pos)    /**< (UDDRC_PCFGW_2) If set to 1, enables the AXI urgent sideband signal (awurgent). When enabled and awurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register.  Note that awurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Mask */
#define UDDRC_PCFGW_2_WR_PORT_URGENT_EN(value) (UDDRC_PCFGW_2_WR_PORT_URGENT_EN_Msk & ((value) << UDDRC_PCFGW_2_WR_PORT_URGENT_EN_Pos))
#define UDDRC_PCFGW_2_WR_PORT_PAGEMATCH_EN_Pos _U_(14)                                              /**< (UDDRC_PCFGW_2) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Position */
#define UDDRC_PCFGW_2_WR_PORT_PAGEMATCH_EN_Msk (_U_(0x1) << UDDRC_PCFGW_2_WR_PORT_PAGEMATCH_EN_Pos) /**< (UDDRC_PCFGW_2) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Mask */
#define UDDRC_PCFGW_2_WR_PORT_PAGEMATCH_EN(value) (UDDRC_PCFGW_2_WR_PORT_PAGEMATCH_EN_Msk & ((value) << UDDRC_PCFGW_2_WR_PORT_PAGEMATCH_EN_Pos))
#define UDDRC_PCFGW_2_Msk                     _U_(0x000073FF)                                      /**< (UDDRC_PCFGW_2) Register Mask  */


/* -------- UDDRC_PCTRL_2 : (UDDRC Offset: 0x5F0) (R/W 32) Port n Control Register -------- */
#define UDDRC_PCTRL_2_RESETVALUE              _U_(0x00)                                            /**<  (UDDRC_PCTRL_2) Port n Control Register  Reset Value */

#define UDDRC_PCTRL_2_PORT_EN_Pos             _U_(0)                                               /**< (UDDRC_PCTRL_2) Enables AXI port n. Programming Mode: Dynamic Position */
#define UDDRC_PCTRL_2_PORT_EN_Msk             (_U_(0x1) << UDDRC_PCTRL_2_PORT_EN_Pos)              /**< (UDDRC_PCTRL_2) Enables AXI port n. Programming Mode: Dynamic Mask */
#define UDDRC_PCTRL_2_PORT_EN(value)          (UDDRC_PCTRL_2_PORT_EN_Msk & ((value) << UDDRC_PCTRL_2_PORT_EN_Pos))
#define UDDRC_PCTRL_2_Msk                     _U_(0x00000001)                                      /**< (UDDRC_PCTRL_2) Register Mask  */


/* -------- UDDRC_PCFGQOS0_2 : (UDDRC Offset: 0x5F4) (R/W 32) Port n Read QoS Configuration Register 0 -------- */
#define UDDRC_PCFGQOS0_2_RESETVALUE           _U_(0x2000E00)                                       /**<  (UDDRC_PCFGQOS0_2) Port n Read QoS Configuration Register 0  Reset Value */

#define UDDRC_PCFGQOS0_2_RQOS_MAP_LEVEL1_Pos  _U_(0)                                               /**< (UDDRC_PCFGQOS0_2) Separation level1 indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos.           Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_2_RQOS_MAP_LEVEL1_Msk  (_U_(0xF) << UDDRC_PCFGQOS0_2_RQOS_MAP_LEVEL1_Pos)   /**< (UDDRC_PCFGQOS0_2) Separation level1 indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos.           Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_2_RQOS_MAP_LEVEL1(value) (UDDRC_PCFGQOS0_2_RQOS_MAP_LEVEL1_Msk & ((value) << UDDRC_PCFGQOS0_2_RQOS_MAP_LEVEL1_Pos))
#define UDDRC_PCFGQOS0_2_RQOS_MAP_LEVEL2_Pos  _U_(8)                                               /**< (UDDRC_PCFGQOS0_2) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to arqos.   Region2 starts from (level2 + 1) up to 15.  Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_2_RQOS_MAP_LEVEL2_Msk  (_U_(0xF) << UDDRC_PCFGQOS0_2_RQOS_MAP_LEVEL2_Pos)   /**< (UDDRC_PCFGQOS0_2) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to arqos.   Region2 starts from (level2 + 1) up to 15.  Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_2_RQOS_MAP_LEVEL2(value) (UDDRC_PCFGQOS0_2_RQOS_MAP_LEVEL2_Msk & ((value) << UDDRC_PCFGQOS0_2_RQOS_MAP_LEVEL2_Pos))
#define UDDRC_PCFGQOS0_2_RQOS_MAP_REGION0_Pos _U_(16)                                              /**< (UDDRC_PCFGQOS0_2) This bitfield indicates the traffic class of region 0.  Valid values are:  - 0: LPR  - 1: VPR  - 2: HPR For dual address queue configurations, region 0 maps to the blue address queue.  In this case, valid values are:  0: LPR and 1: VPR only.  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_2_RQOS_MAP_REGION0_Msk (_U_(0x3) << UDDRC_PCFGQOS0_2_RQOS_MAP_REGION0_Pos)  /**< (UDDRC_PCFGQOS0_2) This bitfield indicates the traffic class of region 0.  Valid values are:  - 0: LPR  - 1: VPR  - 2: HPR For dual address queue configurations, region 0 maps to the blue address queue.  In this case, valid values are:  0: LPR and 1: VPR only.  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_2_RQOS_MAP_REGION0(value) (UDDRC_PCFGQOS0_2_RQOS_MAP_REGION0_Msk & ((value) << UDDRC_PCFGQOS0_2_RQOS_MAP_REGION0_Pos))
#define UDDRC_PCFGQOS0_2_RQOS_MAP_REGION1_Pos _U_(20)                                              /**< (UDDRC_PCFGQOS0_2) This bitfield indicates the traffic class of region 1.  Valid values are:  - 0 : LPR  - 1: VPR  - 2: HPR  For dual address queue configurations, region1 maps to the blue address queue.  In this case, valid values are   - 0: LPR  - 1: VPR only  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_2_RQOS_MAP_REGION1_Msk (_U_(0x3) << UDDRC_PCFGQOS0_2_RQOS_MAP_REGION1_Pos)  /**< (UDDRC_PCFGQOS0_2) This bitfield indicates the traffic class of region 1.  Valid values are:  - 0 : LPR  - 1: VPR  - 2: HPR  For dual address queue configurations, region1 maps to the blue address queue.  In this case, valid values are   - 0: LPR  - 1: VPR only  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_2_RQOS_MAP_REGION1(value) (UDDRC_PCFGQOS0_2_RQOS_MAP_REGION1_Msk & ((value) << UDDRC_PCFGQOS0_2_RQOS_MAP_REGION1_Pos))
#define UDDRC_PCFGQOS0_2_RQOS_MAP_REGION2_Pos _U_(24)                                              /**< (UDDRC_PCFGQOS0_2) This bitfield indicates the traffic class of region2.  For dual address queue configurations, region2 maps to the red address queue.  Valid values are 1: VPR and 2: HPR only.  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region2 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_2_RQOS_MAP_REGION2_Msk (_U_(0x3) << UDDRC_PCFGQOS0_2_RQOS_MAP_REGION2_Pos)  /**< (UDDRC_PCFGQOS0_2) This bitfield indicates the traffic class of region2.  For dual address queue configurations, region2 maps to the red address queue.  Valid values are 1: VPR and 2: HPR only.  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region2 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_2_RQOS_MAP_REGION2(value) (UDDRC_PCFGQOS0_2_RQOS_MAP_REGION2_Msk & ((value) << UDDRC_PCFGQOS0_2_RQOS_MAP_REGION2_Pos))
#define UDDRC_PCFGQOS0_2_Msk                  _U_(0x03330F0F)                                      /**< (UDDRC_PCFGQOS0_2) Register Mask  */


/* -------- UDDRC_PCFGQOS1_2 : (UDDRC Offset: 0x5F8) (R/W 32) Port n Read QoS Configuration Register 1 -------- */
#define UDDRC_PCFGQOS1_2_RESETVALUE           _U_(0x00)                                            /**<  (UDDRC_PCFGQOS1_2) Port n Read QoS Configuration Register 1  Reset Value */

#define UDDRC_PCFGQOS1_2_RQOS_MAP_TIMEOUTB_Pos _U_(0)                                               /**< (UDDRC_PCFGQOS1_2) Specifies the timeout value for transactions mapped to the blue address queue. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS1_2_RQOS_MAP_TIMEOUTB_Msk (_U_(0x7FF) << UDDRC_PCFGQOS1_2_RQOS_MAP_TIMEOUTB_Pos) /**< (UDDRC_PCFGQOS1_2) Specifies the timeout value for transactions mapped to the blue address queue. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS1_2_RQOS_MAP_TIMEOUTB(value) (UDDRC_PCFGQOS1_2_RQOS_MAP_TIMEOUTB_Msk & ((value) << UDDRC_PCFGQOS1_2_RQOS_MAP_TIMEOUTB_Pos))
#define UDDRC_PCFGQOS1_2_RQOS_MAP_TIMEOUTR_Pos _U_(16)                                              /**< (UDDRC_PCFGQOS1_2) Specifies the timeout value for transactions mapped to the red address queue. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS1_2_RQOS_MAP_TIMEOUTR_Msk (_U_(0x7FF) << UDDRC_PCFGQOS1_2_RQOS_MAP_TIMEOUTR_Pos) /**< (UDDRC_PCFGQOS1_2) Specifies the timeout value for transactions mapped to the red address queue. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS1_2_RQOS_MAP_TIMEOUTR(value) (UDDRC_PCFGQOS1_2_RQOS_MAP_TIMEOUTR_Msk & ((value) << UDDRC_PCFGQOS1_2_RQOS_MAP_TIMEOUTR_Pos))
#define UDDRC_PCFGQOS1_2_Msk                  _U_(0x07FF07FF)                                      /**< (UDDRC_PCFGQOS1_2) Register Mask  */


/* -------- UDDRC_PCFGWQOS0_2 : (UDDRC Offset: 0x5FC) (R/W 32) Port n Write QoS Configuration Register 0 -------- */
#define UDDRC_PCFGWQOS0_2_RESETVALUE          _U_(0xE00)                                           /**<  (UDDRC_PCFGWQOS0_2) Port n Write QoS Configuration Register 0  Reset Value */

#define UDDRC_PCFGWQOS0_2_WQOS_MAP_LEVEL1_Pos _U_(0)                                               /**< (UDDRC_PCFGWQOS0_2) Separation level indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds to awqos.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_2_WQOS_MAP_LEVEL1_Msk (_U_(0xF) << UDDRC_PCFGWQOS0_2_WQOS_MAP_LEVEL1_Pos)  /**< (UDDRC_PCFGWQOS0_2) Separation level indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds to awqos.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_2_WQOS_MAP_LEVEL1(value) (UDDRC_PCFGWQOS0_2_WQOS_MAP_LEVEL1_Msk & ((value) << UDDRC_PCFGWQOS0_2_WQOS_MAP_LEVEL1_Pos))
#define UDDRC_PCFGWQOS0_2_WQOS_MAP_LEVEL2_Pos _U_(8)                                               /**< (UDDRC_PCFGWQOS0_2) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to awqos.  Region2 starts from (level2 + 1) up to 15.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_2_WQOS_MAP_LEVEL2_Msk (_U_(0xF) << UDDRC_PCFGWQOS0_2_WQOS_MAP_LEVEL2_Pos)  /**< (UDDRC_PCFGWQOS0_2) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to awqos.  Region2 starts from (level2 + 1) up to 15.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_2_WQOS_MAP_LEVEL2(value) (UDDRC_PCFGWQOS0_2_WQOS_MAP_LEVEL2_Msk & ((value) << UDDRC_PCFGWQOS0_2_WQOS_MAP_LEVEL2_Pos))
#define UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION0_Pos _U_(16)                                              /**< (UDDRC_PCFGWQOS0_2) This bitfield indicates the traffic class of region 0.     Valid values are:      0: NPW, 1: VPW.        When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION0_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION0_Pos) /**< (UDDRC_PCFGWQOS0_2) This bitfield indicates the traffic class of region 0.     Valid values are:      0: NPW, 1: VPW.        When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION0(value) (UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION0_Msk & ((value) << UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION0_Pos))
#define UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION1_Pos _U_(20)                                              /**< (UDDRC_PCFGWQOS0_2) This bitfield indicates the traffic class of region 1.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION1_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION1_Pos) /**< (UDDRC_PCFGWQOS0_2) This bitfield indicates the traffic class of region 1.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION1(value) (UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION1_Msk & ((value) << UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION1_Pos))
#define UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION2_Pos _U_(24)                                              /**< (UDDRC_PCFGWQOS0_2) This bitfield indicates the traffic class of region 2.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION2_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION2_Pos) /**< (UDDRC_PCFGWQOS0_2) This bitfield indicates the traffic class of region 2.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION2(value) (UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION2_Msk & ((value) << UDDRC_PCFGWQOS0_2_WQOS_MAP_REGION2_Pos))
#define UDDRC_PCFGWQOS0_2_Msk                 _U_(0x03330F0F)                                      /**< (UDDRC_PCFGWQOS0_2) Register Mask  */


/* -------- UDDRC_PCFGWQOS1_2 : (UDDRC Offset: 0x600) (R/W 32) Port n Write QoS Configuration Register 1 -------- */
#define UDDRC_PCFGWQOS1_2_RESETVALUE          _U_(0x00)                                            /**<  (UDDRC_PCFGWQOS1_2) Port n Write QoS Configuration Register 1  Reset Value */

#define UDDRC_PCFGWQOS1_2_WQOS_MAP_TIMEOUT1_Pos _U_(0)                                               /**< (UDDRC_PCFGWQOS1_2) Specifies the timeout value for write transactions in region 0 and 1. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS1_2_WQOS_MAP_TIMEOUT1_Msk (_U_(0x7FF) << UDDRC_PCFGWQOS1_2_WQOS_MAP_TIMEOUT1_Pos) /**< (UDDRC_PCFGWQOS1_2) Specifies the timeout value for write transactions in region 0 and 1. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS1_2_WQOS_MAP_TIMEOUT1(value) (UDDRC_PCFGWQOS1_2_WQOS_MAP_TIMEOUT1_Msk & ((value) << UDDRC_PCFGWQOS1_2_WQOS_MAP_TIMEOUT1_Pos))
#define UDDRC_PCFGWQOS1_2_WQOS_MAP_TIMEOUT2_Pos _U_(16)                                              /**< (UDDRC_PCFGWQOS1_2) Specifies the timeout value for write transactions in region 2. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS1_2_WQOS_MAP_TIMEOUT2_Msk (_U_(0x7FF) << UDDRC_PCFGWQOS1_2_WQOS_MAP_TIMEOUT2_Pos) /**< (UDDRC_PCFGWQOS1_2) Specifies the timeout value for write transactions in region 2. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS1_2_WQOS_MAP_TIMEOUT2(value) (UDDRC_PCFGWQOS1_2_WQOS_MAP_TIMEOUT2_Msk & ((value) << UDDRC_PCFGWQOS1_2_WQOS_MAP_TIMEOUT2_Pos))
#define UDDRC_PCFGWQOS1_2_Msk                 _U_(0x07FF07FF)                                      /**< (UDDRC_PCFGWQOS1_2) Register Mask  */


/* -------- UDDRC_PCFGR_3 : (UDDRC Offset: 0x614) (R/W 32) Port n Configuration Read Register -------- */
#define UDDRC_PCFGR_3_RESETVALUE              _U_(0x4000)                                          /**<  (UDDRC_PCFGR_3) Port n Configuration Read Register  Reset Value */

#define UDDRC_PCFGR_3_RD_PORT_PRIORITY_Pos    _U_(0)                                               /**< (UDDRC_PCFGR_3) Determines the initial load value of read aging counters.   These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not    granted. The higher significant 5-bits of the read aging counter sets the priority of the           read channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease.   When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0).  For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (arqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.  In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority    (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Position */
#define UDDRC_PCFGR_3_RD_PORT_PRIORITY_Msk    (_U_(0x3FF) << UDDRC_PCFGR_3_RD_PORT_PRIORITY_Pos)   /**< (UDDRC_PCFGR_3) Determines the initial load value of read aging counters.   These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not    granted. The higher significant 5-bits of the read aging counter sets the priority of the           read channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease.   When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0).  For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (arqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.  In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority    (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Mask */
#define UDDRC_PCFGR_3_RD_PORT_PRIORITY(value) (UDDRC_PCFGR_3_RD_PORT_PRIORITY_Msk & ((value) << UDDRC_PCFGR_3_RD_PORT_PRIORITY_Pos))
#define UDDRC_PCFGR_3_READ_REORDER_BYPASS_EN_Pos _U_(11)                                              /**< (UDDRC_PCFGR_3) All transactions can be reordered even if ID not found in any RBB channel Position */
#define UDDRC_PCFGR_3_READ_REORDER_BYPASS_EN_Msk (_U_(0x1) << UDDRC_PCFGR_3_READ_REORDER_BYPASS_EN_Pos) /**< (UDDRC_PCFGR_3) All transactions can be reordered even if ID not found in any RBB channel Mask */
#define UDDRC_PCFGR_3_READ_REORDER_BYPASS_EN(value) (UDDRC_PCFGR_3_READ_REORDER_BYPASS_EN_Msk & ((value) << UDDRC_PCFGR_3_READ_REORDER_BYPASS_EN_Pos))
#define UDDRC_PCFGR_3_RD_PORT_AGING_EN_Pos    _U_(12)                                              /**< (UDDRC_PCFGR_3) If set to 1, enables aging function for the read channel of the port. Programming Mode: Static Position */
#define UDDRC_PCFGR_3_RD_PORT_AGING_EN_Msk    (_U_(0x1) << UDDRC_PCFGR_3_RD_PORT_AGING_EN_Pos)     /**< (UDDRC_PCFGR_3) If set to 1, enables aging function for the read channel of the port. Programming Mode: Static Mask */
#define UDDRC_PCFGR_3_RD_PORT_AGING_EN(value) (UDDRC_PCFGR_3_RD_PORT_AGING_EN_Msk & ((value) << UDDRC_PCFGR_3_RD_PORT_AGING_EN_Pos))
#define UDDRC_PCFGR_3_RD_PORT_URGENT_EN_Pos   _U_(13)                                              /**< (UDDRC_PCFGR_3) If set to 1, enables the AXI urgent sideband signal (arurgent). When enabled and arurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Position */
#define UDDRC_PCFGR_3_RD_PORT_URGENT_EN_Msk   (_U_(0x1) << UDDRC_PCFGR_3_RD_PORT_URGENT_EN_Pos)    /**< (UDDRC_PCFGR_3) If set to 1, enables the AXI urgent sideband signal (arurgent). When enabled and arurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Mask */
#define UDDRC_PCFGR_3_RD_PORT_URGENT_EN(value) (UDDRC_PCFGR_3_RD_PORT_URGENT_EN_Msk & ((value) << UDDRC_PCFGR_3_RD_PORT_URGENT_EN_Pos))
#define UDDRC_PCFGR_3_RD_PORT_PAGEMATCH_EN_Pos _U_(14)                                              /**< (UDDRC_PCFGR_3) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Position */
#define UDDRC_PCFGR_3_RD_PORT_PAGEMATCH_EN_Msk (_U_(0x1) << UDDRC_PCFGR_3_RD_PORT_PAGEMATCH_EN_Pos) /**< (UDDRC_PCFGR_3) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Mask */
#define UDDRC_PCFGR_3_RD_PORT_PAGEMATCH_EN(value) (UDDRC_PCFGR_3_RD_PORT_PAGEMATCH_EN_Msk & ((value) << UDDRC_PCFGR_3_RD_PORT_PAGEMATCH_EN_Pos))
#define UDDRC_PCFGR_3_RDWR_ORDERED_EN_Pos     _U_(16)                                              /**< (UDDRC_PCFGR_3) Read/Write AXI transactions acceptance ordering to the same address on a giben port will not be respected when transported to  the DFI Position */
#define UDDRC_PCFGR_3_RDWR_ORDERED_EN_Msk     (_U_(0x1) << UDDRC_PCFGR_3_RDWR_ORDERED_EN_Pos)      /**< (UDDRC_PCFGR_3) Read/Write AXI transactions acceptance ordering to the same address on a giben port will not be respected when transported to  the DFI Mask */
#define UDDRC_PCFGR_3_RDWR_ORDERED_EN(value)  (UDDRC_PCFGR_3_RDWR_ORDERED_EN_Msk & ((value) << UDDRC_PCFGR_3_RDWR_ORDERED_EN_Pos))
#define UDDRC_PCFGR_3_Msk                     _U_(0x00017BFF)                                      /**< (UDDRC_PCFGR_3) Register Mask  */


/* -------- UDDRC_PCFGW_3 : (UDDRC Offset: 0x618) (R/W 32) Port n Configuration Write Register -------- */
#define UDDRC_PCFGW_3_RESETVALUE              _U_(0x4000)                                          /**<  (UDDRC_PCFGW_3) Port n Configuration Write Register  Reset Value */

#define UDDRC_PCFGW_3_WR_PORT_PRIORITY_Pos    _U_(0)                                               /**< (UDDRC_PCFGW_3) Determines the initial load value of write aging counters.  These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not   granted. The higher significant 5-bits of the write aging counter sets the initial priority of the           write channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level.   For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (awqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Position */
#define UDDRC_PCFGW_3_WR_PORT_PRIORITY_Msk    (_U_(0x3FF) << UDDRC_PCFGW_3_WR_PORT_PRIORITY_Pos)   /**< (UDDRC_PCFGW_3) Determines the initial load value of write aging counters.  These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not   granted. The higher significant 5-bits of the write aging counter sets the initial priority of the           write channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level.   For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (awqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Mask */
#define UDDRC_PCFGW_3_WR_PORT_PRIORITY(value) (UDDRC_PCFGW_3_WR_PORT_PRIORITY_Msk & ((value) << UDDRC_PCFGW_3_WR_PORT_PRIORITY_Pos))
#define UDDRC_PCFGW_3_WR_PORT_AGING_EN_Pos    _U_(12)                                              /**< (UDDRC_PCFGW_3) If set to 1, enables aging function for the write channel of the port. Programming Mode: Static Position */
#define UDDRC_PCFGW_3_WR_PORT_AGING_EN_Msk    (_U_(0x1) << UDDRC_PCFGW_3_WR_PORT_AGING_EN_Pos)     /**< (UDDRC_PCFGW_3) If set to 1, enables aging function for the write channel of the port. Programming Mode: Static Mask */
#define UDDRC_PCFGW_3_WR_PORT_AGING_EN(value) (UDDRC_PCFGW_3_WR_PORT_AGING_EN_Msk & ((value) << UDDRC_PCFGW_3_WR_PORT_AGING_EN_Pos))
#define UDDRC_PCFGW_3_WR_PORT_URGENT_EN_Pos   _U_(13)                                              /**< (UDDRC_PCFGW_3) If set to 1, enables the AXI urgent sideband signal (awurgent). When enabled and awurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register.  Note that awurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Position */
#define UDDRC_PCFGW_3_WR_PORT_URGENT_EN_Msk   (_U_(0x1) << UDDRC_PCFGW_3_WR_PORT_URGENT_EN_Pos)    /**< (UDDRC_PCFGW_3) If set to 1, enables the AXI urgent sideband signal (awurgent). When enabled and awurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register.  Note that awurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Mask */
#define UDDRC_PCFGW_3_WR_PORT_URGENT_EN(value) (UDDRC_PCFGW_3_WR_PORT_URGENT_EN_Msk & ((value) << UDDRC_PCFGW_3_WR_PORT_URGENT_EN_Pos))
#define UDDRC_PCFGW_3_WR_PORT_PAGEMATCH_EN_Pos _U_(14)                                              /**< (UDDRC_PCFGW_3) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Position */
#define UDDRC_PCFGW_3_WR_PORT_PAGEMATCH_EN_Msk (_U_(0x1) << UDDRC_PCFGW_3_WR_PORT_PAGEMATCH_EN_Pos) /**< (UDDRC_PCFGW_3) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Mask */
#define UDDRC_PCFGW_3_WR_PORT_PAGEMATCH_EN(value) (UDDRC_PCFGW_3_WR_PORT_PAGEMATCH_EN_Msk & ((value) << UDDRC_PCFGW_3_WR_PORT_PAGEMATCH_EN_Pos))
#define UDDRC_PCFGW_3_Msk                     _U_(0x000073FF)                                      /**< (UDDRC_PCFGW_3) Register Mask  */


/* -------- UDDRC_PCTRL_3 : (UDDRC Offset: 0x6A0) (R/W 32) Port n Control Register -------- */
#define UDDRC_PCTRL_3_RESETVALUE              _U_(0x00)                                            /**<  (UDDRC_PCTRL_3) Port n Control Register  Reset Value */

#define UDDRC_PCTRL_3_PORT_EN_Pos             _U_(0)                                               /**< (UDDRC_PCTRL_3) Enables AXI port n. Programming Mode: Dynamic Position */
#define UDDRC_PCTRL_3_PORT_EN_Msk             (_U_(0x1) << UDDRC_PCTRL_3_PORT_EN_Pos)              /**< (UDDRC_PCTRL_3) Enables AXI port n. Programming Mode: Dynamic Mask */
#define UDDRC_PCTRL_3_PORT_EN(value)          (UDDRC_PCTRL_3_PORT_EN_Msk & ((value) << UDDRC_PCTRL_3_PORT_EN_Pos))
#define UDDRC_PCTRL_3_Msk                     _U_(0x00000001)                                      /**< (UDDRC_PCTRL_3) Register Mask  */


/* -------- UDDRC_PCFGQOS0_3 : (UDDRC Offset: 0x6A4) (R/W 32) Port n Read QoS Configuration Register 0 -------- */
#define UDDRC_PCFGQOS0_3_RESETVALUE           _U_(0x00)                                            /**<  (UDDRC_PCFGQOS0_3) Port n Read QoS Configuration Register 0  Reset Value */

#define UDDRC_PCFGQOS0_3_RQOS_MAP_LEVEL1_Pos  _U_(0)                                               /**< (UDDRC_PCFGQOS0_3) Separation level1 indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos.           Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_3_RQOS_MAP_LEVEL1_Msk  (_U_(0xF) << UDDRC_PCFGQOS0_3_RQOS_MAP_LEVEL1_Pos)   /**< (UDDRC_PCFGQOS0_3) Separation level1 indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos.           Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_3_RQOS_MAP_LEVEL1(value) (UDDRC_PCFGQOS0_3_RQOS_MAP_LEVEL1_Msk & ((value) << UDDRC_PCFGQOS0_3_RQOS_MAP_LEVEL1_Pos))
#define UDDRC_PCFGQOS0_3_RQOS_MAP_REGION0_Pos _U_(16)                                              /**< (UDDRC_PCFGQOS0_3) This bitfield indicates the traffic class of region 0.  Valid values are:  - 0: LPR  - 1: VPR  - 2: HPR For dual address queue configurations, region 0 maps to the blue address queue.  In this case, valid values are:  0: LPR and 1: VPR only.  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_3_RQOS_MAP_REGION0_Msk (_U_(0x3) << UDDRC_PCFGQOS0_3_RQOS_MAP_REGION0_Pos)  /**< (UDDRC_PCFGQOS0_3) This bitfield indicates the traffic class of region 0.  Valid values are:  - 0: LPR  - 1: VPR  - 2: HPR For dual address queue configurations, region 0 maps to the blue address queue.  In this case, valid values are:  0: LPR and 1: VPR only.  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_3_RQOS_MAP_REGION0(value) (UDDRC_PCFGQOS0_3_RQOS_MAP_REGION0_Msk & ((value) << UDDRC_PCFGQOS0_3_RQOS_MAP_REGION0_Pos))
#define UDDRC_PCFGQOS0_3_RQOS_MAP_REGION1_Pos _U_(20)                                              /**< (UDDRC_PCFGQOS0_3) This bitfield indicates the traffic class of region 1.  Valid values are:  - 0 : LPR  - 1: VPR  - 2: HPR  For dual address queue configurations, region1 maps to the blue address queue.  In this case, valid values are   - 0: LPR  - 1: VPR only  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_3_RQOS_MAP_REGION1_Msk (_U_(0x3) << UDDRC_PCFGQOS0_3_RQOS_MAP_REGION1_Pos)  /**< (UDDRC_PCFGQOS0_3) This bitfield indicates the traffic class of region 1.  Valid values are:  - 0 : LPR  - 1: VPR  - 2: HPR  For dual address queue configurations, region1 maps to the blue address queue.  In this case, valid values are   - 0: LPR  - 1: VPR only  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_3_RQOS_MAP_REGION1(value) (UDDRC_PCFGQOS0_3_RQOS_MAP_REGION1_Msk & ((value) << UDDRC_PCFGQOS0_3_RQOS_MAP_REGION1_Pos))
#define UDDRC_PCFGQOS0_3_Msk                  _U_(0x0033000F)                                      /**< (UDDRC_PCFGQOS0_3) Register Mask  */


/* -------- UDDRC_PCFGQOS1_3 : (UDDRC Offset: 0x6A8) (R/W 32) Port n Read QoS Configuration Register 1 -------- */
#define UDDRC_PCFGQOS1_3_RESETVALUE           _U_(0x00)                                            /**<  (UDDRC_PCFGQOS1_3) Port n Read QoS Configuration Register 1  Reset Value */

#define UDDRC_PCFGQOS1_3_RQOS_MAP_TIMEOUTB_Pos _U_(0)                                               /**< (UDDRC_PCFGQOS1_3) Specifies the timeout value for transactions mapped to the blue address queue. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS1_3_RQOS_MAP_TIMEOUTB_Msk (_U_(0x7FF) << UDDRC_PCFGQOS1_3_RQOS_MAP_TIMEOUTB_Pos) /**< (UDDRC_PCFGQOS1_3) Specifies the timeout value for transactions mapped to the blue address queue. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS1_3_RQOS_MAP_TIMEOUTB(value) (UDDRC_PCFGQOS1_3_RQOS_MAP_TIMEOUTB_Msk & ((value) << UDDRC_PCFGQOS1_3_RQOS_MAP_TIMEOUTB_Pos))
#define UDDRC_PCFGQOS1_3_RQOS_MAP_TIMEOUTR_Pos _U_(16)                                              /**< (UDDRC_PCFGQOS1_3) Specifies the timeout value for transactions mapped to the red address queue. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS1_3_RQOS_MAP_TIMEOUTR_Msk (_U_(0x7FF) << UDDRC_PCFGQOS1_3_RQOS_MAP_TIMEOUTR_Pos) /**< (UDDRC_PCFGQOS1_3) Specifies the timeout value for transactions mapped to the red address queue. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS1_3_RQOS_MAP_TIMEOUTR(value) (UDDRC_PCFGQOS1_3_RQOS_MAP_TIMEOUTR_Msk & ((value) << UDDRC_PCFGQOS1_3_RQOS_MAP_TIMEOUTR_Pos))
#define UDDRC_PCFGQOS1_3_Msk                  _U_(0x07FF07FF)                                      /**< (UDDRC_PCFGQOS1_3) Register Mask  */


/* -------- UDDRC_PCFGWQOS0_3 : (UDDRC Offset: 0x6AC) (R/W 32) Port n Write QoS Configuration Register 0 -------- */
#define UDDRC_PCFGWQOS0_3_RESETVALUE          _U_(0xE00)                                           /**<  (UDDRC_PCFGWQOS0_3) Port n Write QoS Configuration Register 0  Reset Value */

#define UDDRC_PCFGWQOS0_3_WQOS_MAP_LEVEL1_Pos _U_(0)                                               /**< (UDDRC_PCFGWQOS0_3) Separation level indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds to awqos.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_3_WQOS_MAP_LEVEL1_Msk (_U_(0xF) << UDDRC_PCFGWQOS0_3_WQOS_MAP_LEVEL1_Pos)  /**< (UDDRC_PCFGWQOS0_3) Separation level indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds to awqos.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_3_WQOS_MAP_LEVEL1(value) (UDDRC_PCFGWQOS0_3_WQOS_MAP_LEVEL1_Msk & ((value) << UDDRC_PCFGWQOS0_3_WQOS_MAP_LEVEL1_Pos))
#define UDDRC_PCFGWQOS0_3_WQOS_MAP_LEVEL2_Pos _U_(8)                                               /**< (UDDRC_PCFGWQOS0_3) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to awqos.  Region2 starts from (level2 + 1) up to 15.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_3_WQOS_MAP_LEVEL2_Msk (_U_(0xF) << UDDRC_PCFGWQOS0_3_WQOS_MAP_LEVEL2_Pos)  /**< (UDDRC_PCFGWQOS0_3) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to awqos.  Region2 starts from (level2 + 1) up to 15.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_3_WQOS_MAP_LEVEL2(value) (UDDRC_PCFGWQOS0_3_WQOS_MAP_LEVEL2_Msk & ((value) << UDDRC_PCFGWQOS0_3_WQOS_MAP_LEVEL2_Pos))
#define UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION0_Pos _U_(16)                                              /**< (UDDRC_PCFGWQOS0_3) This bitfield indicates the traffic class of region 0.     Valid values are:      0: NPW, 1: VPW.        When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION0_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION0_Pos) /**< (UDDRC_PCFGWQOS0_3) This bitfield indicates the traffic class of region 0.     Valid values are:      0: NPW, 1: VPW.        When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION0(value) (UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION0_Msk & ((value) << UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION0_Pos))
#define UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION1_Pos _U_(20)                                              /**< (UDDRC_PCFGWQOS0_3) This bitfield indicates the traffic class of region 1.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION1_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION1_Pos) /**< (UDDRC_PCFGWQOS0_3) This bitfield indicates the traffic class of region 1.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION1(value) (UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION1_Msk & ((value) << UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION1_Pos))
#define UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION2_Pos _U_(24)                                              /**< (UDDRC_PCFGWQOS0_3) This bitfield indicates the traffic class of region 2.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION2_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION2_Pos) /**< (UDDRC_PCFGWQOS0_3) This bitfield indicates the traffic class of region 2.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION2(value) (UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION2_Msk & ((value) << UDDRC_PCFGWQOS0_3_WQOS_MAP_REGION2_Pos))
#define UDDRC_PCFGWQOS0_3_Msk                 _U_(0x03330F0F)                                      /**< (UDDRC_PCFGWQOS0_3) Register Mask  */


/* -------- UDDRC_PCFGWQOS1_3 : (UDDRC Offset: 0x6B0) (R/W 32) Port n Write QoS Configuration Register 1 -------- */
#define UDDRC_PCFGWQOS1_3_RESETVALUE          _U_(0x00)                                            /**<  (UDDRC_PCFGWQOS1_3) Port n Write QoS Configuration Register 1  Reset Value */

#define UDDRC_PCFGWQOS1_3_WQOS_MAP_TIMEOUT1_Pos _U_(0)                                               /**< (UDDRC_PCFGWQOS1_3) Specifies the timeout value for write transactions in region 0 and 1. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS1_3_WQOS_MAP_TIMEOUT1_Msk (_U_(0x7FF) << UDDRC_PCFGWQOS1_3_WQOS_MAP_TIMEOUT1_Pos) /**< (UDDRC_PCFGWQOS1_3) Specifies the timeout value for write transactions in region 0 and 1. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS1_3_WQOS_MAP_TIMEOUT1(value) (UDDRC_PCFGWQOS1_3_WQOS_MAP_TIMEOUT1_Msk & ((value) << UDDRC_PCFGWQOS1_3_WQOS_MAP_TIMEOUT1_Pos))
#define UDDRC_PCFGWQOS1_3_WQOS_MAP_TIMEOUT2_Pos _U_(16)                                              /**< (UDDRC_PCFGWQOS1_3) Specifies the timeout value for write transactions in region 2. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS1_3_WQOS_MAP_TIMEOUT2_Msk (_U_(0x7FF) << UDDRC_PCFGWQOS1_3_WQOS_MAP_TIMEOUT2_Pos) /**< (UDDRC_PCFGWQOS1_3) Specifies the timeout value for write transactions in region 2. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS1_3_WQOS_MAP_TIMEOUT2(value) (UDDRC_PCFGWQOS1_3_WQOS_MAP_TIMEOUT2_Msk & ((value) << UDDRC_PCFGWQOS1_3_WQOS_MAP_TIMEOUT2_Pos))
#define UDDRC_PCFGWQOS1_3_Msk                 _U_(0x07FF07FF)                                      /**< (UDDRC_PCFGWQOS1_3) Register Mask  */


/* -------- UDDRC_PCFGR_4 : (UDDRC Offset: 0x6C4) (R/W 32) Port n Configuration Read Register -------- */
#define UDDRC_PCFGR_4_RESETVALUE              _U_(0x4000)                                          /**<  (UDDRC_PCFGR_4) Port n Configuration Read Register  Reset Value */

#define UDDRC_PCFGR_4_RD_PORT_PRIORITY_Pos    _U_(0)                                               /**< (UDDRC_PCFGR_4) Determines the initial load value of read aging counters.   These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not    granted. The higher significant 5-bits of the read aging counter sets the priority of the           read channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease.   When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0).  For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (arqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.  In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority    (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Position */
#define UDDRC_PCFGR_4_RD_PORT_PRIORITY_Msk    (_U_(0x3FF) << UDDRC_PCFGR_4_RD_PORT_PRIORITY_Pos)   /**< (UDDRC_PCFGR_4) Determines the initial load value of read aging counters.   These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not    granted. The higher significant 5-bits of the read aging counter sets the priority of the           read channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease.   When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0).  For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (arqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.  In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority    (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Mask */
#define UDDRC_PCFGR_4_RD_PORT_PRIORITY(value) (UDDRC_PCFGR_4_RD_PORT_PRIORITY_Msk & ((value) << UDDRC_PCFGR_4_RD_PORT_PRIORITY_Pos))
#define UDDRC_PCFGR_4_READ_REORDER_BYPASS_EN_Pos _U_(11)                                              /**< (UDDRC_PCFGR_4) All transactions can be reordered even if ID not found in any RBB channel Position */
#define UDDRC_PCFGR_4_READ_REORDER_BYPASS_EN_Msk (_U_(0x1) << UDDRC_PCFGR_4_READ_REORDER_BYPASS_EN_Pos) /**< (UDDRC_PCFGR_4) All transactions can be reordered even if ID not found in any RBB channel Mask */
#define UDDRC_PCFGR_4_READ_REORDER_BYPASS_EN(value) (UDDRC_PCFGR_4_READ_REORDER_BYPASS_EN_Msk & ((value) << UDDRC_PCFGR_4_READ_REORDER_BYPASS_EN_Pos))
#define UDDRC_PCFGR_4_RD_PORT_AGING_EN_Pos    _U_(12)                                              /**< (UDDRC_PCFGR_4) If set to 1, enables aging function for the read channel of the port. Programming Mode: Static Position */
#define UDDRC_PCFGR_4_RD_PORT_AGING_EN_Msk    (_U_(0x1) << UDDRC_PCFGR_4_RD_PORT_AGING_EN_Pos)     /**< (UDDRC_PCFGR_4) If set to 1, enables aging function for the read channel of the port. Programming Mode: Static Mask */
#define UDDRC_PCFGR_4_RD_PORT_AGING_EN(value) (UDDRC_PCFGR_4_RD_PORT_AGING_EN_Msk & ((value) << UDDRC_PCFGR_4_RD_PORT_AGING_EN_Pos))
#define UDDRC_PCFGR_4_RD_PORT_URGENT_EN_Pos   _U_(13)                                              /**< (UDDRC_PCFGR_4) If set to 1, enables the AXI urgent sideband signal (arurgent). When enabled and arurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Position */
#define UDDRC_PCFGR_4_RD_PORT_URGENT_EN_Msk   (_U_(0x1) << UDDRC_PCFGR_4_RD_PORT_URGENT_EN_Pos)    /**< (UDDRC_PCFGR_4) If set to 1, enables the AXI urgent sideband signal (arurgent). When enabled and arurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Mask */
#define UDDRC_PCFGR_4_RD_PORT_URGENT_EN(value) (UDDRC_PCFGR_4_RD_PORT_URGENT_EN_Msk & ((value) << UDDRC_PCFGR_4_RD_PORT_URGENT_EN_Pos))
#define UDDRC_PCFGR_4_RD_PORT_PAGEMATCH_EN_Pos _U_(14)                                              /**< (UDDRC_PCFGR_4) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Position */
#define UDDRC_PCFGR_4_RD_PORT_PAGEMATCH_EN_Msk (_U_(0x1) << UDDRC_PCFGR_4_RD_PORT_PAGEMATCH_EN_Pos) /**< (UDDRC_PCFGR_4) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Mask */
#define UDDRC_PCFGR_4_RD_PORT_PAGEMATCH_EN(value) (UDDRC_PCFGR_4_RD_PORT_PAGEMATCH_EN_Msk & ((value) << UDDRC_PCFGR_4_RD_PORT_PAGEMATCH_EN_Pos))
#define UDDRC_PCFGR_4_RDWR_ORDERED_EN_Pos     _U_(16)                                              /**< (UDDRC_PCFGR_4) Read/Write AXI transactions acceptance ordering to the same address on a giben port will not be respected when transported to  the DFI Position */
#define UDDRC_PCFGR_4_RDWR_ORDERED_EN_Msk     (_U_(0x1) << UDDRC_PCFGR_4_RDWR_ORDERED_EN_Pos)      /**< (UDDRC_PCFGR_4) Read/Write AXI transactions acceptance ordering to the same address on a giben port will not be respected when transported to  the DFI Mask */
#define UDDRC_PCFGR_4_RDWR_ORDERED_EN(value)  (UDDRC_PCFGR_4_RDWR_ORDERED_EN_Msk & ((value) << UDDRC_PCFGR_4_RDWR_ORDERED_EN_Pos))
#define UDDRC_PCFGR_4_Msk                     _U_(0x00017BFF)                                      /**< (UDDRC_PCFGR_4) Register Mask  */


/* -------- UDDRC_PCFGW_4 : (UDDRC Offset: 0x6C8) (R/W 32) Port n Configuration Write Register -------- */
#define UDDRC_PCFGW_4_RESETVALUE              _U_(0x4000)                                          /**<  (UDDRC_PCFGW_4) Port n Configuration Write Register  Reset Value */

#define UDDRC_PCFGW_4_WR_PORT_PRIORITY_Pos    _U_(0)                                               /**< (UDDRC_PCFGW_4) Determines the initial load value of write aging counters.  These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not   granted. The higher significant 5-bits of the write aging counter sets the initial priority of the           write channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level.   For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (awqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Position */
#define UDDRC_PCFGW_4_WR_PORT_PRIORITY_Msk    (_U_(0x3FF) << UDDRC_PCFGW_4_WR_PORT_PRIORITY_Pos)   /**< (UDDRC_PCFGW_4) Determines the initial load value of write aging counters.  These counters will be parallel loaded after reset, or after each grant to the corresponding port.   The aging counters down-count every clock cycle where the port is requesting but not   granted. The higher significant 5-bits of the write aging counter sets the initial priority of the           write channel of a given port.  Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level.   For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority   inputs (awqos) are enabled (timeout is still applicable).    For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching.    Note: The two LSBs of this register field are tied internally to 2'b00. Programming Mode: Static Mask */
#define UDDRC_PCFGW_4_WR_PORT_PRIORITY(value) (UDDRC_PCFGW_4_WR_PORT_PRIORITY_Msk & ((value) << UDDRC_PCFGW_4_WR_PORT_PRIORITY_Pos))
#define UDDRC_PCFGW_4_WR_PORT_AGING_EN_Pos    _U_(12)                                              /**< (UDDRC_PCFGW_4) If set to 1, enables aging function for the write channel of the port. Programming Mode: Static Position */
#define UDDRC_PCFGW_4_WR_PORT_AGING_EN_Msk    (_U_(0x1) << UDDRC_PCFGW_4_WR_PORT_AGING_EN_Pos)     /**< (UDDRC_PCFGW_4) If set to 1, enables aging function for the write channel of the port. Programming Mode: Static Mask */
#define UDDRC_PCFGW_4_WR_PORT_AGING_EN(value) (UDDRC_PCFGW_4_WR_PORT_AGING_EN_Msk & ((value) << UDDRC_PCFGW_4_WR_PORT_AGING_EN_Pos))
#define UDDRC_PCFGW_4_WR_PORT_URGENT_EN_Pos   _U_(13)                                              /**< (UDDRC_PCFGW_4) If set to 1, enables the AXI urgent sideband signal (awurgent). When enabled and awurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register.  Note that awurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Position */
#define UDDRC_PCFGW_4_WR_PORT_URGENT_EN_Msk   (_U_(0x1) << UDDRC_PCFGW_4_WR_PORT_URGENT_EN_Pos)    /**< (UDDRC_PCFGW_4) If set to 1, enables the AXI urgent sideband signal (awurgent). When enabled and awurgent   is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to   DDRC is asserted if enabled in PCCFG.go2critical_en register.  Note that awurgent signal can be   asserted anytime and as long as required which is independent of address handshaking (it is not   associated with any particular command). Programming Mode: Static Mask */
#define UDDRC_PCFGW_4_WR_PORT_URGENT_EN(value) (UDDRC_PCFGW_4_WR_PORT_URGENT_EN_Msk & ((value) << UDDRC_PCFGW_4_WR_PORT_URGENT_EN_Pos))
#define UDDRC_PCFGW_4_WR_PORT_PAGEMATCH_EN_Pos _U_(14)                                              /**< (UDDRC_PCFGW_4) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Position */
#define UDDRC_PCFGW_4_WR_PORT_PAGEMATCH_EN_Msk (_U_(0x1) << UDDRC_PCFGW_4_WR_PORT_PAGEMATCH_EN_Pos) /**< (UDDRC_PCFGW_4) If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted,   the port is continued to be granted if the following immediate commands are to the same   memory page (same bank and same row). See also related PCCFG.pagematch_limit register. Programming Mode: Static Mask */
#define UDDRC_PCFGW_4_WR_PORT_PAGEMATCH_EN(value) (UDDRC_PCFGW_4_WR_PORT_PAGEMATCH_EN_Msk & ((value) << UDDRC_PCFGW_4_WR_PORT_PAGEMATCH_EN_Pos))
#define UDDRC_PCFGW_4_Msk                     _U_(0x000073FF)                                      /**< (UDDRC_PCFGW_4) Register Mask  */


/* -------- UDDRC_PCTRL_4 : (UDDRC Offset: 0x750) (R/W 32) Port n Control Register -------- */
#define UDDRC_PCTRL_4_RESETVALUE              _U_(0x00)                                            /**<  (UDDRC_PCTRL_4) Port n Control Register  Reset Value */

#define UDDRC_PCTRL_4_PORT_EN_Pos             _U_(0)                                               /**< (UDDRC_PCTRL_4) Enables AXI port n. Programming Mode: Dynamic Position */
#define UDDRC_PCTRL_4_PORT_EN_Msk             (_U_(0x1) << UDDRC_PCTRL_4_PORT_EN_Pos)              /**< (UDDRC_PCTRL_4) Enables AXI port n. Programming Mode: Dynamic Mask */
#define UDDRC_PCTRL_4_PORT_EN(value)          (UDDRC_PCTRL_4_PORT_EN_Msk & ((value) << UDDRC_PCTRL_4_PORT_EN_Pos))
#define UDDRC_PCTRL_4_Msk                     _U_(0x00000001)                                      /**< (UDDRC_PCTRL_4) Register Mask  */


/* -------- UDDRC_PCFGQOS0_4 : (UDDRC Offset: 0x754) (R/W 32) Port n Read QoS Configuration Register 0 -------- */
#define UDDRC_PCFGQOS0_4_RESETVALUE           _U_(0x00)                                            /**<  (UDDRC_PCFGQOS0_4) Port n Read QoS Configuration Register 0  Reset Value */

#define UDDRC_PCFGQOS0_4_RQOS_MAP_LEVEL1_Pos  _U_(0)                                               /**< (UDDRC_PCFGQOS0_4) Separation level1 indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos.           Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_4_RQOS_MAP_LEVEL1_Msk  (_U_(0xF) << UDDRC_PCFGQOS0_4_RQOS_MAP_LEVEL1_Pos)   /**< (UDDRC_PCFGQOS0_4) Separation level1 indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos.           Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_4_RQOS_MAP_LEVEL1(value) (UDDRC_PCFGQOS0_4_RQOS_MAP_LEVEL1_Msk & ((value) << UDDRC_PCFGQOS0_4_RQOS_MAP_LEVEL1_Pos))
#define UDDRC_PCFGQOS0_4_RQOS_MAP_REGION0_Pos _U_(16)                                              /**< (UDDRC_PCFGQOS0_4) This bitfield indicates the traffic class of region 0.  Valid values are:  - 0: LPR  - 1: VPR  - 2: HPR For dual address queue configurations, region 0 maps to the blue address queue.  In this case, valid values are:  0: LPR and 1: VPR only.  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_4_RQOS_MAP_REGION0_Msk (_U_(0x3) << UDDRC_PCFGQOS0_4_RQOS_MAP_REGION0_Pos)  /**< (UDDRC_PCFGQOS0_4) This bitfield indicates the traffic class of region 0.  Valid values are:  - 0: LPR  - 1: VPR  - 2: HPR For dual address queue configurations, region 0 maps to the blue address queue.  In this case, valid values are:  0: LPR and 1: VPR only.  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_4_RQOS_MAP_REGION0(value) (UDDRC_PCFGQOS0_4_RQOS_MAP_REGION0_Msk & ((value) << UDDRC_PCFGQOS0_4_RQOS_MAP_REGION0_Pos))
#define UDDRC_PCFGQOS0_4_RQOS_MAP_REGION1_Pos _U_(20)                                              /**< (UDDRC_PCFGQOS0_4) This bitfield indicates the traffic class of region 1.  Valid values are:  - 0 : LPR  - 1: VPR  - 2: HPR  For dual address queue configurations, region1 maps to the blue address queue.  In this case, valid values are   - 0: LPR  - 1: VPR only  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS0_4_RQOS_MAP_REGION1_Msk (_U_(0x3) << UDDRC_PCFGQOS0_4_RQOS_MAP_REGION1_Pos)  /**< (UDDRC_PCFGQOS0_4) This bitfield indicates the traffic class of region 1.  Valid values are:  - 0 : LPR  - 1: VPR  - 2: HPR  For dual address queue configurations, region1 maps to the blue address queue.  In this case, valid values are   - 0: LPR  - 1: VPR only  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1 is set to 1 (VPR), VPR traffic is aliased to LPR traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS0_4_RQOS_MAP_REGION1(value) (UDDRC_PCFGQOS0_4_RQOS_MAP_REGION1_Msk & ((value) << UDDRC_PCFGQOS0_4_RQOS_MAP_REGION1_Pos))
#define UDDRC_PCFGQOS0_4_Msk                  _U_(0x0033000F)                                      /**< (UDDRC_PCFGQOS0_4) Register Mask  */


/* -------- UDDRC_PCFGQOS1_4 : (UDDRC Offset: 0x758) (R/W 32) Port n Read QoS Configuration Register 1 -------- */
#define UDDRC_PCFGQOS1_4_RESETVALUE           _U_(0x00)                                            /**<  (UDDRC_PCFGQOS1_4) Port n Read QoS Configuration Register 1  Reset Value */

#define UDDRC_PCFGQOS1_4_RQOS_MAP_TIMEOUTB_Pos _U_(0)                                               /**< (UDDRC_PCFGQOS1_4) Specifies the timeout value for transactions mapped to the blue address queue. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS1_4_RQOS_MAP_TIMEOUTB_Msk (_U_(0x7FF) << UDDRC_PCFGQOS1_4_RQOS_MAP_TIMEOUTB_Pos) /**< (UDDRC_PCFGQOS1_4) Specifies the timeout value for transactions mapped to the blue address queue. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS1_4_RQOS_MAP_TIMEOUTB(value) (UDDRC_PCFGQOS1_4_RQOS_MAP_TIMEOUTB_Msk & ((value) << UDDRC_PCFGQOS1_4_RQOS_MAP_TIMEOUTB_Pos))
#define UDDRC_PCFGQOS1_4_RQOS_MAP_TIMEOUTR_Pos _U_(16)                                              /**< (UDDRC_PCFGQOS1_4) Specifies the timeout value for transactions mapped to the red address queue. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGQOS1_4_RQOS_MAP_TIMEOUTR_Msk (_U_(0x7FF) << UDDRC_PCFGQOS1_4_RQOS_MAP_TIMEOUTR_Pos) /**< (UDDRC_PCFGQOS1_4) Specifies the timeout value for transactions mapped to the red address queue. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGQOS1_4_RQOS_MAP_TIMEOUTR(value) (UDDRC_PCFGQOS1_4_RQOS_MAP_TIMEOUTR_Msk & ((value) << UDDRC_PCFGQOS1_4_RQOS_MAP_TIMEOUTR_Pos))
#define UDDRC_PCFGQOS1_4_Msk                  _U_(0x07FF07FF)                                      /**< (UDDRC_PCFGQOS1_4) Register Mask  */


/* -------- UDDRC_PCFGWQOS0_4 : (UDDRC Offset: 0x75C) (R/W 32) Port n Write QoS Configuration Register 0 -------- */
#define UDDRC_PCFGWQOS0_4_RESETVALUE          _U_(0xE00)                                           /**<  (UDDRC_PCFGWQOS0_4) Port n Write QoS Configuration Register 0  Reset Value */

#define UDDRC_PCFGWQOS0_4_WQOS_MAP_LEVEL1_Pos _U_(0)                                               /**< (UDDRC_PCFGWQOS0_4) Separation level indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds to awqos.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_4_WQOS_MAP_LEVEL1_Msk (_U_(0xF) << UDDRC_PCFGWQOS0_4_WQOS_MAP_LEVEL1_Pos)  /**< (UDDRC_PCFGWQOS0_4) Separation level indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds to awqos.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_4_WQOS_MAP_LEVEL1(value) (UDDRC_PCFGWQOS0_4_WQOS_MAP_LEVEL1_Msk & ((value) << UDDRC_PCFGWQOS0_4_WQOS_MAP_LEVEL1_Pos))
#define UDDRC_PCFGWQOS0_4_WQOS_MAP_LEVEL2_Pos _U_(8)                                               /**< (UDDRC_PCFGWQOS0_4) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to awqos.  Region2 starts from (level2 + 1) up to 15.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_4_WQOS_MAP_LEVEL2_Msk (_U_(0xF) << UDDRC_PCFGWQOS0_4_WQOS_MAP_LEVEL2_Pos)  /**< (UDDRC_PCFGWQOS0_4) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to awqos.  Region2 starts from (level2 + 1) up to 15.  Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.  All of the map_level* registers must be set to distinct values. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_4_WQOS_MAP_LEVEL2(value) (UDDRC_PCFGWQOS0_4_WQOS_MAP_LEVEL2_Msk & ((value) << UDDRC_PCFGWQOS0_4_WQOS_MAP_LEVEL2_Pos))
#define UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION0_Pos _U_(16)                                              /**< (UDDRC_PCFGWQOS0_4) This bitfield indicates the traffic class of region 0.     Valid values are:      0: NPW, 1: VPW.        When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION0_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION0_Pos) /**< (UDDRC_PCFGWQOS0_4) This bitfield indicates the traffic class of region 0.     Valid values are:      0: NPW, 1: VPW.        When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION0(value) (UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION0_Msk & ((value) << UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION0_Pos))
#define UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION1_Pos _U_(20)                                              /**< (UDDRC_PCFGWQOS0_4) This bitfield indicates the traffic class of region 1.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION1_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION1_Pos) /**< (UDDRC_PCFGWQOS0_4) This bitfield indicates the traffic class of region 1.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION1(value) (UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION1_Msk & ((value) << UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION1_Pos))
#define UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION2_Pos _U_(24)                                              /**< (UDDRC_PCFGWQOS0_4) This bitfield indicates the traffic class of region 2.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION2_Msk (_U_(0x3) << UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION2_Pos) /**< (UDDRC_PCFGWQOS0_4) This bitfield indicates the traffic class of region 2.  Valid values are:  0: NPW, 1: VPW.  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2 is set to 1 (VPW), VPW traffic is aliased to NPW traffic. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION2(value) (UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION2_Msk & ((value) << UDDRC_PCFGWQOS0_4_WQOS_MAP_REGION2_Pos))
#define UDDRC_PCFGWQOS0_4_Msk                 _U_(0x03330F0F)                                      /**< (UDDRC_PCFGWQOS0_4) Register Mask  */


/* -------- UDDRC_PCFGWQOS1_4 : (UDDRC Offset: 0x760) (R/W 32) Port n Write QoS Configuration Register 1 -------- */
#define UDDRC_PCFGWQOS1_4_RESETVALUE          _U_(0x00)                                            /**<  (UDDRC_PCFGWQOS1_4) Port n Write QoS Configuration Register 1  Reset Value */

#define UDDRC_PCFGWQOS1_4_WQOS_MAP_TIMEOUT1_Pos _U_(0)                                               /**< (UDDRC_PCFGWQOS1_4) Specifies the timeout value for write transactions in region 0 and 1. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS1_4_WQOS_MAP_TIMEOUT1_Msk (_U_(0x7FF) << UDDRC_PCFGWQOS1_4_WQOS_MAP_TIMEOUT1_Pos) /**< (UDDRC_PCFGWQOS1_4) Specifies the timeout value for write transactions in region 0 and 1. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS1_4_WQOS_MAP_TIMEOUT1(value) (UDDRC_PCFGWQOS1_4_WQOS_MAP_TIMEOUT1_Msk & ((value) << UDDRC_PCFGWQOS1_4_WQOS_MAP_TIMEOUT1_Pos))
#define UDDRC_PCFGWQOS1_4_WQOS_MAP_TIMEOUT2_Pos _U_(16)                                              /**< (UDDRC_PCFGWQOS1_4) Specifies the timeout value for write transactions in region 2. Programming Mode: Quasi-dynamic Group 3 Position */
#define UDDRC_PCFGWQOS1_4_WQOS_MAP_TIMEOUT2_Msk (_U_(0x7FF) << UDDRC_PCFGWQOS1_4_WQOS_MAP_TIMEOUT2_Pos) /**< (UDDRC_PCFGWQOS1_4) Specifies the timeout value for write transactions in region 2. Programming Mode: Quasi-dynamic Group 3 Mask */
#define UDDRC_PCFGWQOS1_4_WQOS_MAP_TIMEOUT2(value) (UDDRC_PCFGWQOS1_4_WQOS_MAP_TIMEOUT2_Msk & ((value) << UDDRC_PCFGWQOS1_4_WQOS_MAP_TIMEOUT2_Pos))
#define UDDRC_PCFGWQOS1_4_Msk                 _U_(0x07FF07FF)                                      /**< (UDDRC_PCFGWQOS1_4) Register Mask  */


/* -------- UDDRC_SARBASE0 : (UDDRC Offset: 0xF04) (R/W 32) SAR Base Address Register n -------- */
#define UDDRC_SARBASE0_RESETVALUE             _U_(0x00)                                            /**<  (UDDRC_SARBASE0) SAR Base Address Register n  Reset Value */

#define UDDRC_SARBASE0_BASE_ADDR0_Pos         _U_(0)                                               /**< (UDDRC_SARBASE0) Base address for address region n specified as awaddr[UMCTL2_A_ADDRW-1:x] and araddr[UMCTL2_A_ADDRW-1:x]  where 0 is determined by the minimum block size parameter UMCTL2_SARMINSIZE: (x=log2(block size)). Programming Mode: Static Position */
#define UDDRC_SARBASE0_BASE_ADDR0_Msk         (_U_(0x1) << UDDRC_SARBASE0_BASE_ADDR0_Pos)          /**< (UDDRC_SARBASE0) Base address for address region n specified as awaddr[UMCTL2_A_ADDRW-1:x] and araddr[UMCTL2_A_ADDRW-1:x]  where 0 is determined by the minimum block size parameter UMCTL2_SARMINSIZE: (x=log2(block size)). Programming Mode: Static Mask */
#define UDDRC_SARBASE0_BASE_ADDR0(value)      (UDDRC_SARBASE0_BASE_ADDR0_Msk & ((value) << UDDRC_SARBASE0_BASE_ADDR0_Pos))
#define UDDRC_SARBASE0_BASE_ADDR1_Pos         _U_(1)                                               /**< (UDDRC_SARBASE0) Base address for address region n specified as awaddr[UMCTL2_A_ADDRW-1:x] and araddr[UMCTL2_A_ADDRW-1:x]  where 1 is determined by the minimum block size parameter UMCTL2_SARMINSIZE: (x=log2(block size)). Programming Mode: Static Position */
#define UDDRC_SARBASE0_BASE_ADDR1_Msk         (_U_(0x1) << UDDRC_SARBASE0_BASE_ADDR1_Pos)          /**< (UDDRC_SARBASE0) Base address for address region n specified as awaddr[UMCTL2_A_ADDRW-1:x] and araddr[UMCTL2_A_ADDRW-1:x]  where 1 is determined by the minimum block size parameter UMCTL2_SARMINSIZE: (x=log2(block size)). Programming Mode: Static Mask */
#define UDDRC_SARBASE0_BASE_ADDR1(value)      (UDDRC_SARBASE0_BASE_ADDR1_Msk & ((value) << UDDRC_SARBASE0_BASE_ADDR1_Pos))
#define UDDRC_SARBASE0_BASE_ADDR2_Pos         _U_(2)                                               /**< (UDDRC_SARBASE0) Base address for address region n specified as awaddr[UMCTL2_A_ADDRW-1:x] and araddr[UMCTL2_A_ADDRW-1:x]  where 2 is determined by the minimum block size parameter UMCTL2_SARMINSIZE: (x=log2(block size)). Programming Mode: Static Position */
#define UDDRC_SARBASE0_BASE_ADDR2_Msk         (_U_(0x1) << UDDRC_SARBASE0_BASE_ADDR2_Pos)          /**< (UDDRC_SARBASE0) Base address for address region n specified as awaddr[UMCTL2_A_ADDRW-1:x] and araddr[UMCTL2_A_ADDRW-1:x]  where 2 is determined by the minimum block size parameter UMCTL2_SARMINSIZE: (x=log2(block size)). Programming Mode: Static Mask */
#define UDDRC_SARBASE0_BASE_ADDR2(value)      (UDDRC_SARBASE0_BASE_ADDR2_Msk & ((value) << UDDRC_SARBASE0_BASE_ADDR2_Pos))
#define UDDRC_SARBASE0_Msk                    _U_(0x00000007)                                      /**< (UDDRC_SARBASE0) Register Mask  */

#define UDDRC_SARBASE0_BASE_ADDR_Pos          _U_(0)                                               /**< (UDDRC_SARBASE0 Position) Base address for address region n specified as awaddr[UMCTL2_A_ADDRW-x:x] and araddr[UMCTL2_A_ADDRW-x:x]  where 2 is determined by the minimum block size parameter UMCTL2_SARMINSIZE: (x=log2(block size)). Programming Mode: Static */
#define UDDRC_SARBASE0_BASE_ADDR_Msk          (_U_(0x7) << UDDRC_SARBASE0_BASE_ADDR_Pos)           /**< (UDDRC_SARBASE0 Mask) BASE_ADDR */
#define UDDRC_SARBASE0_BASE_ADDR(value)       (UDDRC_SARBASE0_BASE_ADDR_Msk & ((value) << UDDRC_SARBASE0_BASE_ADDR_Pos)) 

/* -------- UDDRC_SARSIZE0 : (UDDRC Offset: 0xF08) (R/W 32) SAR Size Register n -------- */
#define UDDRC_SARSIZE0_RESETVALUE             _U_(0x00)                                            /**<  (UDDRC_SARSIZE0) SAR Size Register n  Reset Value */

#define UDDRC_SARSIZE0_NBLOCKS_Pos            _U_(0)                                               /**< (UDDRC_SARSIZE0) Number of blocks for address region n.  This register determines the total size of the region in multiples of minimum block size as specified by the hardware parameter UMCTL2_SARMINSIZE.     The register value is encoded as number of blocks = nblocks + 1. For example, if register is programmed to 0, region will have 1 block. Programming Mode: Static Position */
#define UDDRC_SARSIZE0_NBLOCKS_Msk            (_U_(0xFF) << UDDRC_SARSIZE0_NBLOCKS_Pos)            /**< (UDDRC_SARSIZE0) Number of blocks for address region n.  This register determines the total size of the region in multiples of minimum block size as specified by the hardware parameter UMCTL2_SARMINSIZE.     The register value is encoded as number of blocks = nblocks + 1. For example, if register is programmed to 0, region will have 1 block. Programming Mode: Static Mask */
#define UDDRC_SARSIZE0_NBLOCKS(value)         (UDDRC_SARSIZE0_NBLOCKS_Msk & ((value) << UDDRC_SARSIZE0_NBLOCKS_Pos))
#define UDDRC_SARSIZE0_Msk                    _U_(0x000000FF)                                      /**< (UDDRC_SARSIZE0) Register Mask  */


/* -------- UDDRC_VER_NUMBER : (UDDRC Offset: 0xFF0) ( R/ 32) Version Number Register -------- */
#define UDDRC_VER_NUMBER_RESETVALUE           _U_(0x3334302A)                                      /**<  (UDDRC_VER_NUMBER) Version Number Register  Reset Value */

#define UDDRC_VER_NUMBER_VER_NUMBER_Pos       _U_(0)                                               /**< (UDDRC_VER_NUMBER) Indicates the Device Version Number value. Programming Mode: Static Position */
#define UDDRC_VER_NUMBER_VER_NUMBER_Msk       (_U_(0xFFFFFFFF) << UDDRC_VER_NUMBER_VER_NUMBER_Pos) /**< (UDDRC_VER_NUMBER) Indicates the Device Version Number value. Programming Mode: Static Mask */
#define UDDRC_VER_NUMBER_VER_NUMBER(value)    (UDDRC_VER_NUMBER_VER_NUMBER_Msk & ((value) << UDDRC_VER_NUMBER_VER_NUMBER_Pos))
#define UDDRC_VER_NUMBER_Msk                  _U_(0xFFFFFFFF)                                      /**< (UDDRC_VER_NUMBER) Register Mask  */


/* -------- UDDRC_VER_TYPE : (UDDRC Offset: 0xFF4) ( R/ 32) Version Type Register -------- */
#define UDDRC_VER_TYPE_RESETVALUE             _U_(0x67612A2A)                                      /**<  (UDDRC_VER_TYPE) Version Type Register  Reset Value */

#define UDDRC_VER_TYPE_VER_TYPE_Pos           _U_(0)                                               /**< (UDDRC_VER_TYPE) Indicates the Device Version Type value. Programming Mode: Static Position */
#define UDDRC_VER_TYPE_VER_TYPE_Msk           (_U_(0xFFFFFFFF) << UDDRC_VER_TYPE_VER_TYPE_Pos)     /**< (UDDRC_VER_TYPE) Indicates the Device Version Type value. Programming Mode: Static Mask */
#define UDDRC_VER_TYPE_VER_TYPE(value)        (UDDRC_VER_TYPE_VER_TYPE_Msk & ((value) << UDDRC_VER_TYPE_VER_TYPE_Pos))
#define UDDRC_VER_TYPE_Msk                    _U_(0xFFFFFFFF)                                      /**< (UDDRC_VER_TYPE) Register Mask  */


/** \brief UDDRC register offsets definitions */
#define UDDRC_MSTR_REG_OFST            (0x00)              /**< (UDDRC_MSTR) Master Register 0 Offset */
#define UDDRC_STAT_REG_OFST            (0x04)              /**< (UDDRC_STAT) Operating Mode Status Register Offset */
#define UDDRC_MRCTRL0_REG_OFST         (0x10)              /**< (UDDRC_MRCTRL0) Mode Register Read/Write Control Register 0 Offset */
#define UDDRC_MRCTRL1_REG_OFST         (0x14)              /**< (UDDRC_MRCTRL1) Mode Register Read/Write Control Register 1 Offset */
#define UDDRC_MRSTAT_REG_OFST          (0x18)              /**< (UDDRC_MRSTAT) Mode Register Read/Write Status Register Offset */
#define UDDRC_DERATEEN_REG_OFST        (0x20)              /**< (UDDRC_DERATEEN) Temperature Derate Enable Register Offset */
#define UDDRC_DERATEINT_REG_OFST       (0x24)              /**< (UDDRC_DERATEINT) Temperature Derate Interval Register Offset */
#define UDDRC_DERATECTL_REG_OFST       (0x2C)              /**< (UDDRC_DERATECTL) Temperature Derate Control Register Offset */
#define UDDRC_PWRCTL_REG_OFST          (0x30)              /**< (UDDRC_PWRCTL) Low Power Control Register Offset */
#define UDDRC_PWRTMG_REG_OFST          (0x34)              /**< (UDDRC_PWRTMG) Low Power Timing Register Offset */
#define UDDRC_HWLPCTL_REG_OFST         (0x38)              /**< (UDDRC_HWLPCTL) Hardware Low Power Control Register Offset */
#define UDDRC_RFSHCTL0_REG_OFST        (0x50)              /**< (UDDRC_RFSHCTL0) Refresh Control Register 0 Offset */
#define UDDRC_RFSHCTL3_REG_OFST        (0x60)              /**< (UDDRC_RFSHCTL3) Refresh Control Register 3 Offset */
#define UDDRC_RFSHTMG_REG_OFST         (0x64)              /**< (UDDRC_RFSHTMG) Refresh Timing Register Offset */
#define UDDRC_CRCPARCTL0_REG_OFST      (0xC0)              /**< (UDDRC_CRCPARCTL0) CRC Parity Control Register0 Offset */
#define UDDRC_CRCPARSTAT_REG_OFST      (0xCC)              /**< (UDDRC_CRCPARSTAT) CRC Parity Status Register Offset */
#define UDDRC_INIT0_REG_OFST           (0xD0)              /**< (UDDRC_INIT0) SDRAM Initialization Register 0 Offset */
#define UDDRC_INIT1_REG_OFST           (0xD4)              /**< (UDDRC_INIT1) SDRAM Initialization Register 1 Offset */
#define UDDRC_INIT2_REG_OFST           (0xD8)              /**< (UDDRC_INIT2) SDRAM Initialization Register 2 Offset */
#define UDDRC_INIT3_REG_OFST           (0xDC)              /**< (UDDRC_INIT3) SDRAM Initialization Register 3 Offset */
#define UDDRC_INIT4_REG_OFST           (0xE0)              /**< (UDDRC_INIT4) SDRAM Initialization Register 4 Offset */
#define UDDRC_INIT5_REG_OFST           (0xE4)              /**< (UDDRC_INIT5) SDRAM Initialization Register 5 Offset */
#define UDDRC_DIMMCTL_REG_OFST         (0xF0)              /**< (UDDRC_DIMMCTL) DIMM Control Register Offset */
#define UDDRC_DRAMTMG0_REG_OFST        (0x100)             /**< (UDDRC_DRAMTMG0) SDRAM Timing Register 0 Offset */
#define UDDRC_DRAMTMG1_REG_OFST        (0x104)             /**< (UDDRC_DRAMTMG1) SDRAM Timing Register 1 Offset */
#define UDDRC_DRAMTMG2_REG_OFST        (0x108)             /**< (UDDRC_DRAMTMG2) SDRAM Timing Register 2 Offset */
#define UDDRC_DRAMTMG3_REG_OFST        (0x10C)             /**< (UDDRC_DRAMTMG3) SDRAM Timing Register 3 Offset */
#define UDDRC_DRAMTMG4_REG_OFST        (0x110)             /**< (UDDRC_DRAMTMG4) SDRAM Timing Register 4 Offset */
#define UDDRC_DRAMTMG5_REG_OFST        (0x114)             /**< (UDDRC_DRAMTMG5) SDRAM Timing Register 5 Offset */
#define UDDRC_DRAMTMG6_REG_OFST        (0x118)             /**< (UDDRC_DRAMTMG6) SDRAM Timing Register 6 Offset */
#define UDDRC_DRAMTMG7_REG_OFST        (0x11C)             /**< (UDDRC_DRAMTMG7) SDRAM Timing Register 7 Offset */
#define UDDRC_DRAMTMG8_REG_OFST        (0x120)             /**< (UDDRC_DRAMTMG8) SDRAM Timing Register 8 Offset */
#define UDDRC_DRAMTMG14_REG_OFST       (0x138)             /**< (UDDRC_DRAMTMG14) SDRAM Timing Register 14 Offset */
#define UDDRC_DRAMTMG15_REG_OFST       (0x13C)             /**< (UDDRC_DRAMTMG15) SDRAM Timing Register 15 Offset */
#define UDDRC_ZQCTL0_REG_OFST          (0x180)             /**< (UDDRC_ZQCTL0) ZQ Control Register 0 Offset */
#define UDDRC_ZQCTL1_REG_OFST          (0x184)             /**< (UDDRC_ZQCTL1) ZQ Control Register 1 Offset */
#define UDDRC_ZQCTL2_REG_OFST          (0x188)             /**< (UDDRC_ZQCTL2) ZQ Control Register 2 Offset */
#define UDDRC_ZQSTAT_REG_OFST          (0x18C)             /**< (UDDRC_ZQSTAT) ZQ Status Register Offset */
#define UDDRC_DFITMG0_REG_OFST         (0x190)             /**< (UDDRC_DFITMG0) DFI Timing Register 0 Offset */
#define UDDRC_DFITMG1_REG_OFST         (0x194)             /**< (UDDRC_DFITMG1) DFI Timing Register 1 Offset */
#define UDDRC_DFILPCFG0_REG_OFST       (0x198)             /**< (UDDRC_DFILPCFG0) DFI Low Power Configuration Register 0 Offset */
#define UDDRC_DFIUPD0_REG_OFST         (0x1A0)             /**< (UDDRC_DFIUPD0) DFI Update Register 0 Offset */
#define UDDRC_DFIUPD1_REG_OFST         (0x1A4)             /**< (UDDRC_DFIUPD1) DFI Update Register 1 Offset */
#define UDDRC_DFIUPD2_REG_OFST         (0x1A8)             /**< (UDDRC_DFIUPD2) DFI Update Register 2 Offset */
#define UDDRC_DFIMISC_REG_OFST         (0x1B0)             /**< (UDDRC_DFIMISC) DFI Miscellaneous Control Register Offset */
#define UDDRC_DFISTAT_REG_OFST         (0x1BC)             /**< (UDDRC_DFISTAT) DFI Status Register Offset */
#define UDDRC_DFIPHYMSTR_REG_OFST      (0x1C4)             /**< (UDDRC_DFIPHYMSTR) DFI PHY Master Offset */
#define UDDRC_ADDRMAP1_REG_OFST        (0x204)             /**< (UDDRC_ADDRMAP1) Address Map Register 1 Offset */
#define UDDRC_ADDRMAP2_REG_OFST        (0x208)             /**< (UDDRC_ADDRMAP2) Address Map Register 2 Offset */
#define UDDRC_ADDRMAP3_REG_OFST        (0x20C)             /**< (UDDRC_ADDRMAP3) Address Map Register 3 Offset */
#define UDDRC_ADDRMAP4_REG_OFST        (0x210)             /**< (UDDRC_ADDRMAP4) Address Map Register 4 Offset */
#define UDDRC_ADDRMAP5_REG_OFST        (0x214)             /**< (UDDRC_ADDRMAP5) Address Map Register 5 Offset */
#define UDDRC_ADDRMAP6_REG_OFST        (0x218)             /**< (UDDRC_ADDRMAP6) Address Map Register 6 Offset */
#define UDDRC_ADDRMAP9_REG_OFST        (0x224)             /**< (UDDRC_ADDRMAP9) Address Map Register 9 Offset */
#define UDDRC_ADDRMAP10_REG_OFST       (0x228)             /**< (UDDRC_ADDRMAP10) Address Map Register 10 Offset */
#define UDDRC_ADDRMAP11_REG_OFST       (0x22C)             /**< (UDDRC_ADDRMAP11) Address Map Register 11 Offset */
#define UDDRC_ODTCFG_REG_OFST          (0x240)             /**< (UDDRC_ODTCFG) ODT Configuration Register Offset */
#define UDDRC_ODTMAP_REG_OFST          (0x244)             /**< (UDDRC_ODTMAP) ODT/Rank Map Register Offset */
#define UDDRC_SCHED_REG_OFST           (0x250)             /**< (UDDRC_SCHED) Scheduler Control Register Offset */
#define UDDRC_SCHED1_REG_OFST          (0x254)             /**< (UDDRC_SCHED1) Scheduler Control Register 1 Offset */
#define UDDRC_PERFHPR1_REG_OFST        (0x25C)             /**< (UDDRC_PERFHPR1) High Priority Read CAM Register 1 Offset */
#define UDDRC_PERFLPR1_REG_OFST        (0x264)             /**< (UDDRC_PERFLPR1) Low Priority Read CAM Register 1 Offset */
#define UDDRC_PERFWR1_REG_OFST         (0x26C)             /**< (UDDRC_PERFWR1) Write CAM Register 1 Offset */
#define UDDRC_DBG0_REG_OFST            (0x300)             /**< (UDDRC_DBG0) Debug Register 0 Offset */
#define UDDRC_DBG1_REG_OFST            (0x304)             /**< (UDDRC_DBG1) Debug Register 1 Offset */
#define UDDRC_DBGCAM_REG_OFST          (0x308)             /**< (UDDRC_DBGCAM) CAM Debug Register Offset */
#define UDDRC_DBGCMD_REG_OFST          (0x30C)             /**< (UDDRC_DBGCMD) Command Debug Register Offset */
#define UDDRC_DBGSTAT_REG_OFST         (0x310)             /**< (UDDRC_DBGSTAT) Status Debug Register Offset */
#define UDDRC_SWCTL_REG_OFST           (0x320)             /**< (UDDRC_SWCTL) Software Register Programming Control Enable Offset */
#define UDDRC_SWSTAT_REG_OFST          (0x324)             /**< (UDDRC_SWSTAT) Software Register Programming Control Status Offset */
#define UDDRC_POISONCFG_REG_OFST       (0x36C)             /**< (UDDRC_POISONCFG) AXI Poison Configuration Register. Common for all AXI ports Offset */
#define UDDRC_POISONSTAT_REG_OFST      (0x370)             /**< (UDDRC_POISONSTAT) AXI Poison Status Register Offset */
#define UDDRC_DERATESTAT_REG_OFST      (0x3F0)             /**< (UDDRC_DERATESTAT) Temperature Derate Status Register Offset */
#define UDDRC_PSTAT_REG_OFST           (0x3FC)             /**< (UDDRC_PSTAT) Port Status Register Offset */
#define UDDRC_PCCFG_REG_OFST           (0x400)             /**< (UDDRC_PCCFG) Port Common Configuration Register Offset */
#define UDDRC_PCFGR_0_REG_OFST         (0x404)             /**< (UDDRC_PCFGR_0) Port n Configuration Read Register Offset */
#define UDDRC_PCFGW_0_REG_OFST         (0x408)             /**< (UDDRC_PCFGW_0) Port n Configuration Write Register Offset */
#define UDDRC_PCTRL_0_REG_OFST         (0x490)             /**< (UDDRC_PCTRL_0) Port n Control Register Offset */
#define UDDRC_PCFGQOS0_0_REG_OFST      (0x494)             /**< (UDDRC_PCFGQOS0_0) Port n Read QoS Configuration Register 0 Offset */
#define UDDRC_PCFGQOS1_0_REG_OFST      (0x498)             /**< (UDDRC_PCFGQOS1_0) Port n Read QoS Configuration Register 1 Offset */
#define UDDRC_PCFGWQOS0_0_REG_OFST     (0x49C)             /**< (UDDRC_PCFGWQOS0_0) Port n Write QoS Configuration Register 0 Offset */
#define UDDRC_PCFGWQOS1_0_REG_OFST     (0x4A0)             /**< (UDDRC_PCFGWQOS1_0) Port n Write QoS Configuration Register 1 Offset */
#define UDDRC_PCFGR_1_REG_OFST         (0x4B4)             /**< (UDDRC_PCFGR_1) Port n Configuration Read Register Offset */
#define UDDRC_PCFGW_1_REG_OFST         (0x4B8)             /**< (UDDRC_PCFGW_1) Port n Configuration Write Register Offset */
#define UDDRC_PCTRL_1_REG_OFST         (0x540)             /**< (UDDRC_PCTRL_1) Port n Control Register Offset */
#define UDDRC_PCFGQOS0_1_REG_OFST      (0x544)             /**< (UDDRC_PCFGQOS0_1) Port n Read QoS Configuration Register 0 Offset */
#define UDDRC_PCFGQOS1_1_REG_OFST      (0x548)             /**< (UDDRC_PCFGQOS1_1) Port n Read QoS Configuration Register 1 Offset */
#define UDDRC_PCFGWQOS0_1_REG_OFST     (0x54C)             /**< (UDDRC_PCFGWQOS0_1) Port n Write QoS Configuration Register 0 Offset */
#define UDDRC_PCFGWQOS1_1_REG_OFST     (0x550)             /**< (UDDRC_PCFGWQOS1_1) Port n Write QoS Configuration Register 1 Offset */
#define UDDRC_PCFGR_2_REG_OFST         (0x564)             /**< (UDDRC_PCFGR_2) Port n Configuration Read Register Offset */
#define UDDRC_PCFGW_2_REG_OFST         (0x568)             /**< (UDDRC_PCFGW_2) Port n Configuration Write Register Offset */
#define UDDRC_PCTRL_2_REG_OFST         (0x5F0)             /**< (UDDRC_PCTRL_2) Port n Control Register Offset */
#define UDDRC_PCFGQOS0_2_REG_OFST      (0x5F4)             /**< (UDDRC_PCFGQOS0_2) Port n Read QoS Configuration Register 0 Offset */
#define UDDRC_PCFGQOS1_2_REG_OFST      (0x5F8)             /**< (UDDRC_PCFGQOS1_2) Port n Read QoS Configuration Register 1 Offset */
#define UDDRC_PCFGWQOS0_2_REG_OFST     (0x5FC)             /**< (UDDRC_PCFGWQOS0_2) Port n Write QoS Configuration Register 0 Offset */
#define UDDRC_PCFGWQOS1_2_REG_OFST     (0x600)             /**< (UDDRC_PCFGWQOS1_2) Port n Write QoS Configuration Register 1 Offset */
#define UDDRC_PCFGR_3_REG_OFST         (0x614)             /**< (UDDRC_PCFGR_3) Port n Configuration Read Register Offset */
#define UDDRC_PCFGW_3_REG_OFST         (0x618)             /**< (UDDRC_PCFGW_3) Port n Configuration Write Register Offset */
#define UDDRC_PCTRL_3_REG_OFST         (0x6A0)             /**< (UDDRC_PCTRL_3) Port n Control Register Offset */
#define UDDRC_PCFGQOS0_3_REG_OFST      (0x6A4)             /**< (UDDRC_PCFGQOS0_3) Port n Read QoS Configuration Register 0 Offset */
#define UDDRC_PCFGQOS1_3_REG_OFST      (0x6A8)             /**< (UDDRC_PCFGQOS1_3) Port n Read QoS Configuration Register 1 Offset */
#define UDDRC_PCFGWQOS0_3_REG_OFST     (0x6AC)             /**< (UDDRC_PCFGWQOS0_3) Port n Write QoS Configuration Register 0 Offset */
#define UDDRC_PCFGWQOS1_3_REG_OFST     (0x6B0)             /**< (UDDRC_PCFGWQOS1_3) Port n Write QoS Configuration Register 1 Offset */
#define UDDRC_PCFGR_4_REG_OFST         (0x6C4)             /**< (UDDRC_PCFGR_4) Port n Configuration Read Register Offset */
#define UDDRC_PCFGW_4_REG_OFST         (0x6C8)             /**< (UDDRC_PCFGW_4) Port n Configuration Write Register Offset */
#define UDDRC_PCTRL_4_REG_OFST         (0x750)             /**< (UDDRC_PCTRL_4) Port n Control Register Offset */
#define UDDRC_PCFGQOS0_4_REG_OFST      (0x754)             /**< (UDDRC_PCFGQOS0_4) Port n Read QoS Configuration Register 0 Offset */
#define UDDRC_PCFGQOS1_4_REG_OFST      (0x758)             /**< (UDDRC_PCFGQOS1_4) Port n Read QoS Configuration Register 1 Offset */
#define UDDRC_PCFGWQOS0_4_REG_OFST     (0x75C)             /**< (UDDRC_PCFGWQOS0_4) Port n Write QoS Configuration Register 0 Offset */
#define UDDRC_PCFGWQOS1_4_REG_OFST     (0x760)             /**< (UDDRC_PCFGWQOS1_4) Port n Write QoS Configuration Register 1 Offset */
#define UDDRC_SARBASE0_REG_OFST        (0xF04)             /**< (UDDRC_SARBASE0) SAR Base Address Register n Offset */
#define UDDRC_SARSIZE0_REG_OFST        (0xF08)             /**< (UDDRC_SARSIZE0) SAR Size Register n Offset */
#define UDDRC_VER_NUMBER_REG_OFST      (0xFF0)             /**< (UDDRC_VER_NUMBER) Version Number Register Offset */
#define UDDRC_VER_TYPE_REG_OFST        (0xFF4)             /**< (UDDRC_VER_TYPE) Version Type Register Offset */

#if !(defined(__ASSEMBLER__) || defined(__IAR_SYSTEMS_ASM__))
/** \brief UDDRC register API structure */
typedef struct
{  /* Enhanced Universal DDR-SDRAM Memory Controller */
  __IO  uint32_t                       UDDRC_MSTR;         /**< Offset: 0x00 (R/W  32) Master Register 0 */
  __I   uint32_t                       UDDRC_STAT;         /**< Offset: 0x04 (R/   32) Operating Mode Status Register */
  __I   uint8_t                        Reserved1[0x08];
  __IO  uint32_t                       UDDRC_MRCTRL0;      /**< Offset: 0x10 (R/W  32) Mode Register Read/Write Control Register 0 */
  __IO  uint32_t                       UDDRC_MRCTRL1;      /**< Offset: 0x14 (R/W  32) Mode Register Read/Write Control Register 1 */
  __I   uint32_t                       UDDRC_MRSTAT;       /**< Offset: 0x18 (R/   32) Mode Register Read/Write Status Register */
  __I   uint8_t                        Reserved2[0x04];
  __IO  uint32_t                       UDDRC_DERATEEN;     /**< Offset: 0x20 (R/W  32) Temperature Derate Enable Register */
  __IO  uint32_t                       UDDRC_DERATEINT;    /**< Offset: 0x24 (R/W  32) Temperature Derate Interval Register */
  __I   uint8_t                        Reserved3[0x04];
  __IO  uint32_t                       UDDRC_DERATECTL;    /**< Offset: 0x2C (R/W  32) Temperature Derate Control Register */
  __IO  uint32_t                       UDDRC_PWRCTL;       /**< Offset: 0x30 (R/W  32) Low Power Control Register */
  __IO  uint32_t                       UDDRC_PWRTMG;       /**< Offset: 0x34 (R/W  32) Low Power Timing Register */
  __IO  uint32_t                       UDDRC_HWLPCTL;      /**< Offset: 0x38 (R/W  32) Hardware Low Power Control Register */
  __I   uint8_t                        Reserved4[0x14];
  __IO  uint32_t                       UDDRC_RFSHCTL0;     /**< Offset: 0x50 (R/W  32) Refresh Control Register 0 */
  __I   uint8_t                        Reserved5[0x0C];
  __IO  uint32_t                       UDDRC_RFSHCTL3;     /**< Offset: 0x60 (R/W  32) Refresh Control Register 3 */
  __IO  uint32_t                       UDDRC_RFSHTMG;      /**< Offset: 0x64 (R/W  32) Refresh Timing Register */
  __I   uint8_t                        Reserved6[0x58];
  __IO  uint32_t                       UDDRC_CRCPARCTL0;   /**< Offset: 0xC0 (R/W  32) CRC Parity Control Register0 */
  __I   uint8_t                        Reserved7[0x08];
  __I   uint32_t                       UDDRC_CRCPARSTAT;   /**< Offset: 0xCC (R/   32) CRC Parity Status Register */
  __IO  uint32_t                       UDDRC_INIT0;        /**< Offset: 0xD0 (R/W  32) SDRAM Initialization Register 0 */
  __IO  uint32_t                       UDDRC_INIT1;        /**< Offset: 0xD4 (R/W  32) SDRAM Initialization Register 1 */
  __IO  uint32_t                       UDDRC_INIT2;        /**< Offset: 0xD8 (R/W  32) SDRAM Initialization Register 2 */
  __IO  uint32_t                       UDDRC_INIT3;        /**< Offset: 0xDC (R/W  32) SDRAM Initialization Register 3 */
  __IO  uint32_t                       UDDRC_INIT4;        /**< Offset: 0xE0 (R/W  32) SDRAM Initialization Register 4 */
  __IO  uint32_t                       UDDRC_INIT5;        /**< Offset: 0xE4 (R/W  32) SDRAM Initialization Register 5 */
  __I   uint8_t                        Reserved8[0x08];
  __IO  uint32_t                       UDDRC_DIMMCTL;      /**< Offset: 0xF0 (R/W  32) DIMM Control Register */
  __I   uint8_t                        Reserved9[0x0C];
  __IO  uint32_t                       UDDRC_DRAMTMG0;     /**< Offset: 0x100 (R/W  32) SDRAM Timing Register 0 */
  __IO  uint32_t                       UDDRC_DRAMTMG1;     /**< Offset: 0x104 (R/W  32) SDRAM Timing Register 1 */
  __IO  uint32_t                       UDDRC_DRAMTMG2;     /**< Offset: 0x108 (R/W  32) SDRAM Timing Register 2 */
  __IO  uint32_t                       UDDRC_DRAMTMG3;     /**< Offset: 0x10C (R/W  32) SDRAM Timing Register 3 */
  __IO  uint32_t                       UDDRC_DRAMTMG4;     /**< Offset: 0x110 (R/W  32) SDRAM Timing Register 4 */
  __IO  uint32_t                       UDDRC_DRAMTMG5;     /**< Offset: 0x114 (R/W  32) SDRAM Timing Register 5 */
  __IO  uint32_t                       UDDRC_DRAMTMG6;     /**< Offset: 0x118 (R/W  32) SDRAM Timing Register 6 */
  __IO  uint32_t                       UDDRC_DRAMTMG7;     /**< Offset: 0x11C (R/W  32) SDRAM Timing Register 7 */
  __IO  uint32_t                       UDDRC_DRAMTMG8;     /**< Offset: 0x120 (R/W  32) SDRAM Timing Register 8 */
  __I   uint8_t                        Reserved10[0x14];
  __IO  uint32_t                       UDDRC_DRAMTMG14;    /**< Offset: 0x138 (R/W  32) SDRAM Timing Register 14 */
  __IO  uint32_t                       UDDRC_DRAMTMG15;    /**< Offset: 0x13C (R/W  32) SDRAM Timing Register 15 */
  __I   uint8_t                        Reserved11[0x40];
  __IO  uint32_t                       UDDRC_ZQCTL0;       /**< Offset: 0x180 (R/W  32) ZQ Control Register 0 */
  __IO  uint32_t                       UDDRC_ZQCTL1;       /**< Offset: 0x184 (R/W  32) ZQ Control Register 1 */
  __IO  uint32_t                       UDDRC_ZQCTL2;       /**< Offset: 0x188 (R/W  32) ZQ Control Register 2 */
  __I   uint32_t                       UDDRC_ZQSTAT;       /**< Offset: 0x18C (R/   32) ZQ Status Register */
  __IO  uint32_t                       UDDRC_DFITMG0;      /**< Offset: 0x190 (R/W  32) DFI Timing Register 0 */
  __IO  uint32_t                       UDDRC_DFITMG1;      /**< Offset: 0x194 (R/W  32) DFI Timing Register 1 */
  __IO  uint32_t                       UDDRC_DFILPCFG0;    /**< Offset: 0x198 (R/W  32) DFI Low Power Configuration Register 0 */
  __I   uint8_t                        Reserved12[0x04];
  __IO  uint32_t                       UDDRC_DFIUPD0;      /**< Offset: 0x1A0 (R/W  32) DFI Update Register 0 */
  __IO  uint32_t                       UDDRC_DFIUPD1;      /**< Offset: 0x1A4 (R/W  32) DFI Update Register 1 */
  __IO  uint32_t                       UDDRC_DFIUPD2;      /**< Offset: 0x1A8 (R/W  32) DFI Update Register 2 */
  __I   uint8_t                        Reserved13[0x04];
  __IO  uint32_t                       UDDRC_DFIMISC;      /**< Offset: 0x1B0 (R/W  32) DFI Miscellaneous Control Register */
  __I   uint8_t                        Reserved14[0x08];
  __I   uint32_t                       UDDRC_DFISTAT;      /**< Offset: 0x1BC (R/   32) DFI Status Register */
  __I   uint8_t                        Reserved15[0x04];
  __IO  uint32_t                       UDDRC_DFIPHYMSTR;   /**< Offset: 0x1C4 (R/W  32) DFI PHY Master */
  __I   uint8_t                        Reserved16[0x3C];
  __IO  uint32_t                       UDDRC_ADDRMAP1;     /**< Offset: 0x204 (R/W  32) Address Map Register 1 */
  __IO  uint32_t                       UDDRC_ADDRMAP2;     /**< Offset: 0x208 (R/W  32) Address Map Register 2 */
  __IO  uint32_t                       UDDRC_ADDRMAP3;     /**< Offset: 0x20C (R/W  32) Address Map Register 3 */
  __IO  uint32_t                       UDDRC_ADDRMAP4;     /**< Offset: 0x210 (R/W  32) Address Map Register 4 */
  __IO  uint32_t                       UDDRC_ADDRMAP5;     /**< Offset: 0x214 (R/W  32) Address Map Register 5 */
  __IO  uint32_t                       UDDRC_ADDRMAP6;     /**< Offset: 0x218 (R/W  32) Address Map Register 6 */
  __I   uint8_t                        Reserved17[0x08];
  __IO  uint32_t                       UDDRC_ADDRMAP9;     /**< Offset: 0x224 (R/W  32) Address Map Register 9 */
  __IO  uint32_t                       UDDRC_ADDRMAP10;    /**< Offset: 0x228 (R/W  32) Address Map Register 10 */
  __IO  uint32_t                       UDDRC_ADDRMAP11;    /**< Offset: 0x22C (R/W  32) Address Map Register 11 */
  __I   uint8_t                        Reserved18[0x10];
  __IO  uint32_t                       UDDRC_ODTCFG;       /**< Offset: 0x240 (R/W  32) ODT Configuration Register */
  __IO  uint32_t                       UDDRC_ODTMAP;       /**< Offset: 0x244 (R/W  32) ODT/Rank Map Register */
  __I   uint8_t                        Reserved19[0x08];
  __IO  uint32_t                       UDDRC_SCHED;        /**< Offset: 0x250 (R/W  32) Scheduler Control Register */
  __IO  uint32_t                       UDDRC_SCHED1;       /**< Offset: 0x254 (R/W  32) Scheduler Control Register 1 */
  __I   uint8_t                        Reserved20[0x04];
  __IO  uint32_t                       UDDRC_PERFHPR1;     /**< Offset: 0x25C (R/W  32) High Priority Read CAM Register 1 */
  __I   uint8_t                        Reserved21[0x04];
  __IO  uint32_t                       UDDRC_PERFLPR1;     /**< Offset: 0x264 (R/W  32) Low Priority Read CAM Register 1 */
  __I   uint8_t                        Reserved22[0x04];
  __IO  uint32_t                       UDDRC_PERFWR1;      /**< Offset: 0x26C (R/W  32) Write CAM Register 1 */
  __I   uint8_t                        Reserved23[0x90];
  __IO  uint32_t                       UDDRC_DBG0;         /**< Offset: 0x300 (R/W  32) Debug Register 0 */
  __IO  uint32_t                       UDDRC_DBG1;         /**< Offset: 0x304 (R/W  32) Debug Register 1 */
  __I   uint32_t                       UDDRC_DBGCAM;       /**< Offset: 0x308 (R/   32) CAM Debug Register */
  __IO  uint32_t                       UDDRC_DBGCMD;       /**< Offset: 0x30C (R/W  32) Command Debug Register */
  __I   uint32_t                       UDDRC_DBGSTAT;      /**< Offset: 0x310 (R/   32) Status Debug Register */
  __I   uint8_t                        Reserved24[0x0C];
  __IO  uint32_t                       UDDRC_SWCTL;        /**< Offset: 0x320 (R/W  32) Software Register Programming Control Enable */
  __I   uint32_t                       UDDRC_SWSTAT;       /**< Offset: 0x324 (R/   32) Software Register Programming Control Status */
  __I   uint8_t                        Reserved25[0x44];
  __IO  uint32_t                       UDDRC_POISONCFG;    /**< Offset: 0x36C (R/W  32) AXI Poison Configuration Register. Common for all AXI ports */
  __I   uint32_t                       UDDRC_POISONSTAT;   /**< Offset: 0x370 (R/   32) AXI Poison Status Register */
  __I   uint8_t                        Reserved26[0x7C];
  __I   uint32_t                       UDDRC_DERATESTAT;   /**< Offset: 0x3F0 (R/   32) Temperature Derate Status Register */
  __I   uint8_t                        Reserved27[0x08];
  __I   uint32_t                       UDDRC_PSTAT;        /**< Offset: 0x3FC (R/   32) Port Status Register */
  __IO  uint32_t                       UDDRC_PCCFG;        /**< Offset: 0x400 (R/W  32) Port Common Configuration Register */
  __IO  uint32_t                       UDDRC_PCFGR_0;      /**< Offset: 0x404 (R/W  32) Port n Configuration Read Register */
  __IO  uint32_t                       UDDRC_PCFGW_0;      /**< Offset: 0x408 (R/W  32) Port n Configuration Write Register */
  __I   uint8_t                        Reserved28[0x84];
  __IO  uint32_t                       UDDRC_PCTRL_0;      /**< Offset: 0x490 (R/W  32) Port n Control Register */
  __IO  uint32_t                       UDDRC_PCFGQOS0_0;   /**< Offset: 0x494 (R/W  32) Port n Read QoS Configuration Register 0 */
  __IO  uint32_t                       UDDRC_PCFGQOS1_0;   /**< Offset: 0x498 (R/W  32) Port n Read QoS Configuration Register 1 */
  __IO  uint32_t                       UDDRC_PCFGWQOS0_0;  /**< Offset: 0x49C (R/W  32) Port n Write QoS Configuration Register 0 */
  __IO  uint32_t                       UDDRC_PCFGWQOS1_0;  /**< Offset: 0x4A0 (R/W  32) Port n Write QoS Configuration Register 1 */
  __I   uint8_t                        Reserved29[0x10];
  __IO  uint32_t                       UDDRC_PCFGR_1;      /**< Offset: 0x4B4 (R/W  32) Port n Configuration Read Register */
  __IO  uint32_t                       UDDRC_PCFGW_1;      /**< Offset: 0x4B8 (R/W  32) Port n Configuration Write Register */
  __I   uint8_t                        Reserved30[0x84];
  __IO  uint32_t                       UDDRC_PCTRL_1;      /**< Offset: 0x540 (R/W  32) Port n Control Register */
  __IO  uint32_t                       UDDRC_PCFGQOS0_1;   /**< Offset: 0x544 (R/W  32) Port n Read QoS Configuration Register 0 */
  __IO  uint32_t                       UDDRC_PCFGQOS1_1;   /**< Offset: 0x548 (R/W  32) Port n Read QoS Configuration Register 1 */
  __IO  uint32_t                       UDDRC_PCFGWQOS0_1;  /**< Offset: 0x54C (R/W  32) Port n Write QoS Configuration Register 0 */
  __IO  uint32_t                       UDDRC_PCFGWQOS1_1;  /**< Offset: 0x550 (R/W  32) Port n Write QoS Configuration Register 1 */
  __I   uint8_t                        Reserved31[0x10];
  __IO  uint32_t                       UDDRC_PCFGR_2;      /**< Offset: 0x564 (R/W  32) Port n Configuration Read Register */
  __IO  uint32_t                       UDDRC_PCFGW_2;      /**< Offset: 0x568 (R/W  32) Port n Configuration Write Register */
  __I   uint8_t                        Reserved32[0x84];
  __IO  uint32_t                       UDDRC_PCTRL_2;      /**< Offset: 0x5F0 (R/W  32) Port n Control Register */
  __IO  uint32_t                       UDDRC_PCFGQOS0_2;   /**< Offset: 0x5F4 (R/W  32) Port n Read QoS Configuration Register 0 */
  __IO  uint32_t                       UDDRC_PCFGQOS1_2;   /**< Offset: 0x5F8 (R/W  32) Port n Read QoS Configuration Register 1 */
  __IO  uint32_t                       UDDRC_PCFGWQOS0_2;  /**< Offset: 0x5FC (R/W  32) Port n Write QoS Configuration Register 0 */
  __IO  uint32_t                       UDDRC_PCFGWQOS1_2;  /**< Offset: 0x600 (R/W  32) Port n Write QoS Configuration Register 1 */
  __I   uint8_t                        Reserved33[0x10];
  __IO  uint32_t                       UDDRC_PCFGR_3;      /**< Offset: 0x614 (R/W  32) Port n Configuration Read Register */
  __IO  uint32_t                       UDDRC_PCFGW_3;      /**< Offset: 0x618 (R/W  32) Port n Configuration Write Register */
  __I   uint8_t                        Reserved34[0x84];
  __IO  uint32_t                       UDDRC_PCTRL_3;      /**< Offset: 0x6A0 (R/W  32) Port n Control Register */
  __IO  uint32_t                       UDDRC_PCFGQOS0_3;   /**< Offset: 0x6A4 (R/W  32) Port n Read QoS Configuration Register 0 */
  __IO  uint32_t                       UDDRC_PCFGQOS1_3;   /**< Offset: 0x6A8 (R/W  32) Port n Read QoS Configuration Register 1 */
  __IO  uint32_t                       UDDRC_PCFGWQOS0_3;  /**< Offset: 0x6AC (R/W  32) Port n Write QoS Configuration Register 0 */
  __IO  uint32_t                       UDDRC_PCFGWQOS1_3;  /**< Offset: 0x6B0 (R/W  32) Port n Write QoS Configuration Register 1 */
  __I   uint8_t                        Reserved35[0x10];
  __IO  uint32_t                       UDDRC_PCFGR_4;      /**< Offset: 0x6C4 (R/W  32) Port n Configuration Read Register */
  __IO  uint32_t                       UDDRC_PCFGW_4;      /**< Offset: 0x6C8 (R/W  32) Port n Configuration Write Register */
  __I   uint8_t                        Reserved36[0x84];
  __IO  uint32_t                       UDDRC_PCTRL_4;      /**< Offset: 0x750 (R/W  32) Port n Control Register */
  __IO  uint32_t                       UDDRC_PCFGQOS0_4;   /**< Offset: 0x754 (R/W  32) Port n Read QoS Configuration Register 0 */
  __IO  uint32_t                       UDDRC_PCFGQOS1_4;   /**< Offset: 0x758 (R/W  32) Port n Read QoS Configuration Register 1 */
  __IO  uint32_t                       UDDRC_PCFGWQOS0_4;  /**< Offset: 0x75C (R/W  32) Port n Write QoS Configuration Register 0 */
  __IO  uint32_t                       UDDRC_PCFGWQOS1_4;  /**< Offset: 0x760 (R/W  32) Port n Write QoS Configuration Register 1 */
  __I   uint8_t                        Reserved37[0x7A0];
  __IO  uint32_t                       UDDRC_SARBASE0;     /**< Offset: 0xF04 (R/W  32) SAR Base Address Register n */
  __IO  uint32_t                       UDDRC_SARSIZE0;     /**< Offset: 0xF08 (R/W  32) SAR Size Register n */
  __I   uint8_t                        Reserved38[0xE4];
  __I   uint32_t                       UDDRC_VER_NUMBER;   /**< Offset: 0xFF0 (R/   32) Version Number Register */
  __I   uint32_t                       UDDRC_VER_TYPE;     /**< Offset: 0xFF4 (R/   32) Version Type Register */
} uddrc_registers_t;


#endif /* !(defined(__ASSEMBLER__) || defined(__IAR_SYSTEMS_ASM__)) */
#endif /* _SAMA7G_UDDRC_COMPONENT_H_ */
